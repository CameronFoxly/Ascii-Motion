[{"filePath":"/Users/cameronfoxly/GitHubRepos/Ascii-Motion/dev-tools/clipboard-test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/cameronfoxly/GitHubRepos/Ascii-Motion/dev-tools/debug-video-export.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/cameronfoxly/GitHubRepos/Ascii-Motion/dev-tools/gridColorTest.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/cameronfoxly/GitHubRepos/Ascii-Motion/dev-tools/test-frame-timing.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/cameronfoxly/GitHubRepos/Ascii-Motion/dev-tools/test-json-html-export.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/cameronfoxly/GitHubRepos/Ascii-Motion/dev-tools/test-video-export.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/cameronfoxly/GitHubRepos/Ascii-Motion/dev-tools/test-video-loops.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/cameronfoxly/GitHubRepos/Ascii-Motion/eslint.config.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/cameronfoxly/GitHubRepos/Ascii-Motion/postcss.config.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/cameronfoxly/GitHubRepos/Ascii-Motion/public/ffmpeg/ffmpeg-core.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/cameronfoxly/GitHubRepos/Ascii-Motion/scripts/version-bump.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/cameronfoxly/GitHubRepos/Ascii-Motion/src/App.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/cameronfoxly/GitHubRepos/Ascii-Motion/src/components/common/AppReveal.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/cameronfoxly/GitHubRepos/Ascii-Motion/src/components/common/CellRenderer.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/cameronfoxly/GitHubRepos/Ascii-Motion/src/components/common/CollapsibleHeader.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/cameronfoxly/GitHubRepos/Ascii-Motion/src/components/common/CollapsiblePanel.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/cameronfoxly/GitHubRepos/Ascii-Motion/src/components/common/DraggableDialogBar.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/cameronfoxly/GitHubRepos/Ascii-Motion/src/components/common/PanelSeparator.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/cameronfoxly/GitHubRepos/Ascii-Motion/src/components/common/PanelToggleButton.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/cameronfoxly/GitHubRepos/Ascii-Motion/src/components/common/PerformanceMonitor.tsx","messages":[{"ruleId":"react-refresh/only-export-components","severity":2,"message":"Fast refresh only works when a file only exports components. Use a new file to share constants or functions between components.","line":142,"column":14,"nodeType":"Identifier","messageId":"namedExport","endLine":142,"endColumn":35}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useCallback, useState } from 'react'\nimport { Button } from '@/components/ui/button'\nimport { useCanvasStore } from '../../stores/canvasStore'\nimport { \n  logPerformanceStats, \n  testLargeGridPerformance, \n  clearPerformanceHistory \n} from '../../utils/performance';\n\ninterface PerformanceTestResult {\n  gridSize: string;\n  avgRenderTime: number;\n  recommendation: string;\n}\n\n/**\n * Development component for testing canvas performance\n * Only visible in development mode for performance monitoring\n */\nexport const PerformanceMonitor: React.FC = () => {\n  const { setCanvasSize } = useCanvasStore();\n  const [testResults, setTestResults] = useState<PerformanceTestResult[]>([]);\n  const [isTesting, setIsTesting] = useState(false);\n\n  // Run performance tests on various grid sizes\n  const runPerformanceTests = useCallback(async () => {\n    setIsTesting(true);\n    setTestResults([]);\n    \n    const testSizes = [\n      { width: 80, height: 24 },   // Standard\n      { width: 120, height: 40 },  // Medium\n      { width: 160, height: 60 },  // Large\n      { width: 200, height: 100 }  // Extra Large\n    ];\n\n    const results: PerformanceTestResult[] = [];\n\n    for (const size of testSizes) {\n      try {\n        // Set canvas to test size\n        setCanvasSize(size.width, size.height);\n        \n        // Wait a moment for render\n        await new Promise(resolve => setTimeout(resolve, 100));\n        \n        // Run performance test\n        const result = await testLargeGridPerformance(size.width, size.height);\n        results.push(result);\n        \n      } catch (error) {\n        console.error(`❌ Test failed for ${size.width}x${size.height}:`, error);\n      }\n    }\n\n    setTestResults(results);\n    setIsTesting(false);\n    \n    // Reset to standard size\n    setCanvasSize(80, 24);\n  }, [setCanvasSize]);\n\n  const handleLogStats = useCallback(() => {\n    logPerformanceStats();\n  }, []);\n\n  const handleClearHistory = useCallback(() => {\n    clearPerformanceHistory();\n    setTestResults([]);\n  }, []);\n\n  // Only show in development mode\n  if (!import.meta.env.DEV) {\n    return null;\n  }\n\n  return (\n    <div className=\"fixed bottom-4 right-4 bg-white border border-gray-300 rounded-lg p-4 shadow-lg max-w-md\">\n      <h3 className=\"font-semibold text-sm mb-2\">🎯 Performance Monitor</h3>\n      \n      <div className=\"space-y-2\">\n        <div className=\"flex gap-2\">\n          <Button\n            onClick={handleLogStats}\n            size=\"sm\"\n            variant=\"outline\"\n            className=\"text-xs\"\n          >\n            Log Stats\n          </Button>\n          \n          <Button\n            onClick={runPerformanceTests}\n            size=\"sm\"\n            variant=\"outline\"\n            className=\"text-xs\"\n            disabled={isTesting}\n          >\n            {isTesting ? 'Testing...' : 'Test Grid Sizes'}\n          </Button>\n          \n          <Button\n            onClick={handleClearHistory}\n            size=\"sm\"\n            variant=\"outline\"\n            className=\"text-xs\"\n          >\n            Clear\n          </Button>\n        </div>\n\n        {testResults.length > 0 && (\n          <div className=\"mt-3\">\n            <h4 className=\"text-xs font-medium mb-2\">Test Results:</h4>\n            <div className=\"space-y-1 max-h-32 overflow-y-auto\">\n              {testResults.map((result, index) => (\n                <div key={index} className=\"text-xs p-2 bg-gray-50 rounded\">\n                  <div className=\"font-medium\">{result.gridSize}</div>\n                  <div className=\"text-gray-600\">\n                    {result.avgRenderTime.toFixed(2)}ms avg\n                  </div>\n                  <div className=\"text-gray-500 text-[10px]\">\n                    {result.recommendation}\n                  </div>\n                </div>\n              ))}\n            </div>\n          </div>\n        )}\n\n        <div className=\"text-[10px] text-gray-500 border-t pt-2\">\n          Step 5.1 Performance Optimizations Active\n          <br />\n          Check console for detailed metrics\n        </div>\n      </div>\n    </div>\n  );\n};\n\n// Hook to conditionally render performance monitor\nexport const usePerformanceMonitor = () => {\n  const [showMonitor, setShowMonitor] = useState(import.meta.env.DEV);\n  \n  return {\n    showMonitor,\n    setShowMonitor,\n    PerformanceMonitor\n  };\n};\n","usedDeprecatedRules":[]},{"filePath":"/Users/cameronfoxly/GitHubRepos/Ascii-Motion/src/components/common/PerformanceOverlay.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/cameronfoxly/GitHubRepos/Ascii-Motion/src/components/common/Spinner.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/cameronfoxly/GitHubRepos/Ascii-Motion/src/components/common/ThemeToggle.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/cameronfoxly/GitHubRepos/Ascii-Motion/src/components/common/VersionDisplay.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/cameronfoxly/GitHubRepos/Ascii-Motion/src/components/features/AboutDialog.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/cameronfoxly/GitHubRepos/Ascii-Motion/src/components/features/ActiveStyleSection.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/cameronfoxly/GitHubRepos/Ascii-Motion/src/components/features/AnimationTimeline.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/cameronfoxly/GitHubRepos/Ascii-Motion/src/components/features/AsciiTypePanel.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/cameronfoxly/GitHubRepos/Ascii-Motion/src/components/features/AsciiTypePreviewDialog.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/cameronfoxly/GitHubRepos/Ascii-Motion/src/components/features/BackgroundColorMappingSection.tsx","messages":[{"ruleId":"prefer-const","severity":2,"message":"'currentIndex' is never reassigned. Use 'const' instead.","line":344,"column":9,"nodeType":"Identifier","messageId":"useConst","endLine":344,"endColumn":21,"fix":{"range":[11086,11117],"text":"const currentIndex = sourceIndex;"}},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":469,"column":57,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":469,"endColumn":60,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[16314,16317],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[16314,16317],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":487,"column":51,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":487,"endColumn":54,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[17320,17323],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[17320,17323],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":1,"fixableWarningCount":0,"source":"/**\n * BackgroundColorMappingSection - Collapsible section for background color palette mapping controls\n * \n * Features:\n * - Collapsible header with enable/disable toggle\n * - Full palette editing: color swatches, inline editing, reordering, reverse button\n * - Palette manager integration for sharing palettes between editors\n * - Consistent UI patterns following main app palette component and TextColorMappingSection\n */\n\nimport { useState, useMemo } from 'react';\nimport { Button } from '../ui/button';\nimport { Label } from '../ui/label';\nimport { Card, CardContent } from '../ui/card';\nimport { \n  Select,\n  SelectContent,\n  SelectItem,\n  SelectSeparator,\n  SelectTrigger,\n  SelectValue,\n} from '../ui/select';\nimport { \n  Collapsible,\n  CollapsibleContent,\n  CollapsibleTrigger,\n} from '../ui/collapsible';\n\nimport { Checkbox } from '../ui/checkbox';\nimport { Tooltip, TooltipContent, TooltipProvider, TooltipTrigger } from '../ui/tooltip';\nimport { \n  Square, \n  Plus,\n  Trash2,\n  ChevronLeft,\n  ChevronRight,\n  ArrowUpDown,\n  Settings,\n  Upload,\n  Download,\n  Edit,\n  ChevronDown\n} from 'lucide-react';\nimport { usePaletteStore } from '../../stores/paletteStore';\nimport { useImportSettings } from '../../stores/importStore';\nimport { ColorPickerOverlay } from './ColorPickerOverlay';\nimport { ManagePalettesDialog } from './ManagePalettesDialog';\nimport { ImportPaletteDialog } from './ImportPaletteDialog';\nimport { ExportPaletteDialog } from './ExportPaletteDialog';\n\ninterface BackgroundColorMappingSectionProps {\n  onSettingsChange?: () => void;\n}\n\nexport function BackgroundColorMappingSection({ onSettingsChange }: BackgroundColorMappingSectionProps) {\n  const [isOpen, setIsOpen] = useState(false);\n  const [isColorPickerOpen, setIsColorPickerOpen] = useState(false);\n  const [colorPickerInitialColor, setColorPickerInitialColor] = useState('#ffffff');\n  const [editingColorId, setEditingColorId] = useState<string | null>(null);\n  const [isManagePalettesOpen, setIsManagePalettesOpen] = useState(false);\n  const [isImportDialogOpen, setIsImportDialogOpen] = useState(false);\n  const [isExportDialogOpen, setIsExportDialogOpen] = useState(false);\n  \n  // Drag and drop state\n  const [draggedColorId, setDraggedColorId] = useState<string | null>(null);\n  const [dropIndicatorIndex, setDropIndicatorIndex] = useState<number | null>(null);\n  \n  // Import settings\n  const { settings, updateSettings } = useImportSettings();\n  const {\n    enableBackgroundColorMapping,\n    backgroundColorPaletteId,\n    backgroundColorMappingMode\n  } = settings;\n  \n  // Color palette store integration\n  const { \n    palettes,\n    customPalettes,\n    selectedColorId,\n    setSelectedColor,\n    addColor,\n    removeColor,\n    updateColor,\n    moveColorLeft,\n    moveColorRight,\n    reversePalette,\n    createCustomCopy,\n  } = usePaletteStore();\n  \n  // Get the currently selected palette for background color mapping\n  const selectedPalette = useMemo(() => {\n    const allPalettes = [...palettes, ...customPalettes];\n    return allPalettes.find(p => p.id === backgroundColorPaletteId);\n  }, [palettes, customPalettes, backgroundColorPaletteId]);\n\n  const handleToggleEnabled = (enabled: boolean) => {\n    updateSettings({ enableBackgroundColorMapping: enabled });\n    onSettingsChange?.();\n  };\n  \n  const handlePaletteChange = (paletteId: string) => {\n    updateSettings({ backgroundColorPaletteId: paletteId });\n    onSettingsChange?.();\n  };\n  \n  const handleMappingModeChange = (mode: 'closest' | 'dithering' | 'by-index') => {\n    updateSettings({ backgroundColorMappingMode: mode });\n    onSettingsChange?.();\n  };\n\n  // Color palette editing handlers\n  const handleColorDoubleClick = (color: string) => {\n    if (!selectedPalette) return;\n    \n    // If it's a preset palette, create a custom copy first\n    if (selectedPalette.isPreset) {\n      const newPaletteId = createCustomCopy(selectedPalette.id);\n      if (newPaletteId) {\n        // Switch to the new custom palette\n        updateSettings({ backgroundColorPaletteId: newPaletteId });\n        // Find the color in the new palette and edit it\n        const newPalette = customPalettes.find(p => p.id === newPaletteId);\n        if (newPalette) {\n          const colorObj = newPalette.colors.find(c => c.value === color);\n          if (colorObj) {\n            setEditingColorId(colorObj.id);\n            setColorPickerInitialColor(color);\n            setIsColorPickerOpen(true);\n          }\n        }\n        onSettingsChange?.();\n      }\n      return;\n    }\n    \n    // For custom palettes, edit directly\n    const colorObj = selectedPalette.colors.find(c => c.value === color);\n    if (colorObj) {\n      setEditingColorId(colorObj.id);\n      setColorPickerInitialColor(color);\n      setIsColorPickerOpen(true);\n    }\n  };\n\n  const handleColorPickerSelect = (newColor: string) => {\n    if (editingColorId && selectedPalette) {\n      updateColor(selectedPalette.id, editingColorId, newColor);\n      setEditingColorId(null);\n      onSettingsChange?.();\n    }\n  };\n\n  const handleEditColor = () => {\n    if (!selectedColorId || !selectedPalette) return;\n    \n    const colorObj = selectedPalette.colors.find(c => c.id === selectedColorId);\n    if (!colorObj) return;\n    \n    // If it's a preset palette, create a custom copy first\n    if (selectedPalette.isPreset) {\n      const newPaletteId = createCustomCopy(selectedPalette.id);\n      if (newPaletteId) {\n        updateSettings({ backgroundColorPaletteId: newPaletteId });\n        // Find the color in the new palette and edit it\n        const newPalette = customPalettes.find(p => p.id === newPaletteId);\n        if (newPalette) {\n          const newColorObj = newPalette.colors.find(c => c.value === colorObj.value);\n          if (newColorObj) {\n            setEditingColorId(newColorObj.id);\n            setColorPickerInitialColor(colorObj.value);\n            setIsColorPickerOpen(true);\n          }\n        }\n        onSettingsChange?.();\n      }\n      return;\n    }\n    \n    // For custom palettes, edit directly\n    setEditingColorId(colorObj.id);\n    setColorPickerInitialColor(colorObj.value);\n    setIsColorPickerOpen(true);\n  };\n\n  const handleAddColor = () => {\n    if (!selectedPalette) return;\n    \n    // If it's a preset palette, create a custom copy first\n    if (selectedPalette.isPreset) {\n      const newPaletteId = createCustomCopy(selectedPalette.id);\n      if (newPaletteId) {\n        updateSettings({ backgroundColorPaletteId: newPaletteId });\n        addColor(newPaletteId, '#ffffff');\n        onSettingsChange?.();\n      }\n      return;\n    }\n    \n    addColor(selectedPalette.id, '#ffffff');\n    onSettingsChange?.();\n  };\n\n  const handleRemoveColor = (colorId: string) => {\n    if (!selectedPalette || selectedPalette.colors.length <= 1) return;\n    \n    // If it's a preset palette, create a custom copy first\n    if (selectedPalette.isPreset) {\n      const newPaletteId = createCustomCopy(selectedPalette.id);\n      if (newPaletteId) {\n        updateSettings({ backgroundColorPaletteId: newPaletteId });\n        removeColor(newPaletteId, colorId);\n        onSettingsChange?.();\n      }\n      return;\n    }\n    \n    removeColor(selectedPalette.id, colorId);\n    onSettingsChange?.();\n  };\n\n  const handleMoveColorLeft = (colorId: string) => {\n    if (!selectedPalette) return;\n    \n    // If it's a preset palette, create a custom copy first\n    if (selectedPalette.isPreset) {\n      const newPaletteId = createCustomCopy(selectedPalette.id);\n      if (newPaletteId) {\n        updateSettings({ backgroundColorPaletteId: newPaletteId });\n        moveColorLeft(newPaletteId, colorId);\n        onSettingsChange?.();\n      }\n      return;\n    }\n    \n    moveColorLeft(selectedPalette.id, colorId);\n    onSettingsChange?.();\n  };\n\n  const handleMoveColorRight = (colorId: string) => {\n    if (!selectedPalette) return;\n    \n    // If it's a preset palette, create a custom copy first\n    if (selectedPalette.isPreset) {\n      const newPaletteId = createCustomCopy(selectedPalette.id);\n      if (newPaletteId) {\n        updateSettings({ backgroundColorPaletteId: newPaletteId });\n        moveColorRight(newPaletteId, colorId);\n        onSettingsChange?.();\n      }\n      return;\n    }\n    \n    moveColorRight(selectedPalette.id, colorId);\n    onSettingsChange?.();\n  };\n\n  const handleReversePalette = () => {\n    if (!selectedPalette) return;\n    \n    // If it's a preset palette, create a custom copy first\n    if (selectedPalette.isPreset) {\n      const newPaletteId = createCustomCopy(selectedPalette.id);\n      if (newPaletteId) {\n        updateSettings({ backgroundColorPaletteId: newPaletteId });\n        reversePalette(newPaletteId);\n        onSettingsChange?.();\n      }\n      return;\n    }\n    \n    reversePalette(selectedPalette.id);\n    onSettingsChange?.();\n  };\n\n  // Handle drag start\n  const handleDragStart = (e: React.DragEvent, colorId: string) => {\n    if (!selectedPalette) {\n      e.preventDefault();\n      return;\n    }\n    setDraggedColorId(colorId);\n    e.dataTransfer.effectAllowed = 'move';\n  };\n\n  // Handle drag over\n  const handleDragOver = (e: React.DragEvent, targetColorId?: string) => {\n    if (!selectedPalette || !draggedColorId) return;\n    e.preventDefault();\n    e.dataTransfer.dropEffect = 'move';\n    \n    if (targetColorId) {\n      const targetIndex = selectedPalette.colors.findIndex(c => c.id === targetColorId);\n      if (targetIndex !== -1) {\n        // Determine if we should show indicator before or after based on mouse position\n        const rect = (e.target as HTMLElement).getBoundingClientRect();\n        const mouseX = e.clientX - rect.left;\n        const isAfter = mouseX > rect.width / 2;\n        setDropIndicatorIndex(isAfter ? targetIndex + 1 : targetIndex);\n      }\n    }\n  };\n\n  // Handle drop\n  const handleDrop = (e: React.DragEvent, targetColorId: string) => {\n    e.preventDefault();\n    if (!selectedPalette || !draggedColorId || draggedColorId === targetColorId) {\n      setDraggedColorId(null);\n      setDropIndicatorIndex(null);\n      return;\n    }\n\n    // Find indices of source and target colors\n    const sourceIndex = selectedPalette.colors.findIndex(c => c.id === draggedColorId);\n    const targetIndex = selectedPalette.colors.findIndex(c => c.id === targetColorId);\n    \n    if (sourceIndex === -1 || targetIndex === -1) {\n      setDraggedColorId(null);\n      setDropIndicatorIndex(null);\n      return;\n    }\n\n    // If it's a preset palette, create a custom copy first\n    let paletteId = selectedPalette.id;\n    if (selectedPalette.isPreset) {\n      const newPaletteId = createCustomCopy(selectedPalette.id);\n      if (newPaletteId) {\n        paletteId = newPaletteId;\n        updateSettings({ backgroundColorPaletteId: newPaletteId });\n      } else {\n        setDraggedColorId(null);\n        setDropIndicatorIndex(null);\n        return;\n      }\n    }\n\n    // Determine final position based on drop indicator\n    let finalTargetIndex = targetIndex;\n    if (dropIndicatorIndex === targetIndex + 1) {\n      finalTargetIndex = targetIndex + 1;\n    }\n\n    // Move the colors\n    let currentIndex = sourceIndex;\n    if (currentIndex < finalTargetIndex) {\n      // Moving right - use moveColorRight\n      for (let i = 0; i < finalTargetIndex - sourceIndex; i++) {\n        moveColorRight(paletteId, draggedColorId);\n      }\n    } else if (currentIndex > finalTargetIndex) {\n      // Moving left - use moveColorLeft\n      for (let i = 0; i < sourceIndex - finalTargetIndex; i++) {\n        moveColorLeft(paletteId, draggedColorId);\n      }\n    }\n\n    setDraggedColorId(null);\n    setDropIndicatorIndex(null);\n    onSettingsChange?.();\n  };\n\n  // Handle drag leave\n  const handleDragLeave = (e: React.DragEvent) => {\n    // Only clear if leaving the grid container\n    if (!e.currentTarget.contains(e.relatedTarget as Node)) {\n      setDropIndicatorIndex(null);\n    }\n  };\n\n  return (\n    <>\n      <Collapsible open={isOpen} onOpenChange={setIsOpen}>\n        <CollapsibleTrigger asChild>\n          <Button \n            variant=\"ghost\" \n            className=\"w-full h-auto text-xs justify-between py-1 px-1 my-1\"\n          >\n            <div className=\"flex items-center gap-2\">\n              <Square className=\"w-4 h-4\" />\n              <span>Background Color Mapping</span>\n              <Checkbox\n                id=\"enable-background-color-mapping\"\n                checked={enableBackgroundColorMapping}\n                onCheckedChange={handleToggleEnabled}\n                className=\"ml-2\"\n                onClick={(e) => e.stopPropagation()}\n              />\n            </div>\n            <ChevronDown \n              className={`h-3 w-3 transition-transform duration-200 ${\n                isOpen ? 'rotate-180' : ''\n              }`}\n            />\n          </Button>\n        </CollapsibleTrigger>\n        \n        <CollapsibleContent className=\"collapsible-content space-y-3 mt-2\">\n          <div className=\"w-full\">\n            {!enableBackgroundColorMapping && (\n              <div className=\"p-3 border border-border/50 rounded-lg bg-muted/20\">\n                <p className=\"text-xs text-muted-foreground text-center\">\n                  Background color mapping is disabled. Characters will use default background colors.\n                </p>\n              </div>\n            )}\n            \n            {enableBackgroundColorMapping && (\n              <Card className=\"bg-card/30 border-border/50\">\n                <CardContent className=\"p-3 space-y-3\">\n                {/* Palette Selection */}\n                <div className=\"space-y-2\">\n                  <div className=\"flex items-center justify-between\">\n                    <Label className=\"text-xs font-medium\">Color Palette</Label>\n                    {enableBackgroundColorMapping && (\n                      <div className=\"flex gap-1\">\n                        <TooltipProvider>\n                          <Tooltip>\n                            <TooltipTrigger asChild>\n                              <Button\n                                size=\"sm\"\n                                variant=\"outline\"\n                                className=\"h-6 w-6 p-0\"\n                                onClick={() => setIsManagePalettesOpen(true)}\n                              >\n                                <Plus className=\"h-3 w-3\" />\n                              </Button>\n                            </TooltipTrigger>\n                            <TooltipContent>\n                              <p>Add new palette</p>\n                            </TooltipContent>\n                          </Tooltip>\n                        </TooltipProvider>\n                        <TooltipProvider>\n                          <Tooltip>\n                            <TooltipTrigger asChild>\n                              <Button\n                                size=\"sm\"\n                                variant=\"outline\"\n                                className=\"h-6 w-6 p-0\"\n                                onClick={() => setIsManagePalettesOpen(true)}\n                              >\n                                <Settings className=\"h-3 w-3\" />\n                              </Button>\n                            </TooltipTrigger>\n                            <TooltipContent>\n                              <p>Manage palettes</p>\n                            </TooltipContent>\n                          </Tooltip>\n                        </TooltipProvider>\n                      </div>\n                    )}\n                  </div>\n                  \n                  <Select \n                    value={backgroundColorPaletteId || ''} \n                    onValueChange={handlePaletteChange}\n                    disabled={!enableBackgroundColorMapping}\n                  >\n                    <SelectTrigger className=\"text-xs h-8\">\n                      <SelectValue placeholder=\"Select palette...\" />\n                    </SelectTrigger>\n                    <SelectContent>\n                      {/* Custom Palettes */}\n                      {customPalettes.length > 0 && (\n                        <div>\n                          <div className=\"px-2 py-1.5 text-xs font-medium text-muted-foreground border-b border-border/30\">\n                            Custom\n                          </div>\n                          {customPalettes.map((palette: any) => (\n                            <SelectItem key={palette.id} value={palette.id} className=\"text-xs\">\n                              <div className=\"flex items-center gap-2 min-w-0\">\n                                <span className=\"truncate flex-1\">{palette.name}</span>\n                                <span className=\"text-muted-foreground flex-shrink-0\">({palette.colors.length} colors)</span>\n                              </div>\n                            </SelectItem>\n                          ))}\n                        </div>\n                      )}\n                          \n                      {/* Preset Palettes */}\n                      {palettes.length > 0 && (\n                        <div>\n                          <SelectSeparator />\n                          <div className=\"px-2 py-1.5 text-xs font-medium text-muted-foreground border-b border-border/30\">\n                            Presets\n                          </div>\n                          {palettes.map((palette: any) => (\n                            <SelectItem key={palette.id} value={palette.id} className=\"text-xs\">\n                              <div className=\"flex items-center gap-2 min-w-0\">\n                                <span className=\"truncate flex-1\">{palette.name}</span>\n                                <span className=\"text-muted-foreground flex-shrink-0\">({palette.colors.length} colors)</span>\n                              </div>\n                            </SelectItem>\n                          ))}\n                        </div>\n                      )}\n                    </SelectContent>\n                  </Select>\n                </div>\n\n                {/* Color Palette Editor */}\n                {selectedPalette && enableBackgroundColorMapping && (\n                  <div className=\"space-y-2\">\n                    <div className=\"flex items-center justify-between\">\n                      <Label className=\"text-xs font-medium\">Colors</Label>\n                      <div className=\"flex gap-0.5\">\n                        <TooltipProvider>\n                          <Tooltip>\n                            <TooltipTrigger asChild>\n                              <Button\n                                size=\"sm\"\n                                variant=\"outline\"\n                                className=\"h-6 w-6 p-0\"\n                                onClick={() => setIsImportDialogOpen(true)}\n                              >\n                                <Upload className=\"h-3 w-3\" />\n                              </Button>\n                            </TooltipTrigger>\n                            <TooltipContent>\n                              <p>Import palette</p>\n                            </TooltipContent>\n                          </Tooltip>\n                        </TooltipProvider>\n\n                        <TooltipProvider>\n                          <Tooltip>\n                            <TooltipTrigger asChild>\n                              <Button\n                                size=\"sm\"\n                                variant=\"outline\"\n                                className=\"h-6 w-6 p-0\"\n                                onClick={() => setIsExportDialogOpen(true)}\n                              >\n                                <Download className=\"h-3 w-3\" />\n                              </Button>\n                            </TooltipTrigger>\n                            <TooltipContent>\n                              <p>Export palette</p>\n                            </TooltipContent>\n                          </Tooltip>\n                        </TooltipProvider>\n                      </div>\n                    </div>\n                    \n                    {/* Color swatches grid */}\n                    <Card className=\"bg-card/50 border-border/50\">\n                      <CardContent className=\"p-2\">\n                        <div className=\"grid grid-cols-8 gap-0.5 mb-2\" onDragLeave={handleDragLeave}>\n                          {selectedPalette.colors.map((color, index) => (\n                            <div key={color.id} className=\"relative flex items-center justify-center\">\n                              {/* Drop indicator line */}\n                              {dropIndicatorIndex === index && (\n                                <div className=\"absolute -left-0.5 top-0 bottom-0 w-0.5 bg-primary z-10 rounded-full\"></div>\n                              )}\n                              \n                              <div\n                                className={`w-6 h-6 rounded border-2 transition-all hover:scale-105 cursor-pointer ${\n                                  draggedColorId === color.id ? 'opacity-50 scale-95' : ''\n                                } ${\n                                  selectedColorId === color.id\n                                    ? 'border-primary ring-2 ring-primary/20 shadow-lg'\n                                    : 'border-border hover:border-border/80'\n                                } cursor-move`}\n                                style={{ backgroundColor: color.value }}\n                                draggable={!selectedPalette.isPreset}\n                                onClick={() => setSelectedColor(color.id)}\n                                onDoubleClick={() => handleColorDoubleClick(color.value)}\n                                onDragStart={(e) => handleDragStart(e, color.id)}\n                                onDragOver={(e) => handleDragOver(e, color.id)}\n                                onDrop={(e) => handleDrop(e, color.id)}\n                                title={\n                                  selectedPalette.isPreset \n                                    ? `${color.name || 'Unnamed'}: ${color.value} (double-click to edit)` \n                                    : `${color.name || 'Unnamed'}: ${color.value} (drag to reorder, double-click to edit)`\n                                }\n                              />\n                              \n                              {/* Drop indicator line after last item */}\n                              {dropIndicatorIndex === index + 1 && (\n                                <div className=\"absolute -right-0.5 top-0 bottom-0 w-0.5 bg-primary z-10 rounded-full\"></div>\n                              )}\n                            </div>\n                          ))}\n                        </div>\n                        \n                        {/* Palette controls */}\n                        <div className=\"flex items-center justify-between\">\n                          {/* Editing controls */}\n                          <div className=\"flex gap-0.5\">\n                            <TooltipProvider>\n                              <Tooltip>\n                                <TooltipTrigger asChild>\n                                  <Button\n                                    size=\"sm\"\n                                    variant=\"outline\"\n                                    className=\"h-6 w-6 p-0\"\n                                    onClick={() => selectedColorId && handleMoveColorLeft(selectedColorId)}\n                                    disabled={!selectedColorId}\n                                  >\n                                    <ChevronLeft className=\"h-3 w-3\" />\n                                  </Button>\n                                </TooltipTrigger>\n                                <TooltipContent>\n                                  <p>Move color left</p>\n                                </TooltipContent>\n                              </Tooltip>\n                            </TooltipProvider>\n\n                            <TooltipProvider>\n                              <Tooltip>\n                                <TooltipTrigger asChild>\n                                  <Button\n                                    size=\"sm\"\n                                    variant=\"outline\"\n                                    className=\"h-6 w-6 p-0\"\n                                    onClick={() => selectedColorId && handleMoveColorRight(selectedColorId)}\n                                    disabled={!selectedColorId}\n                                  >\n                                    <ChevronRight className=\"h-3 w-3\" />\n                                  </Button>\n                                </TooltipTrigger>\n                                <TooltipContent>\n                                  <p>Move color right</p>\n                                </TooltipContent>\n                              </Tooltip>\n                            </TooltipProvider>\n\n                            <TooltipProvider>\n                              <Tooltip>\n                                <TooltipTrigger asChild>\n                                  <Button\n                                    size=\"sm\"\n                                    variant=\"outline\"\n                                    className=\"h-6 w-6 p-0\"\n                                    onClick={handleAddColor}\n                                  >\n                                    <Plus className=\"h-3 w-3\" />\n                                  </Button>\n                                </TooltipTrigger>\n                                <TooltipContent>\n                                  <p>Add color</p>\n                                </TooltipContent>\n                              </Tooltip>\n                            </TooltipProvider>\n\n                            <TooltipProvider>\n                              <Tooltip>\n                                <TooltipTrigger asChild>\n                                  <Button\n                                    size=\"sm\"\n                                    variant=\"outline\"\n                                    className=\"h-6 w-6 p-0\"\n                                    onClick={handleEditColor}\n                                    disabled={!selectedColorId}\n                                  >\n                                    <Edit className=\"h-3 w-3\" />\n                                  </Button>\n                                </TooltipTrigger>\n                                <TooltipContent>\n                                  <p>Edit color</p>\n                                </TooltipContent>\n                              </Tooltip>\n                            </TooltipProvider>\n\n                            <TooltipProvider>\n                              <Tooltip>\n                                <TooltipTrigger asChild>\n                                  <Button\n                                    size=\"sm\"\n                                    variant=\"outline\"\n                                    className=\"h-6 w-6 p-0\"\n                                    onClick={() => selectedColorId && handleRemoveColor(selectedColorId)}\n                                    disabled={!selectedColorId || selectedPalette.colors.length <= 1}\n                                  >\n                                    <Trash2 className=\"h-3 w-3\" />\n                                  </Button>\n                                </TooltipTrigger>\n                                <TooltipContent>\n                                  <p>Remove color</p>\n                                </TooltipContent>\n                              </Tooltip>\n                            </TooltipProvider>\n\n                          </div>\n                          \n                          {/* Reverse button (right-aligned) */}\n                          <div>\n                            <TooltipProvider>\n                              <Tooltip>\n                                <TooltipTrigger asChild>\n                                  <Button\n                                    size=\"sm\"\n                                    variant=\"outline\"\n                                    className=\"h-6 w-6 p-0\"\n                                    onClick={handleReversePalette}\n                                  >\n                                    <ArrowUpDown className=\"h-3 w-3\" />\n                                  </Button>\n                                </TooltipTrigger>\n                                <TooltipContent>\n                                  <p>Reverse palette order</p>\n                                </TooltipContent>\n                              </Tooltip>\n                            </TooltipProvider>\n                          </div>\n                        </div>\n                      </CardContent>\n                    </Card>\n                  </div>\n                )}\n\n                {/* Mapping Mode */}\n                <div className=\"space-y-2\">\n                  <Label className=\"text-xs font-medium\">Mapping Mode</Label>\n                  <Select \n                    value={backgroundColorMappingMode}\n                    onValueChange={handleMappingModeChange}\n                    disabled={!enableBackgroundColorMapping}\n                  >\n                    <SelectTrigger className=\"text-xs h-8\">\n                      <SelectValue />\n                    </SelectTrigger>\n                    <SelectContent>\n                      <SelectItem value=\"closest\" className=\"text-xs\">\n                        Closest Match\n                      </SelectItem>\n                      <SelectItem value=\"dithering\" className=\"text-xs\">\n                        Dithering\n                      </SelectItem>\n                      <SelectItem value=\"by-index\" className=\"text-xs\">\n                        By Index\n                      </SelectItem>\n                    </SelectContent>\n                  </Select>\n                </div>\n\n                </CardContent>\n              </Card>\n            )}\n          </div>\n        </CollapsibleContent>\n      </Collapsible>\n\n      {/* Color Picker Overlay */}\n      <ColorPickerOverlay\n        isOpen={isColorPickerOpen}\n        onOpenChange={setIsColorPickerOpen}\n        initialColor={colorPickerInitialColor}\n        onColorSelect={handleColorPickerSelect}\n        title=\"Edit Color\"\n        anchorPosition=\"import-media-panel\"\n      />\n\n      {/* Palette Management Dialog */}\n      <ManagePalettesDialog\n        isOpen={isManagePalettesOpen}\n        onOpenChange={setIsManagePalettesOpen}\n      />\n\n      {/* Import/Export Dialogs */}\n      <ImportPaletteDialog\n        isOpen={isImportDialogOpen}\n        onOpenChange={setIsImportDialogOpen}\n      />\n\n      <ExportPaletteDialog\n        isOpen={isExportDialogOpen}\n        onOpenChange={setIsExportDialogOpen}\n      />\n    </>\n  );\n}","usedDeprecatedRules":[]},{"filePath":"/Users/cameronfoxly/GitHubRepos/Ascii-Motion/src/components/features/BrushControls.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/cameronfoxly/GitHubRepos/Ascii-Motion/src/components/features/BrushPreview.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/cameronfoxly/GitHubRepos/Ascii-Motion/src/components/features/CanvasActionButtons.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/cameronfoxly/GitHubRepos/Ascii-Motion/src/components/features/CanvasGrid.tsx","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":34,"column":77,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":34,"endColumn":80,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1705,1708],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1705,1708],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useEffect has missing dependencies: 'setAltKeyDown' and 'setShiftKeyDown'. Either include them or remove the dependency array.","line":330,"column":6,"nodeType":"ArrayExpression","endLine":344,"endColumn":4,"suggestions":[{"desc":"Update the dependencies array to be: [moveState, activeTool, commitMove, cancelMove, selection.active, lassoSelection.active, magicWandSelection.active, handleArrowKeyMovement, clearSelection, clearLassoSelection, clearMagicWandSelection, textToolState.isTyping, shouldAllowEyedropperOverride, setShiftKeyDown, setAltKeyDown]","fix":{"range":[12121,12438],"text":"[moveState, activeTool, commitMove, cancelMove, selection.active, lassoSelection.active, magicWandSelection.active, handleArrowKeyMovement, clearSelection, clearLassoSelection, clearMagicWandSelection, textToolState.isTyping, shouldAllowEyedropperOverride, setShiftKeyDown, setAltKeyDown]"}}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useEffect, useRef } from 'react';\nimport { useToolStore } from '../../stores/toolStore';\nimport { useCanvasStore } from '../../stores/canvasStore';\nimport { useAnimationStore } from '../../stores/animationStore';\nimport { useCanvasContext } from '../../contexts/CanvasContext';\nimport { useCanvasState } from '../../hooks/useCanvasState';\nimport { useCanvasMouseHandlers } from '../../hooks/useCanvasMouseHandlers';\nimport { useCanvasRenderer } from '../../hooks/useCanvasRenderer';\nimport { useToolBehavior } from '../../hooks/useToolBehavior';\nimport { useHoverPreview } from '../../hooks/useHoverPreview';\nimport { ToolManager } from './ToolManager';\nimport { ToolStatusManager } from './ToolStatusManager';\nimport { CanvasActionButtons } from './CanvasActionButtons';\nimport { CanvasOverlay } from './CanvasOverlay';\n\ninterface CanvasGridProps {\n  className?: string;\n}\n\nexport const CanvasGrid: React.FC<CanvasGridProps> = ({ className = '' }) => {\n  // Use our new context and state management\n  const { canvasRef, setMouseButtonDown, setShiftKeyDown, setAltKeyDown, altKeyDown } = useCanvasContext();\n  \n  // Get active tool and tool behavior\n  const { activeTool, textToolState, isPlaybackMode } = useToolStore();\n  const { isPlaying } = useAnimationStore();\n  const { getToolCursor } = useToolBehavior();\n  \n  // Track previous tool for cleanup on tool changes\n  const prevToolRef = useRef(activeTool);\n  \n  // Calculate effective tool (Alt key overrides with eyedropper for drawing tools, except gradientfill)\n  const drawingTools = ['pencil', 'eraser', 'paintbucket', 'rectangle', 'ellipse'] as const;\n  const shouldAllowEyedropperOverride = drawingTools.includes(activeTool as any);\n  \n  const effectiveTool = (altKeyDown && shouldAllowEyedropperOverride) ? 'eyedropper' : activeTool;\n  \n  // Canvas dimensions hooks already provide computed values\n  const {\n    moveState,\n    commitMove,\n    cancelMove,\n    setSelectionMode,\n    setMoveState,\n    setPendingSelectionStart,\n    setJustCommittedMove,\n  } = useCanvasState();\n\n  // Use our new mouse handlers\n  const {\n    handleMouseDown,\n    handleMouseMove, \n    handleMouseUp,\n    handleMouseLeave,\n    handleContextMenu\n  } = useCanvasMouseHandlers();\n\n  // Use the new renderer hook that handles both grid and overlay rendering\n  useCanvasRenderer();\n  \n  // Enable hover preview for tools (brush outline, etc.)\n  useHoverPreview();\n\n  const { \n    selection, \n    lassoSelection, \n    magicWandSelection, \n    clearSelection, \n    clearLassoSelection, \n    clearMagicWandSelection \n  } = useToolStore();\n\n  // Handle arrow key movement for selections\n  const handleArrowKeyMovement = (arrowOffset: { x: number; y: number }) => {\n    // Determine which selection is active and handle accordingly\n    if (activeTool === 'select' && selection.active) {\n      handleRectangularSelectionArrowMovement(arrowOffset);\n    } else if (activeTool === 'lasso' && lassoSelection.active) {\n      handleLassoSelectionArrowMovement(arrowOffset);\n    } else if (activeTool === 'magicwand' && magicWandSelection.active) {\n      handleMagicWandSelectionArrowMovement(arrowOffset);\n    }\n  };\n\n  // Handle arrow movement for rectangular selection\n  const handleRectangularSelectionArrowMovement = (arrowOffset: { x: number; y: number }) => {\n    if (!selection.active) return;\n\n    // Ensure we're not blocked by justCommittedMove state\n    setJustCommittedMove(false);\n\n    if (moveState) {\n      // Already in move mode - update the current offset\n      setMoveState({\n        ...moveState,\n        currentOffset: {\n          x: moveState.currentOffset.x + arrowOffset.x,\n          y: moveState.currentOffset.y + arrowOffset.y\n        }\n      });\n    } else {\n      // Enter move mode for the first time\n      const { getCell } = useCanvasStore.getState();\n  const startX = Math.min(selection.start.x, selection.end.x);\n  const startY = Math.min(selection.start.y, selection.end.y);\n\n      const originalData = new Map();\n      const originalPositions = new Set<string>();\n\n      selection.selectedCells.forEach((cellKey) => {\n        originalPositions.add(cellKey);\n        const [cx, cy] = cellKey.split(',').map(Number);\n        const cell = getCell(cx, cy);\n        // Only store non-empty cells (not spaces or empty cells)\n        if (cell && cell.char !== ' ') {\n          originalData.set(cellKey, cell);\n        }\n      });\n      \n      setMoveState({\n        originalData,\n        originalPositions,\n        startPos: { x: startX, y: startY }, // Use selection start as reference point\n        baseOffset: { x: 0, y: 0 },\n        currentOffset: arrowOffset // Start with the arrow offset\n      });\n      setSelectionMode('moving');\n    }\n  };\n\n  // Handle arrow movement for lasso selection\n  const handleLassoSelectionArrowMovement = (arrowOffset: { x: number; y: number }) => {\n    if (!lassoSelection.active) return;\n\n    // Ensure we're not blocked by justCommittedMove state\n    setJustCommittedMove(false);\n\n    if (moveState) {\n      // Already in move mode - update the current offset\n      setMoveState({\n        ...moveState,\n        currentOffset: {\n          x: moveState.currentOffset.x + arrowOffset.x,\n          y: moveState.currentOffset.y + arrowOffset.y\n        }\n      });\n    } else {\n      // Enter move mode for the first time\n      const { getCell } = useCanvasStore.getState();\n      \n      // Store only the non-empty cells from the lasso selection\n      const originalData = new Map();\n      lassoSelection.selectedCells.forEach((cellKey) => {\n        const [cx, cy] = cellKey.split(',').map(Number);\n        const cell = getCell(cx, cy);\n        // Only store non-empty cells (not spaces or empty cells)\n        if (cell && cell.char !== ' ') {\n          originalData.set(cellKey, cell);\n        }\n      });\n      \n      // Use center of selection as reference point\n      const cellCoords = Array.from(lassoSelection.selectedCells).map(key => {\n        const [x, y] = key.split(',').map(Number);\n        return { x, y };\n      });\n      const centerX = Math.floor(cellCoords.reduce((sum, c) => sum + c.x, 0) / cellCoords.length);\n      const centerY = Math.floor(cellCoords.reduce((sum, c) => sum + c.y, 0) / cellCoords.length);\n      \n      setMoveState({\n        originalData,\n        originalPositions: new Set(originalData.keys()),\n        startPos: { x: centerX, y: centerY }, // Use selection center as reference point\n        baseOffset: { x: 0, y: 0 },\n        currentOffset: arrowOffset // Start with the arrow offset\n      });\n      setSelectionMode('moving');\n    }\n  };\n\n  // Handle arrow movement for magic wand selection\n  const handleMagicWandSelectionArrowMovement = (arrowOffset: { x: number; y: number }) => {\n    if (!magicWandSelection.active) return;\n\n    // Ensure we're not blocked by justCommittedMove state\n    setJustCommittedMove(false);\n\n    if (moveState) {\n      // Already in move mode - update the current offset\n      setMoveState({\n        ...moveState,\n        currentOffset: {\n          x: moveState.currentOffset.x + arrowOffset.x,\n          y: moveState.currentOffset.y + arrowOffset.y\n        }\n      });\n    } else {\n      // Enter move mode for the first time\n      const { getCell } = useCanvasStore.getState();\n      \n      // Store only the non-empty cells from the magic wand selection\n      const originalData = new Map();\n      magicWandSelection.selectedCells.forEach((cellKey) => {\n        const [cx, cy] = cellKey.split(',').map(Number);\n        const cell = getCell(cx, cy);\n        // Only store non-empty cells (not spaces or empty cells)\n        if (cell && cell.char !== ' ') {\n          originalData.set(cellKey, cell);\n        }\n      });\n      \n      // Use center of selection as reference point\n      const cellCoords = Array.from(magicWandSelection.selectedCells).map(key => {\n        const [x, y] = key.split(',').map(Number);\n        return { x, y };\n      });\n      const centerX = Math.floor(cellCoords.reduce((sum, c) => sum + c.x, 0) / cellCoords.length);\n      const centerY = Math.floor(cellCoords.reduce((sum, c) => sum + c.y, 0) / cellCoords.length);\n      \n      setMoveState({\n        originalData,\n        originalPositions: new Set(originalData.keys()),\n        startPos: { x: centerX, y: centerY }, // Use selection center as reference point\n        baseOffset: { x: 0, y: 0 },\n        currentOffset: arrowOffset // Start with the arrow offset\n      });\n      setSelectionMode('moving');\n    }\n  };\n\n  // Handle keyboard events for Escape and Shift keys\n  useEffect(() => {\n    const handleKeyDown = (event: KeyboardEvent) => {\n      // Handle Shift key for aspect ratio locking\n      if (event.key === 'Shift') {\n        setShiftKeyDown(true);\n      }\n      \n      // Handle Alt key for temporary eyedropper tool (only for drawing tools)\n      // Don't override Alt key if text tool is actively typing\n      if (event.key === 'Alt' && shouldAllowEyedropperOverride) {\n        event.preventDefault(); // Prevent browser menu activation\n        setAltKeyDown(true);\n      }\n      \n      // Handle Escape key for canceling moves and clearing selections\n      if (event.key === 'Escape') {\n        if ((selection.active && activeTool === 'select') || \n            (lassoSelection.active && activeTool === 'lasso') ||\n            (magicWandSelection.active && activeTool === 'magicwand')) {\n          event.preventDefault();\n          event.stopPropagation();\n          \n          if (moveState) {\n            // Cancel move without committing changes\n            cancelMove();\n          }\n          \n          // Clear the appropriate selection\n          if (selection.active) {\n            clearSelection();\n          }\n          if (lassoSelection.active) {\n            clearLassoSelection();\n          }\n          if (magicWandSelection.active) {\n            clearMagicWandSelection();\n          }\n        }\n      }\n      \n      // Handle Enter key for committing moves\n      if (event.key === 'Enter' && moveState && (activeTool === 'select' || activeTool === 'lasso' || activeTool === 'magicwand')) {\n        event.preventDefault();\n        event.stopPropagation();\n        commitMove();\n        \n        // Clear the appropriate selection based on active tool\n        if (activeTool === 'select') {\n          clearSelection();\n        } else if (activeTool === 'lasso') {\n          clearLassoSelection();\n        } else if (activeTool === 'magicwand') {\n          clearMagicWandSelection();\n        }\n      }\n      \n      // Handle arrow keys for selection movement\n      if ((event.key === 'ArrowUp' || event.key === 'ArrowDown' || event.key === 'ArrowLeft' || event.key === 'ArrowRight')) {\n        // Only handle arrow keys when a selection tool is active and has an active selection\n        if ((activeTool === 'select' && selection.active) || \n            (activeTool === 'lasso' && lassoSelection.active) ||\n            (activeTool === 'magicwand' && magicWandSelection.active)) {\n          event.preventDefault();\n          event.stopPropagation();\n          \n          // Calculate arrow direction offset\n          const arrowOffset = {\n            x: event.key === 'ArrowLeft' ? -1 : event.key === 'ArrowRight' ? 1 : 0,\n            y: event.key === 'ArrowUp' ? -1 : event.key === 'ArrowDown' ? 1 : 0\n          };\n          \n          // Call the new arrow movement handler\n          handleArrowKeyMovement(arrowOffset);\n        }\n      }\n    };\n\n    const handleKeyUp = (event: KeyboardEvent) => {\n      // Handle Shift key release\n      if (event.key === 'Shift') {\n        setShiftKeyDown(false);\n        // Clear line preview when shift is released\n        const { clearLinePreview } = useToolStore.getState();\n        clearLinePreview();\n      }\n      \n      // Handle Alt key release\n      if (event.key === 'Alt') {\n        setAltKeyDown(false);\n      }\n    };\n\n    document.addEventListener('keydown', handleKeyDown);\n    document.addEventListener('keyup', handleKeyUp);\n    return () => {\n      document.removeEventListener('keydown', handleKeyDown);\n      document.removeEventListener('keyup', handleKeyUp);\n    };\n  }, [\n    moveState, \n    activeTool, \n    commitMove, \n    cancelMove, \n    selection.active,\n    lassoSelection.active, \n    magicWandSelection.active,\n    handleArrowKeyMovement,\n    clearSelection,\n    clearLassoSelection,\n    clearMagicWandSelection,\n    textToolState.isTyping,\n    shouldAllowEyedropperOverride\n  ]);\n\n  // Reset selection mode when tool changes\n  useEffect(() => {\n    const prevTool = prevToolRef.current;\n    \n    // If tool actually changed, handle cleanup\n    if (prevTool !== activeTool) {\n      // Always commit any pending move when switching tools\n      if (moveState) {\n        commitMove();\n      }\n      \n      // Clear selection-related state when switching away from selection tools\n      if (activeTool !== 'select' && activeTool !== 'lasso') {\n        setSelectionMode('none');\n        setMouseButtonDown(false);\n        setPendingSelectionStart(null);\n        setMoveState(null);\n      }\n      \n      // Update the ref for next time\n      prevToolRef.current = activeTool;\n    }\n  }, [activeTool, moveState, commitMove, setSelectionMode, setMouseButtonDown, setPendingSelectionStart, setMoveState]);\n\n  return (\n    <div className={`canvas-grid-container ${className} h-full flex flex-col relative`}>\n      {/* Tool Manager - handles tool-specific behavior */}\n      <ToolManager />\n      \n      <div className={`canvas-wrapper border rounded-lg overflow-auto flex-1 relative ${\n        isPlaying \n          ? 'border-white border-2' \n          : isPlaybackMode \n            ? 'border-orange-500 border-2'\n            : 'border-border border'\n      }`}>\n        <canvas\n          ref={canvasRef}\n          className={`canvas-grid border border-border ${getToolCursor(effectiveTool)}`}\n          onMouseDown={handleMouseDown}\n          onMouseMove={handleMouseMove}\n          onMouseUp={handleMouseUp}\n          onMouseLeave={handleMouseLeave}\n          onContextMenu={handleContextMenu}\n          style={{\n            display: 'block'\n            // Width and height are set by canvas resize logic in useCanvasRenderer\n          }}\n        />\n        <CanvasOverlay />\n      </div>\n      \n      {/* Action buttons and status info positioned outside canvas */}\n      <div className=\"my-2 flex justify-between items-center\">\n        <CanvasActionButtons />\n        <ToolStatusManager />\n      </div>\n    </div>\n  );\n};\n","usedDeprecatedRules":[]},{"filePath":"/Users/cameronfoxly/GitHubRepos/Ascii-Motion/src/components/features/CanvasOverlay.tsx","messages":[{"ruleId":"prefer-const","severity":2,"message":"'cellX' is never reassigned. Use 'const' instead.","line":72,"column":13,"nodeType":"Identifier","messageId":"useConst","endLine":72,"endColumn":18,"fix":{"range":[2947,2980],"text":"const cellX = rawX + totalOffset.x;"}},{"ruleId":"prefer-const","severity":2,"message":"'cellY' is never reassigned. Use 'const' instead.","line":73,"column":13,"nodeType":"Identifier","messageId":"useConst","endLine":73,"endColumn":18,"fix":{"range":[2989,3022],"text":"const cellY = rawY + totalOffset.y;"}},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":514,"column":99,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":514,"endColumn":102,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[17884,17887],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[17884,17887],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":516,"column":47,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":516,"endColumn":50,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[17971,17974],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[17971,17974],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useCallback has missing dependencies: 'canvasBackgroundColor', 'fontMetrics.fontFamily', 'fontMetrics.fontSize', 'height', 'magicWandSelection.active', 'magicWandSelection.selectedCells', 'selectionPreview.active', 'selectionPreview.baseCells', 'selectionPreview.gestureCells', 'selectionPreview.modifier', 'selectionPreview.tool', 'theme', 'width', and 'zoom'. Either include them or remove the dependency array.","line":684,"column":6,"nodeType":"ArrayExpression","endLine":684,"endColumn":256,"suggestions":[{"desc":"Update the dependencies array to be: [canvasRef, moveState, getTotalOffset, selectionPreview.active, selectionPreview.tool, selectionPreview.modifier, selectionPreview.baseCells, selectionPreview.gestureCells, selection.active, selection.selectedCells, lassoSelection.active, lassoSelection.selectedCells, magicWandSelection.active, magicWandSelection.selectedCells, linePreview.active, linePreview.points, pasteMode.isActive, pasteMode.preview, activeTool, gradientApplying, hoverPreview.active, hoverPreview.cells, hoverPreview.mode, width, height, effectiveCellWidth, panOffset.x, panOffset.y, effectiveCellHeight, gradientStart, gradientEnd, gradientPreview, gradientDefinition, canvasBackgroundColor, theme, fontMetrics.fontSize, fontMetrics.fontFamily, zoom]","fix":{"range":[24501,24751],"text":"[canvasRef, moveState, getTotalOffset, selectionPreview.active, selectionPreview.tool, selectionPreview.modifier, selectionPreview.baseCells, selectionPreview.gestureCells, selection.active, selection.selectedCells, lassoSelection.active, lassoSelection.selectedCells, magicWandSelection.active, magicWandSelection.selectedCells, linePreview.active, linePreview.points, pasteMode.isActive, pasteMode.preview, activeTool, gradientApplying, hoverPreview.active, hoverPreview.cells, hoverPreview.mode, width, height, effectiveCellWidth, panOffset.x, panOffset.y, effectiveCellHeight, gradientStart, gradientEnd, gradientPreview, gradientDefinition, canvasBackgroundColor, theme, fontMetrics.fontSize, fontMetrics.fontFamily, zoom]"}}]}],"suppressedMessages":[],"errorCount":4,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":2,"fixableWarningCount":0,"source":"import React, { useCallback, useEffect, useRef } from 'react';\nimport { useToolStore } from '../../stores/toolStore';\nimport { useGradientStore } from '../../stores/gradientStore';\nimport { useCanvasContext } from '../../contexts/CanvasContext';\nimport { useCanvasStore } from '../../stores/canvasStore';\nimport { useTheme } from '../../contexts/ThemeContext';\nimport { useCanvasState } from '../../hooks/useCanvasState';\nimport { InteractiveGradientOverlay } from './InteractiveGradientOverlay';\n\nexport const CanvasOverlay: React.FC = () => {\n  // Create a separate canvas ref for overlay\n  const overlayCanvasRef = useRef<HTMLCanvasElement>(null);\n  \n  // Canvas context and state  \n  const { canvasRef, pasteMode, cellWidth, cellHeight, zoom, panOffset, fontMetrics, hoverPreview, selectionPreview } = useCanvasContext();\n  const {\n    moveState,\n    getTotalOffset,\n  } = useCanvasState();\n\n  const { selection, lassoSelection, magicWandSelection, linePreview, activeTool } = useToolStore();\n  const { \n    isApplying: gradientApplying, \n    startPoint: gradientStart, \n    endPoint: gradientEnd,\n    definition: gradientDefinition,\n    previewData: gradientPreview\n  } = useGradientStore();\n  const { canvasBackgroundColor, width, height } = useCanvasStore();\n  const { theme } = useTheme();\n\n  // Calculate effective dimensions with zoom and aspect ratio\n  const effectiveCellWidth = cellWidth * zoom;\n  const effectiveCellHeight = cellHeight * zoom;\n\n  // Render selection overlay\n  const renderOverlay = useCallback(() => {\n    const overlayCanvas = overlayCanvasRef.current;\n    const mainCanvas = canvasRef.current;\n    if (!overlayCanvas || !mainCanvas) return;\n\n    const ctx = overlayCanvas.getContext('2d');\n    if (!ctx) return;\n\n    // Match the overlay canvas size to the main canvas\n    if (overlayCanvas.width !== mainCanvas.width || overlayCanvas.height !== mainCanvas.height) {\n      overlayCanvas.width = mainCanvas.width;\n      overlayCanvas.height = mainCanvas.height;\n      overlayCanvas.style.width = mainCanvas.style.width;\n      overlayCanvas.style.height = mainCanvas.style.height;\n      \n      // Apply the same high-DPI scaling as the main canvas\n      const devicePixelRatio = window.devicePixelRatio || 1;\n      ctx.scale(devicePixelRatio, devicePixelRatio);\n    }\n\n    // Clear previous overlay\n    ctx.clearRect(0, 0, overlayCanvas.width / (window.devicePixelRatio || 1), overlayCanvas.height / (window.devicePixelRatio || 1));\n\n    const totalOffset = moveState ? getTotalOffset(moveState) : { x: 0, y: 0 };\n\n    const drawCells = (cells: Set<string>, options: { fillStyle?: string; strokeStyle?: string; lineDash?: number[] }) => {\n      if (!cells || cells.size === 0) return;\n\n      const { fillStyle, strokeStyle, lineDash } = options;\n      if (lineDash) {\n        ctx.setLineDash(lineDash);\n      }\n\n      cells.forEach((cellKey) => {\n        const [rawX, rawY] = cellKey.split(',').map(Number);\n        let cellX = rawX + totalOffset.x;\n        let cellY = rawY + totalOffset.y;\n\n        if (cellX < 0 || cellY < 0 || cellX >= width || cellY >= height) {\n          return;\n        }\n\n        const pixelX = cellX * effectiveCellWidth + panOffset.x;\n        const pixelY = cellY * effectiveCellHeight + panOffset.y;\n\n        if (fillStyle) {\n          ctx.fillStyle = fillStyle;\n          ctx.fillRect(pixelX, pixelY, effectiveCellWidth, effectiveCellHeight);\n        }\n\n        if (strokeStyle) {\n          ctx.strokeStyle = strokeStyle;\n          ctx.lineWidth = 2;\n          ctx.strokeRect(pixelX, pixelY, effectiveCellWidth, effectiveCellHeight);\n        }\n      });\n\n      if (lineDash) {\n        ctx.setLineDash([]);\n      }\n    };\n\n    const selectionFillColor = 'rgba(192, 132, 252, 0.18)';\n    const selectionOutlineColor = '#C084FC';\n    const selectionLineDash: [number, number] = [6, 4];\n\n    const adjustCellsForOffset = (cells: Set<string>): Set<string> => {\n      const adjusted = new Set<string>();\n      cells.forEach((cellKey) => {\n        const [rawX, rawY] = cellKey.split(',').map(Number);\n        const adjX = rawX + totalOffset.x;\n        const adjY = rawY + totalOffset.y;\n\n        if (adjX < 0 || adjY < 0 || adjX >= width || adjY >= height) {\n          return;\n        }\n\n        adjusted.add(`${adjX},${adjY}`);\n      });\n      return adjusted;\n    };\n\n    const buildIslands = (cells: Set<string>): Set<string>[] => {\n      const visited = new Set<string>();\n      const islands: Set<string>[] = [];\n      const neighborOffsets = [\n        [1, 0],\n        [-1, 0],\n        [0, 1],\n        [0, -1]\n      ];\n\n      cells.forEach((cellKey) => {\n        if (visited.has(cellKey)) {\n          return;\n        }\n\n        const island = new Set<string>();\n        const stack: string[] = [cellKey];\n        visited.add(cellKey);\n\n        while (stack.length > 0) {\n          const currentKey = stack.pop()!;\n          island.add(currentKey);\n          const [cx, cy] = currentKey.split(',').map(Number);\n\n          neighborOffsets.forEach(([dx, dy]) => {\n            const neighborKey = `${cx + dx},${cy + dy}`;\n            if (!visited.has(neighborKey) && cells.has(neighborKey)) {\n              visited.add(neighborKey);\n              stack.push(neighborKey);\n            }\n          });\n        }\n\n        islands.push(island);\n      });\n\n      return islands;\n    };\n\n    const buildOutlineLoops = (island: Set<string>): { x: number; y: number }[][] => {\n      const edgeMap = new Map<string, Map<string, { x: number; y: number }>>();\n      const edgeKeys = new Set<string>();\n\n      const pointKey = (point: { x: number; y: number }) => `${point.x},${point.y}`;\n\n      const addEdge = (from: { x: number; y: number }, to: { x: number; y: number }) => {\n        const fromKey = pointKey(from);\n        const toKey = pointKey(to);\n\n        if (!edgeMap.has(fromKey)) {\n          edgeMap.set(fromKey, new Map());\n        }\n\n        const fromEdges = edgeMap.get(fromKey)!;\n        if (!fromEdges.has(toKey)) {\n          fromEdges.set(toKey, to);\n          edgeKeys.add(`${fromKey}|${toKey}`);\n        }\n      };\n\n      island.forEach((cellKey) => {\n        const [x, y] = cellKey.split(',').map(Number);\n\n        const neighbors = [\n          { dx: 0, dy: -1, from: { x, y }, to: { x: x + 1, y } }, // top edge\n          { dx: 1, dy: 0, from: { x: x + 1, y }, to: { x: x + 1, y: y + 1 } }, // right edge\n          { dx: 0, dy: 1, from: { x: x + 1, y: y + 1 }, to: { x, y: y + 1 } }, // bottom edge\n          { dx: -1, dy: 0, from: { x, y: y + 1 }, to: { x, y } } // left edge\n        ];\n\n        neighbors.forEach(({ dx, dy, from, to }) => {\n          const neighborKey = `${x + dx},${y + dy}`;\n          if (!island.has(neighborKey)) {\n            addEdge(from, to);\n          }\n        });\n      });\n\n      const parsePoint = (key: string): { x: number; y: number } => {\n        const [px, py] = key.split(',').map(Number);\n        return { x: px, y: py };\n      };\n\n      const loops: { x: number; y: number }[][] = [];\n\n      while (edgeKeys.size > 0) {\n        const firstKey = edgeKeys.values().next().value as string;\n        const [startFromKey, startToKey] = firstKey.split('|');\n        const loop: { x: number; y: number }[] = [];\n\n        let currentFromKey = startFromKey;\n        let currentToKey = startToKey;\n        loop.push(parsePoint(currentFromKey));\n\n        while (true) {\n          const fromEdges = edgeMap.get(currentFromKey);\n          if (!fromEdges) {\n            break;\n          }\n\n          const nextPoint = fromEdges.get(currentToKey);\n          if (!nextPoint) {\n            break;\n          }\n\n          loop.push(nextPoint);\n\n          fromEdges.delete(currentToKey);\n          edgeKeys.delete(`${currentFromKey}|${currentToKey}`);\n          if (fromEdges.size === 0) {\n            edgeMap.delete(currentFromKey);\n          }\n\n          if (currentToKey === startFromKey) {\n            break;\n          }\n\n          const nextEdges = edgeMap.get(currentToKey);\n          if (!nextEdges || nextEdges.size === 0) {\n            break;\n          }\n\n          const nextToEntry = nextEdges.entries().next().value as [string, { x: number; y: number }];\n          currentFromKey = currentToKey;\n          currentToKey = nextToEntry[0];\n        }\n\n        loops.push(loop);\n      }\n\n      return loops;\n    };\n\n    const drawSelectionIslands = (cells: Set<string>) => {\n      if (!cells || cells.size === 0) {\n        return;\n      }\n\n      const adjustedCells = adjustCellsForOffset(cells);\n      if (adjustedCells.size === 0) {\n        return;\n      }\n\n      ctx.fillStyle = selectionFillColor;\n      adjustedCells.forEach((cellKey) => {\n        const [x, y] = cellKey.split(',').map(Number);\n        const pixelX = x * effectiveCellWidth + panOffset.x;\n        const pixelY = y * effectiveCellHeight + panOffset.y;\n        ctx.fillRect(pixelX, pixelY, effectiveCellWidth, effectiveCellHeight);\n      });\n\n      const islands = buildIslands(adjustedCells);\n\n      ctx.strokeStyle = selectionOutlineColor;\n      ctx.lineWidth = 2;\n      ctx.lineJoin = 'round';\n      ctx.lineCap = 'round';\n      ctx.setLineDash(selectionLineDash);\n\n      islands.forEach((island) => {\n        const loops = buildOutlineLoops(island);\n        loops.forEach((loop) => {\n          if (loop.length < 2) {\n            return;\n          }\n\n          ctx.beginPath();\n          loop.forEach((point, index) => {\n            const pixelX = point.x * effectiveCellWidth + panOffset.x;\n            const pixelY = point.y * effectiveCellHeight + panOffset.y;\n            if (index === 0) {\n              ctx.moveTo(pixelX, pixelY);\n            } else {\n              ctx.lineTo(pixelX, pixelY);\n            }\n          });\n          ctx.closePath();\n          ctx.stroke();\n        });\n      });\n\n      ctx.setLineDash([]);\n    };\n\n    const previewActive = selectionPreview.active && selectionPreview.tool !== null && selectionPreview.modifier !== 'replace';\n    if (previewActive) {\n      const baseCells = new Set(selectionPreview.baseCells);\n      const gestureCells = new Set(selectionPreview.gestureCells);\n      const modifier = selectionPreview.modifier;\n      const toolKey = selectionPreview.tool ?? 'select';\n\n      const previewStyleMap = {\n        select: {\n          baseFill: 'rgba(59, 130, 246, 0.2)',\n          addFill: 'rgba(34, 197, 94, 0.25)',\n          addStroke: undefined,\n          subtractFill: 'rgba(239, 68, 68, 0.22)',\n          subtractStroke: '#EF4444'\n        },\n        lasso: {\n          baseFill: 'rgba(168, 85, 247, 0.25)',\n          addFill: 'rgba(34, 197, 94, 0.25)',\n          addStroke: undefined,\n          subtractFill: 'rgba(239, 68, 68, 0.22)',\n          subtractStroke: '#EF4444'\n        },\n        magicwand: {\n          baseFill: 'rgba(255, 165, 0, 0.28)',\n          addFill: 'rgba(56, 189, 248, 0.25)',\n          addStroke: undefined,\n          subtractFill: 'rgba(239, 68, 68, 0.22)',\n          subtractStroke: undefined\n        }\n      } as const;\n\n      const styles = previewStyleMap[toolKey as keyof typeof previewStyleMap] ?? previewStyleMap.select;\n\n      if (modifier === 'add') {\n        drawCells(baseCells, { fillStyle: styles.baseFill });\n        drawCells(gestureCells, { fillStyle: styles.addFill, strokeStyle: styles.addStroke });\n      } else if (modifier === 'subtract') {\n        const remainingCells = new Set<string>();\n        baseCells.forEach((cell) => {\n          if (!gestureCells.has(cell)) {\n            remainingCells.add(cell);\n          }\n        });\n\n        drawCells(remainingCells, { fillStyle: styles.baseFill });\n        if (gestureCells.size > 0) {\n          drawCells(gestureCells, { fillStyle: styles.subtractFill, strokeStyle: styles.subtractStroke, lineDash: styles.subtractStroke ? [4, 3] : undefined });\n        }\n      }\n    }\n\n    // Draw selection overlay\n    if (selection.active && selection.selectedCells.size > 0) {\n      drawSelectionIslands(selection.selectedCells);\n    }\n\n    if (lassoSelection.active && lassoSelection.selectedCells.size > 0) {\n      drawSelectionIslands(lassoSelection.selectedCells);\n    }\n\n    if (magicWandSelection.active && magicWandSelection.selectedCells.size > 0) {\n      drawSelectionIslands(magicWandSelection.selectedCells);\n    }\n\n    // Draw shift+click line preview\n    if (linePreview.active && linePreview.points.length > 0) {\n      ctx.fillStyle = 'rgba(168, 85, 247, 0.1)'; // Same purple as lasso selection\n      \n      linePreview.points.forEach(({ x, y }) => {\n        ctx.fillRect(\n          x * effectiveCellWidth + panOffset.x,\n          y * effectiveCellHeight + panOffset.y,\n          effectiveCellWidth,\n          effectiveCellHeight\n        );\n      });\n    }\n\n    // Draw paste preview overlay\n    if (pasteMode.isActive && pasteMode.preview) {\n      const { position, data, bounds } = pasteMode.preview;\n      \n      // Calculate preview rectangle\n      const previewStartX = position.x + bounds.minX;\n      const previewStartY = position.y + bounds.minY;\n      const previewWidth = bounds.maxX - bounds.minX + 1;\n      const previewHeight = bounds.maxY - bounds.minY + 1;\n\n      // Draw paste preview marquee\n      ctx.strokeStyle = '#A855F7'; // Purple color\n      ctx.lineWidth = 2;\n      ctx.setLineDash([8, 4]);\n      ctx.strokeRect(\n        previewStartX * effectiveCellWidth + panOffset.x,\n        previewStartY * effectiveCellHeight + panOffset.y,\n        previewWidth * effectiveCellWidth,\n        previewHeight * effectiveCellHeight\n      );\n\n      // Add semi-transparent background\n      ctx.fillStyle = 'rgba(168, 85, 247, 0.1)';\n      ctx.fillRect(\n        previewStartX * effectiveCellWidth + panOffset.x,\n        previewStartY * effectiveCellHeight + panOffset.y,\n        previewWidth * effectiveCellWidth,\n        previewHeight * effectiveCellHeight\n      );\n\n      ctx.setLineDash([]);\n\n      // Draw paste content preview with transparency\n      ctx.globalAlpha = 0.7;\n      data.forEach((cell, key) => {\n        const [relX, relY] = key.split(',').map(Number);\n        const absoluteX = position.x + relX;\n        const absoluteY = position.y + relY;\n        \n        const pixelX = absoluteX * effectiveCellWidth + panOffset.x;\n        const pixelY = absoluteY * effectiveCellHeight + panOffset.y;\n\n        // Draw cell background\n        if (cell.backgroundColor && cell.backgroundColor !== 'transparent') {\n          ctx.fillStyle = cell.backgroundColor;\n          ctx.fillRect(pixelX, pixelY, effectiveCellWidth, effectiveCellHeight);\n        }\n\n        // Draw character\n        if (cell.character && cell.character !== ' ') {\n          ctx.fillStyle = cell.color || '#000000';\n          ctx.font = `${Math.floor(effectiveCellHeight - 2)}px 'Courier New', monospace`;\n          ctx.textAlign = 'center';\n          ctx.textBaseline = 'middle';\n          ctx.fillText(\n            cell.character, \n            pixelX + effectiveCellWidth / 2, \n            pixelY + effectiveCellHeight / 2\n          );\n        }\n      });\n      ctx.globalAlpha = 1.0;\n    }\n    \n    // Draw gradient fill overlay\n    if (activeTool === 'gradientfill' && gradientApplying) {\n      // Draw gradient start point\n      if (gradientStart) {\n        ctx.strokeStyle = '#22c55e'; // Green for start\n        ctx.fillStyle = '#22c55e';\n        ctx.lineWidth = 2;\n        ctx.setLineDash([]);\n        \n        const startPixelX = gradientStart.x * effectiveCellWidth + panOffset.x + effectiveCellWidth / 2;\n        const startPixelY = gradientStart.y * effectiveCellHeight + panOffset.y + effectiveCellHeight / 2;\n        \n        // Draw start point circle\n        ctx.beginPath();\n        ctx.arc(startPixelX, startPixelY, 6, 0, 2 * Math.PI);\n        ctx.fill();\n        ctx.strokeStyle = 'white';\n        ctx.lineWidth = 2;\n        ctx.stroke();\n        \n        // Draw \"START\" label\n        ctx.fillStyle = 'white';\n        ctx.font = '12px monospace';\n        ctx.textAlign = 'center';\n        ctx.textBaseline = 'middle';\n        ctx.fillText('START', startPixelX, startPixelY - 18);\n      }\n      \n      // Draw gradient end point and line\n      if (gradientStart && gradientEnd) {\n        const startPixelX = gradientStart.x * effectiveCellWidth + panOffset.x + effectiveCellWidth / 2;\n        const startPixelY = gradientStart.y * effectiveCellHeight + panOffset.y + effectiveCellHeight / 2;\n        const endPixelX = gradientEnd.x * effectiveCellWidth + panOffset.x + effectiveCellWidth / 2;\n        const endPixelY = gradientEnd.y * effectiveCellHeight + panOffset.y + effectiveCellHeight / 2;\n        \n        // Draw gradient line\n        ctx.strokeStyle = '#6b7280'; // Gray\n        ctx.lineWidth = 2;\n        ctx.setLineDash([5, 5]);\n        ctx.beginPath();\n        ctx.moveTo(startPixelX, startPixelY);\n        ctx.lineTo(endPixelX, endPixelY);\n        ctx.stroke();\n        ctx.setLineDash([]);\n        \n        // Draw end point circle\n        ctx.fillStyle = '#ef4444'; // Red for end\n        ctx.strokeStyle = 'white';\n        ctx.lineWidth = 2;\n        \n        ctx.beginPath();\n        ctx.arc(endPixelX, endPixelY, 6, 0, 2 * Math.PI);\n        ctx.fill();\n        ctx.stroke();\n        \n        // Draw \"END\" label\n        ctx.fillStyle = 'white';\n        ctx.font = '12px monospace';\n        ctx.textAlign = 'center';\n        ctx.textBaseline = 'middle';\n        ctx.fillText('END', endPixelX, endPixelY - 18);\n        \n        // Draw gradient stops along the line\n        const enabledProperties = [];\n        if (gradientDefinition.character.enabled) enabledProperties.push('character');\n        if (gradientDefinition.textColor.enabled) enabledProperties.push('textColor');\n        if (gradientDefinition.backgroundColor.enabled) enabledProperties.push('backgroundColor');\n        \n        enabledProperties.forEach((property, propIndex) => {\n          const gradientProp = gradientDefinition[property as keyof typeof gradientDefinition] as any;\n          if (gradientProp.stops) {\n            gradientProp.stops.forEach((stop: any) => {\n              if (stop.position >= 0 && stop.position <= 1) {\n                // Calculate position along the line\n                const lineX = startPixelX + (endPixelX - startPixelX) * stop.position;\n                const lineY = startPixelY + (endPixelY - startPixelY) * stop.position;\n                \n                // Offset perpendicular to line based on property type\n                const lineAngle = Math.atan2(endPixelY - startPixelY, endPixelX - startPixelX);\n                const perpAngle = lineAngle + Math.PI / 2;\n                const offsetDistance = propIndex * 20; // Stack properties\n                \n                const stopX = lineX + Math.cos(perpAngle) * offsetDistance;\n                const stopY = lineY + Math.sin(perpAngle) * offsetDistance;\n                \n                // Draw connection line to main line\n                if (offsetDistance > 0) {\n                  ctx.strokeStyle = '#9ca3af';\n                  ctx.lineWidth = 1;\n                  ctx.setLineDash([2, 2]);\n                  ctx.beginPath();\n                  ctx.moveTo(lineX, lineY);\n                  ctx.lineTo(stopX, stopY);\n                  ctx.stroke();\n                  ctx.setLineDash([]);\n                }\n                \n                // Draw stop marker\n                const stopColor = property === 'character' ? '#8b5cf6' : \n                                property === 'textColor' ? '#3b82f6' : '#f59e0b';\n                ctx.fillStyle = stopColor;\n                ctx.strokeStyle = 'white';\n                ctx.lineWidth = 1;\n                \n                ctx.beginPath();\n                ctx.rect(stopX - 6, stopY - 6, 12, 12);\n                ctx.fill();\n                ctx.stroke();\n                \n                // Draw stop value\n                ctx.fillStyle = 'white';\n                ctx.font = '10px monospace';\n                ctx.textAlign = 'center';\n                ctx.textBaseline = 'middle';\n                \n                const displayValue = property === 'character' ? stop.value : \n                                   property === 'textColor' ? '●' : '■';\n                if (property !== 'character') {\n                  ctx.fillStyle = stop.value;\n                }\n                ctx.fillText(displayValue, stopX, stopY);\n              }\n            });\n          }\n        });\n      }\n      \n      // Draw gradient preview overlay with full opacity (shows exactly what the final result will be)\n      if (gradientPreview && gradientPreview.size > 0) {\n        ctx.globalAlpha = 1.0;\n        \n        gradientPreview.forEach((cell, key) => {\n          const [x, y] = key.split(',').map(Number);\n          const pixelX = x * effectiveCellWidth + panOffset.x;\n          const pixelY = y * effectiveCellHeight + panOffset.y;\n\n          // First, clear the background to hide original canvas content\n          // Use actual canvas background, or app background when canvas is transparent\n          if (canvasBackgroundColor === 'transparent') {\n            ctx.fillStyle = theme === 'dark' ? '#000000' : '#ffffff';\n          } else {\n            ctx.fillStyle = canvasBackgroundColor;\n          }\n          ctx.fillRect(pixelX, pixelY, effectiveCellWidth, effectiveCellHeight);\n\n          // Draw cell background (gradient background color)\n          if (cell.bgColor && cell.bgColor !== 'transparent') {\n            ctx.fillStyle = cell.bgColor;\n            ctx.fillRect(pixelX, pixelY, effectiveCellWidth, effectiveCellHeight);\n          }\n\n          // Draw character\n          if (cell.char && cell.char !== ' ') {\n            ctx.fillStyle = cell.color || '#000000';\n            // Use the same font as the main canvas for 1:1 preview\n            const scaledFontSize = fontMetrics.fontSize * zoom;\n            ctx.font = `${scaledFontSize}px '${fontMetrics.fontFamily}', monospace`;\n            ctx.textAlign = 'center';\n            ctx.textBaseline = 'middle';\n            ctx.fillText(\n              cell.char, \n              pixelX + effectiveCellWidth / 2, \n              pixelY + effectiveCellHeight / 2\n            );\n          }\n        });\n        \n        ctx.globalAlpha = 1.0;\n      }\n    }\n    \n    // Draw hover preview (for brush and other tool-specific previews)\n    // Rendered last so it appears on top of all other overlays\n    if (hoverPreview.active && hoverPreview.cells.length > 0) {\n      // Visual style based on preview mode\n      const getPreviewStyle = (mode: string) => {\n        switch (mode) {\n          case 'brush':\n            return {\n              fillStyle: 'rgba(168, 85, 247, 0.15)', // Subtle purple fill\n              strokeStyle: 'rgba(168, 85, 247, 0.5)', // Purple outline\n              lineWidth: 1\n            };\n          case 'eraser-brush':\n            return {\n              fillStyle: 'rgba(248, 250, 252, 0.25)', // Soft neutral fill\n              strokeStyle: 'rgba(226, 232, 240, 0.7)', // Light gray outline\n              lineWidth: 1,\n              lineDash: [4, 2] as [number, number]\n            };\n          // Future modes can have different visual styles\n          case 'rectangle':\n          case 'ellipse':\n            return {\n              fillStyle: 'rgba(59, 130, 246, 0.15)', // Blue fill\n              strokeStyle: 'rgba(59, 130, 246, 0.5)', // Blue outline\n              lineWidth: 1\n            };\n          default:\n            return {\n              fillStyle: 'rgba(255, 255, 255, 0.1)', // White fill\n              strokeStyle: 'rgba(255, 255, 255, 0.3)', // White outline\n              lineWidth: 1\n            };\n        }\n      };\n      \n      const style = getPreviewStyle(hoverPreview.mode);\n      ctx.fillStyle = style.fillStyle;\n      ctx.strokeStyle = style.strokeStyle;\n      ctx.lineWidth = style.lineWidth;\n      if ('lineDash' in style && style.lineDash) {\n        ctx.setLineDash(style.lineDash);\n      } else {\n        ctx.setLineDash([]);\n      }\n      \n      // Draw each cell in the preview pattern\n      hoverPreview.cells.forEach(({ x, y }) => {\n        const pixelX = x * effectiveCellWidth + panOffset.x;\n        const pixelY = y * effectiveCellHeight + panOffset.y;\n        \n        // Fill cell with semi-transparent color\n        ctx.fillRect(\n          pixelX,\n          pixelY,\n          effectiveCellWidth,\n          effectiveCellHeight\n        );\n        \n        // Outline cell for better visibility\n        ctx.strokeRect(\n          pixelX,\n          pixelY,\n          effectiveCellWidth,\n          effectiveCellHeight\n        );\n      });\n    }\n  }, [selection, lassoSelection, linePreview, effectiveCellWidth, effectiveCellHeight, panOffset, moveState, getTotalOffset, canvasRef, pasteMode, activeTool, gradientApplying, gradientStart, gradientEnd, gradientDefinition, gradientPreview, hoverPreview]);\n\n  // Re-render overlay when dependencies change\n  useEffect(() => {\n    renderOverlay();\n  }, [renderOverlay]);\n\n  return (\n    <>\n      <canvas\n        ref={overlayCanvasRef}\n        className=\"absolute inset-0 pointer-events-none\"\n        style={{\n          zIndex: 10, // Ensure overlay appears above main canvas\n        }}\n      />\n      <InteractiveGradientOverlay />\n    </>\n  );\n};\n","usedDeprecatedRules":[]},{"filePath":"/Users/cameronfoxly/GitHubRepos/Ascii-Motion/src/components/features/CanvasRenderer.tsx","messages":[{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useCallback has a missing dependency: 'canvasRef'. Either include it or remove the dependency array.","line":110,"column":6,"nodeType":"ArrayExpression","endLine":110,"endColumn":127,"suggestions":[{"desc":"Update the dependencies array to be: [canvasRef, canvasBackgroundColor, canvasWidth, canvasHeight, moveState, height, width, drawCell, getCell, getTotalOffset]","fix":{"range":[3601,3722],"text":"[canvasRef, canvasBackgroundColor, canvasWidth, canvasHeight, moveState, height, width, drawCell, getCell, getTotalOffset]"}}]},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useEffect has a missing dependency: 'canvasRef'. Either include it or remove the dependency array.","line":128,"column":6,"nodeType":"ArrayExpression","endLine":128,"endColumn":45,"suggestions":[{"desc":"Update the dependencies array to be: [canvasWidth, canvasHeight, renderGrid, canvasRef]","fix":{"range":[4082,4121],"text":"[canvasWidth, canvasHeight, renderGrid, canvasRef]"}}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useCallback, useEffect } from 'react';\nimport { useCanvasStore } from '../../stores/canvasStore';\nimport { useCanvasContext } from '../../contexts/CanvasContext';\nimport { useCanvasState } from '../../hooks/useCanvasState';\nimport type { Cell } from '../../types';\n\nexport const CanvasRenderer: React.FC = () => {\n  // Canvas context and state\n  const { canvasRef } = useCanvasContext();\n  const {\n    cellSize,\n    moveState,\n    canvasWidth,\n    canvasHeight,\n    getTotalOffset,\n  } = useCanvasState();\n\n  // Canvas store data\n  const { \n    width, \n    height, \n    canvasBackgroundColor,\n    showGrid,\n    getCell\n  } = useCanvasStore();\n\n  // Draw a single cell on the canvas\n  const drawCell = useCallback((ctx: CanvasRenderingContext2D, x: number, y: number, cell?: Cell) => {\n    const pixelX = x * cellSize;\n    const pixelY = y * cellSize;\n\n    // Only draw cell background if it's not the default transparent background\n    if (cell && cell.bgColor !== 'transparent' && cell.bgColor !== '#FFFFFF') {\n      ctx.fillStyle = cell.bgColor;\n      ctx.fillRect(pixelX, pixelY, cellSize, cellSize);\n    }\n\n    // Draw character if present\n    if (cell?.char && cell.char !== ' ') {\n      ctx.fillStyle = cell.color || '#FFFFFF';\n      ctx.font = `${cellSize - 2}px 'Courier New', monospace`;\n      ctx.textAlign = 'center';\n      ctx.textBaseline = 'middle';\n      ctx.fillText(\n        cell.char, \n        pixelX + cellSize / 2, \n        pixelY + cellSize / 2\n      );\n    }\n\n    // Draw grid lines only if grid is visible\n    if (showGrid) {\n      ctx.strokeStyle = canvasBackgroundColor === '#000000' ? '#333333' : '#E5E7EB';\n      ctx.lineWidth = 0.5;\n      ctx.strokeRect(pixelX, pixelY, cellSize, cellSize);\n    }\n  }, [cellSize, canvasBackgroundColor, showGrid]);\n\n  // Render the entire grid\n  const renderGrid = useCallback(() => {\n    const canvas = canvasRef.current;\n    if (!canvas) return;\n\n    const ctx = canvas.getContext('2d');\n    if (!ctx) return;\n\n    // Clear canvas and fill with background color\n    ctx.fillStyle = canvasBackgroundColor;\n    ctx.fillRect(0, 0, canvasWidth, canvasHeight);\n\n    // Create a set of coordinates that are being moved (to skip in normal rendering)\n    const movingCells = new Set<string>();\n    if (moveState) {\n      const originalKeys = moveState.originalPositions ?? new Set(moveState.originalData.keys());\n      originalKeys.forEach(key => {\n        movingCells.add(key);\n      });\n    }\n\n    // Draw all cells (excluding cells that are being moved)\n    for (let y = 0; y < height; y++) {\n      for (let x = 0; x < width; x++) {\n        const key = `${x},${y}`;\n        \n        // Skip cells that are being moved during preview\n        if (movingCells.has(key)) {\n          // Draw empty cell in original position during move (use default black background)\n          drawCell(ctx, x, y, { char: ' ', color: '#FFFFFF', bgColor: '#000000' });\n        } else {\n          const cell = getCell(x, y);\n          drawCell(ctx, x, y, cell);\n        }\n      }\n    }\n\n    // Draw moved cells at their new positions during preview\n    if (moveState && moveState.originalData.size > 0) {\n      const totalOffset = getTotalOffset(moveState);\n      moveState.originalData.forEach((cell, key) => {\n        const [origX, origY] = key.split(',').map(Number);\n        const newX = origX + totalOffset.x;\n        const newY = origY + totalOffset.y;\n        \n        // Only draw if within bounds\n        if (newX >= 0 && newX < width && newY >= 0 && newY < height) {\n          drawCell(ctx, newX, newY, cell);\n        }\n      });\n    }\n  }, [width, height, getCell, drawCell, canvasWidth, canvasHeight, moveState, getTotalOffset, canvasBackgroundColor, showGrid]);\n\n  // Re-render when dependencies change\n  useEffect(() => {\n    renderGrid();\n  }, [renderGrid]);\n\n  // Handle canvas resize\n  useEffect(() => {\n    const canvas = canvasRef.current;\n    if (!canvas) return;\n\n    // Set canvas size\n    canvas.width = canvasWidth;\n    canvas.height = canvasHeight;\n    \n    // Re-render after resize\n    renderGrid();\n  }, [canvasWidth, canvasHeight, renderGrid]);\n\n  return null; // This component only handles rendering logic, no UI\n};\n","usedDeprecatedRules":[]},{"filePath":"/Users/cameronfoxly/GitHubRepos/Ascii-Motion/src/components/features/CanvasSettings.tsx","messages":[{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useEffect has a missing dependency: 'closeTypographyPicker'. Either include it or remove the dependency array.","line":80,"column":6,"nodeType":"ArrayExpression","endLine":80,"endColumn":28,"suggestions":[{"desc":"Update the dependencies array to be: [closeTypographyPicker, showTypographyPicker]","fix":{"range":[3012,3034],"text":"[closeTypographyPicker, showTypographyPicker]"}}]},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useEffect has a missing dependency: 'closeTypographyPicker'. Either include it or remove the dependency array.","line":91,"column":6,"nodeType":"ArrayExpression","endLine":91,"endColumn":8,"suggestions":[{"desc":"Update the dependencies array to be: [closeTypographyPicker]","fix":{"range":[3380,3382],"text":"[closeTypographyPicker]"}}]},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"The ref value 'colorPickerTimeoutRef.current' will likely have changed by the time this effect cleanup function runs. If this ref points to a node rendered by React, copy 'colorPickerTimeoutRef.current' to a variable inside the effect, and use that variable in the cleanup function.","line":97,"column":44,"nodeType":"Identifier","endLine":97,"endColumn":51}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useState, useRef, useEffect } from 'react';\nimport { createPortal } from 'react-dom';\nimport { ColorPickerOverlay } from './ColorPickerOverlay';\nimport { Button } from '@/components/ui/button';\nimport { Tooltip, TooltipContent, TooltipProvider, TooltipTrigger } from '@/components/ui/tooltip';\nimport { Separator } from '@/components/ui/separator';\nimport { Grid3X3, Palette, Type } from 'lucide-react';\nimport { useCanvasStore } from '@/stores/canvasStore';\nimport { useCanvasContext } from '@/contexts/CanvasContext';\nimport { ZoomControls } from './ZoomControls';\n\nexport const CanvasSettings: React.FC = () => {\n  const { \n    width, \n    height, \n    canvasBackgroundColor, \n    showGrid, \n    setCanvasSize, \n    setCanvasBackgroundColor, \n    toggleGrid \n  } = useCanvasStore();\n\n  const {\n    characterSpacing,\n    lineSpacing,\n    fontSize,\n    setCharacterSpacing,\n    setLineSpacing,\n    setFontSize\n  } = useCanvasContext();\n\n  // Replace inline dropdown picker with modal overlay reuse\n  const [showColorPicker, setShowColorPicker] = useState(false);\n  const [showTypographyPicker, setShowTypographyPicker] = useState(false);\n  // (Removed old dropdown animation state)\n  const [typographyPickerAnimationClass, setTypographyPickerAnimationClass] = useState('');\n  // Temp color state removed; modal handles confirmation\n  const [dropdownPosition, setDropdownPosition] = useState({ top: 0, left: 0, width: 0 });\n  const colorPickerRef = useRef<HTMLDivElement>(null);\n  const typographyPickerRef = useRef<HTMLDivElement>(null);\n  const colorPickerTimeoutRef = useRef<NodeJS.Timeout | null>(null);\n  const typographyPickerTimeoutRef = useRef<NodeJS.Timeout | null>(null);\n\n  // Calculate dropdown position\n  const calculatePosition = (buttonRef: HTMLDivElement | null) => {\n    if (!buttonRef) return { top: 0, left: 0, width: 200 };\n    \n    const rect = buttonRef.getBoundingClientRect();\n    return {\n      top: rect.bottom + 4,\n      left: rect.left,\n      width: Math.max(200, rect.width)\n    };\n  };\n\n  // Sync tempColor with actual background color\n  // (Removed tempColor sync effect)\n\n  // Close typography picker when clicking outside (color picker overlay handles its own dialog focus trapping)\n  useEffect(() => {\n    const handleClickOutside = (event: MouseEvent) => {\n      const target = event.target as Node;\n\n      // Check if click is outside typography picker\n      if (showTypographyPicker && \n          typographyPickerRef.current && \n          !typographyPickerRef.current.contains(target)) {\n        // Also check if click is not on the portal dropdown\n        const typographyDropdown = document.getElementById('typography-dropdown');\n        if (!typographyDropdown || !typographyDropdown.contains(target)) {\n          closeTypographyPicker();\n        }\n      }\n    };\n\n    if (showTypographyPicker) {\n      document.addEventListener('mousedown', handleClickOutside);\n      return () => document.removeEventListener('mousedown', handleClickOutside);\n    }\n  }, [showTypographyPicker]);\n\n  // Reset dropdown states when layout might be changing (e.g., window resize)\n  useEffect(() => {\n    const handleLayoutChange = () => {\n      closeColorPicker();\n      closeTypographyPicker();\n    };\n\n    window.addEventListener('resize', handleLayoutChange);\n    return () => window.removeEventListener('resize', handleLayoutChange);\n  }, []);\n\n  // Clean up timeouts on unmount\n  useEffect(() => {\n    return () => {\n      if (colorPickerTimeoutRef.current) {\n        clearTimeout(colorPickerTimeoutRef.current);\n      }\n      if (typographyPickerTimeoutRef.current) {\n        clearTimeout(typographyPickerTimeoutRef.current);\n      }\n    };\n  }, []);\n\n  // Animated show/hide functions for color picker\n  const showColorPickerAnimated = () => {\n    setShowColorPicker(true);\n  };\n\n  const closeColorPicker = () => {\n    setShowColorPicker(false);\n  };\n\n  // Animated show/hide functions for typography picker\n  const showTypographyPickerAnimated = () => {\n    if (typographyPickerTimeoutRef.current) {\n      clearTimeout(typographyPickerTimeoutRef.current);\n    }\n    setShowTypographyPicker(true);\n    setTypographyPickerAnimationClass('dropdown-enter');\n  };\n\n  const closeTypographyPicker = () => {\n    if (!showTypographyPicker) return;\n    \n    setTypographyPickerAnimationClass('dropdown-exit');\n    typographyPickerTimeoutRef.current = setTimeout(() => {\n      setShowTypographyPicker(false);\n      setTypographyPickerAnimationClass('');\n    }, 100); // Match faster exit animation duration\n  };\n\n  const handleColorChange = (color: string) => {\n    setCanvasBackgroundColor(color);\n  };\n\n  // Removed preset color array (presets no longer shown in advanced dialog)\n\n  return (\n    <TooltipProvider>\n      <div className=\"flex flex-col lg:flex-row lg:items-center lg:justify-between w-full gap-3\">\n        {/* Left Section - Canvas Size Controls */}\n        <div className=\"flex items-center gap-2\">\n          <span className=\"text-sm font-medium text-muted-foreground\">Canvas size:</span>\n          \n          {/* Width controls with controls to the left */}\n          <div className=\"flex items-center gap-1\">\n            <div className=\"flex flex-col\">\n              <Button\n                size=\"sm\"\n                variant=\"ghost\"\n                onClick={() => {\n                  const newWidth = Math.max(4, Math.min(200, width + 1));\n                  setCanvasSize(newWidth, height);\n                }}\n                disabled={width >= 200}\n                className=\"h-3 w-6 p-0 text-xs leading-none\"\n              >\n                +\n              </Button>\n              <Button\n                size=\"sm\"\n                variant=\"ghost\"\n                onClick={() => {\n                  const newWidth = Math.max(4, Math.min(200, width - 1));\n                  setCanvasSize(newWidth, height);\n                }}\n                disabled={width <= 4}\n                className=\"h-3 w-6 p-0 text-xs leading-none\"\n              >\n                -\n              </Button>\n            </div>\n            <input\n              type=\"number\"\n              value={width}\n              onChange={(e) => {\n                const numValue = parseInt(e.target.value, 10);\n                if (!isNaN(numValue)) {\n                  const constrainedValue = Math.max(4, Math.min(200, numValue));\n                  setCanvasSize(constrainedValue, height);\n                }\n              }}\n              className=\"w-12 h-7 text-xs text-center border border-border rounded bg-background text-foreground [appearance:textfield] [&::-webkit-outer-spin-button]:appearance-none [&::-webkit-inner-spin-button]:appearance-none\"\n              min=\"4\"\n              max=\"200\"\n            />\n          </div>\n\n          <span className=\"text-xs text-muted-foreground\">×</span>\n\n          {/* Height controls with input and controls to the right */}\n          <div className=\"flex items-center gap-1\">\n            <input\n              type=\"number\"\n              value={height}\n              onChange={(e) => {\n                const numValue = parseInt(e.target.value, 10);\n                if (!isNaN(numValue)) {\n                  const constrainedValue = Math.max(4, Math.min(100, numValue));\n                  setCanvasSize(width, constrainedValue);\n                }\n              }}\n              className=\"w-12 h-7 text-xs text-center border border-border rounded bg-background text-foreground [appearance:textfield] [&::-webkit-outer-spin-button]:appearance-none [&::-webkit-inner-spin-button]:appearance-none\"\n              min=\"4\"\n              max=\"100\"\n            />\n            <div className=\"flex flex-col\">\n              <Button\n                size=\"sm\"\n                variant=\"ghost\"\n                onClick={() => {\n                  const newHeight = Math.max(4, Math.min(100, height + 1));\n                  setCanvasSize(width, newHeight);\n                }}\n                disabled={height >= 100}\n                className=\"h-3 w-6 p-0 text-xs leading-none\"\n              >\n                +\n              </Button>\n              <Button\n                size=\"sm\"\n                variant=\"ghost\"\n                onClick={() => {\n                  const newHeight = Math.max(4, Math.min(100, height - 1));\n                  setCanvasSize(width, newHeight);\n                }}\n                disabled={height <= 4}\n                className=\"h-3 w-6 p-0 text-xs leading-none\"\n              >\n                -\n              </Button>\n            </div>\n          </div>\n        </div>\n\n        {/* Right Section - Display, Text, and Zoom Controls */}\n        <div className=\"flex items-center gap-3\">\n          {/* Display Controls */}\n          <div className=\"flex items-center gap-2\">\n            <span className=\"text-sm font-medium text-muted-foreground\">Display:</span>\n            \n            {/* Grid Toggle */}\n            <Tooltip>\n              <TooltipTrigger asChild>\n                <Button\n                  variant={showGrid ? \"default\" : \"outline\"}\n                  size=\"sm\"\n                  onClick={toggleGrid}\n                  className=\"h-6 w-6 p-0 leading-none flex items-center justify-center [&_svg]:w-3 [&_svg]:h-3\"\n                >\n                  <Grid3X3 className=\"w-3 h-3\" />\n                </Button>\n              </TooltipTrigger>\n              <TooltipContent>\n                <p className=\"text-xs\">{showGrid ? \"Hide grid\" : \"Show grid\"}</p>\n              </TooltipContent>\n            </Tooltip>\n\n            {/* Background Color Picker */}\n            <div className=\"relative\" ref={colorPickerRef}>\n              <Tooltip>\n                <TooltipTrigger asChild>\n                  <Button\n                    variant=\"outline\"\n                    size=\"sm\"\n                    onClick={() => {\n                      closeTypographyPicker();\n                      showColorPickerAnimated();\n                    }}\n                    className={`h-6 w-6 p-0 leading-none flex items-center justify-center relative overflow-hidden ${canvasBackgroundColor === 'transparent' ? 'border-2' : ''}`}\n                    aria-label=\"Canvas background color\"\n                    aria-expanded={showColorPicker}\n                    aria-controls=\"color-dropdown\"\n                  >\n                    {canvasBackgroundColor === 'transparent' ? (\n                      // Match structure/metrics of other buttons: use an inner span with inset background & diagonal\n                      <span className=\"flex items-center justify-center w-full h-full\">\n                        <span className=\"relative block w-full h-full rounded overflow-hidden\">\n                          <span\n                            className=\"absolute inset-0 rounded\"\n                            style={{\n                              backgroundColor: '#ffffff',\n                              backgroundImage: 'linear-gradient(45deg, #ccc 25%, transparent 25%), linear-gradient(-45deg, #ccc 25%, transparent 25%), linear-gradient(45deg, transparent 75%, #ccc 75%), linear-gradient(-45deg, transparent 75%, #ccc 75%)',\n                              backgroundSize: '8px 8px',\n                              backgroundPosition: '0 0, 0 4px, 4px -4px, -4px 0px'\n                            }}\n                          />\n                          <svg\n                            className=\"absolute inset-0 w-full h-full pointer-events-none\"\n                            viewBox=\"0 0 32 32\"\n                            preserveAspectRatio=\"xMidYMid meet\"\n                          >\n                            {/* Slash to match palette panel (bottom-left to top-right) */}\n                            <line x1=\"2\" y1=\"30\" x2=\"30\" y2=\"2\" stroke=\"#dc2626\" strokeWidth=\"2\" strokeLinecap=\"round\" />\n                          </svg>\n                        </span>\n                      </span>\n                    ) : (\n                      <div className=\"flex items-center justify-center w-full h-full\" style={{ backgroundColor: canvasBackgroundColor }}>\n                        <Palette className=\"w-3 h-3\" style={{ color: canvasBackgroundColor === '#FFFFFF' ? '#000000' : '#FFFFFF' }} />\n                      </div>\n                    )}\n                  </Button>\n                </TooltipTrigger>\n                <TooltipContent>\n                  <p className=\"text-xs\">Canvas background color</p>\n                </TooltipContent>\n              </Tooltip>\n            </div>\n\n            {/* Typography Controls */}\n            <div className=\"relative\" ref={typographyPickerRef}>\n              <Tooltip>\n                <TooltipTrigger asChild>\n                  <Button\n                    variant=\"outline\"\n                    size=\"sm\"\n                    onClick={() => {\n                      if (showTypographyPicker) {\n                        closeTypographyPicker();\n                      } else {\n                        const position = calculatePosition(typographyPickerRef.current);\n                        setDropdownPosition(position);\n                        closeColorPicker(); // Close other dropdown first\n                        showTypographyPickerAnimated();\n                      }\n                    }}\n                    className=\"h-6 w-6 p-0 leading-none flex items-center justify-center [&_svg]:w-3 [&_svg]:h-3\"\n                    aria-label=\"Typography settings\"\n                    aria-expanded={showTypographyPicker}\n                    aria-controls=\"typography-dropdown\"\n                  >\n                    <Type className=\"w-3 h-3\" />\n                  </Button>\n                </TooltipTrigger>\n                <TooltipContent>\n                  <p className=\"text-xs\">Typography settings</p>\n                </TooltipContent>\n              </Tooltip>\n            </div>\n          </div>\n\n          <Separator orientation=\"vertical\" className=\"h-6\" />\n\n          {/* Zoom Controls - kept exactly as is */}\n          <ZoomControls />\n  </div>        {/* Typography Picker Dropdown - Portal rendered for proper layering */}\n        {showTypographyPicker && dropdownPosition.top > 0 && createPortal(\n          <div \n            id=\"typography-dropdown\"\n            className={`fixed z-[99999] p-3 bg-popover border border-border rounded-md shadow-lg ${typographyPickerAnimationClass}`}\n            style={{\n              top: `${dropdownPosition.top}px`,\n              left: `${dropdownPosition.left}px`,\n              minWidth: `${dropdownPosition.width}px`\n            }}\n            role=\"menu\"\n            aria-label=\"Typography settings menu\"\n            onMouseDown={(e) => e.stopPropagation()}\n            onClick={(e) => e.stopPropagation()}\n          >\n            <div className=\"space-y-4\">\n              {/* Text Size */}\n              <div>\n                <label className=\"text-xs font-medium text-muted-foreground mb-2 block\">\n                  Text Size: {fontSize}px\n                </label>\n                <input\n                  type=\"range\"\n                  min=\"8\"\n                  max=\"48\"\n                  step=\"1\"\n                  value={fontSize}\n                  onChange={(e) => setFontSize(parseInt(e.target.value))}\n                  className=\"w-full h-2 bg-muted rounded-lg appearance-none cursor-pointer\"\n                />\n                <div className=\"flex justify-between text-xs text-muted-foreground mt-1\">\n                  <span>8px</span>\n                  <span>24px</span>\n                  <span>48px</span>\n                </div>\n              </div>\n\n              {/* Character Spacing */}\n              <div>\n                <label className=\"text-xs font-medium text-muted-foreground mb-2 block\">\n                  Character Spacing: {characterSpacing.toFixed(2)}x\n                </label>\n                <input\n                  type=\"range\"\n                  min=\"0.5\"\n                  max=\"2.0\"\n                  step=\"0.05\"\n                  value={characterSpacing}\n                  onChange={(e) => setCharacterSpacing(parseFloat(e.target.value))}\n                  className=\"w-full h-2 bg-muted rounded-lg appearance-none cursor-pointer\"\n                />\n                <div className=\"flex justify-between text-xs text-muted-foreground mt-1\">\n                  <span>0.5x</span>\n                  <span>1.0x</span>\n                  <span>2.0x</span>\n                </div>\n              </div>\n\n              {/* Line Spacing */}\n              <div>\n                <label className=\"text-xs font-medium text-muted-foreground mb-2 block\">\n                  Line Spacing: {lineSpacing.toFixed(2)}x\n                </label>\n                <input\n                  type=\"range\"\n                  min=\"0.8\"\n                  max=\"2.0\"\n                  step=\"0.05\"\n                  value={lineSpacing}\n                  onChange={(e) => setLineSpacing(parseFloat(e.target.value))}\n                  className=\"w-full h-2 bg-muted rounded-lg appearance-none cursor-pointer\"\n                />\n                <div className=\"flex justify-between text-xs text-muted-foreground mt-1\">\n                  <span>0.8x</span>\n                  <span>1.0x</span>\n                  <span>2.0x</span>\n                </div>\n              </div>\n\n              {/* Reset Button */}\n              <div className=\"pt-2 border-t border-border\">\n                <Button\n                  variant=\"outline\"\n                  size=\"sm\"\n                  onClick={() => {\n                    setFontSize(18);\n                    setCharacterSpacing(1.0);\n                    setLineSpacing(1.0);\n                  }}\n                  className=\"w-full h-7 text-xs\"\n                >\n                  Reset to Default\n                </Button>\n              </div>\n            </div>\n          </div>,\n          document.body\n        )}\n\n        {/* Background Color Picker Modal (full replacement) */}\n        <ColorPickerOverlay\n          isOpen={showColorPicker}\n          onOpenChange={(open) => {\n            setShowColorPicker(open);\n          }}\n          onColorSelect={(color) => {\n            handleColorChange(color);\n          }}\n          initialColor={canvasBackgroundColor}\n          title=\"Edit Canvas Background Color\"\n          showTransparentOption\n          triggerRef={colorPickerRef}\n          anchorPosition=\"bottom-left\"\n        />\n      </div>\n    </TooltipProvider>\n  );\n};\n","usedDeprecatedRules":[]},{"filePath":"/Users/cameronfoxly/GitHubRepos/Ascii-Motion/src/components/features/CanvasSizePicker.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/cameronfoxly/GitHubRepos/Ascii-Motion/src/components/features/CanvasWithShortcuts.tsx","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":19,"column":16,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":19,"endColumn":19,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[685,688],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[685,688],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":21,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":21,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[786,789],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[786,789],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React from 'react';\nimport { CanvasGrid } from './CanvasGrid';\nimport { useKeyboardShortcuts } from '../../hooks/useKeyboardShortcuts';\n\ninterface CanvasWithShortcutsProps {\n  className?: string;\n}\n\n/**\n * Wrapper component that provides keyboard shortcuts functionality\n * to the canvas grid. Must be inside CanvasProvider.\n */\nexport const CanvasWithShortcuts: React.FC<CanvasWithShortcutsProps> = ({ className }) => {\n  // Enable keyboard shortcuts (this hook now requires CanvasContext)\n  const { copySelection, pasteSelection } = useKeyboardShortcuts();\n\n  // Expose keyboard shortcuts to parent via window object for button access\n  React.useEffect(() => {\n    (window as any).canvasShortcuts = { copySelection, pasteSelection };\n    return () => {\n      delete (window as any).canvasShortcuts;\n    };\n  }, [copySelection, pasteSelection]);\n\n  return <CanvasGrid className={className} />;\n};\n","usedDeprecatedRules":[]},{"filePath":"/Users/cameronfoxly/GitHubRepos/Ascii-Motion/src/components/features/CharacterMappingControls.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/cameronfoxly/GitHubRepos/Ascii-Motion/src/components/features/CharacterMappingSection.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/cameronfoxly/GitHubRepos/Ascii-Motion/src/components/features/CharacterPalette.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/cameronfoxly/GitHubRepos/Ascii-Motion/src/components/features/CharacterPaletteEditor.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/cameronfoxly/GitHubRepos/Ascii-Motion/src/components/features/ColorPicker.tsx","messages":[{"ruleId":"prefer-const","severity":2,"message":"'currentIndex' is never reassigned. Use 'const' instead.","line":170,"column":9,"nodeType":"Identifier","messageId":"useConst","endLine":170,"endColumn":21,"fix":{"range":[6543,6574],"text":"const currentIndex = sourceIndex;"}}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":1,"fixableWarningCount":0,"source":"import React, { useState, useEffect } from 'react';\nimport { useToolStore } from '../../stores/toolStore';\nimport { usePaletteStore } from '../../stores/paletteStore';\nimport { Card, CardContent } from '@/components/ui/card';\nimport { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs';\nimport { Button } from '@/components/ui/button';\nimport { Select, SelectContent, SelectItem, SelectSeparator, SelectTrigger, SelectValue } from '@/components/ui/select';\nimport { Tooltip, TooltipContent, TooltipProvider, TooltipTrigger } from '@/components/ui/tooltip';\nimport { Collapsible, CollapsibleContent } from '@/components/ui/collapsible';\nimport { Palette, Type, Settings, Plus, Trash2, ChevronLeft, ChevronRight, Upload, Download } from 'lucide-react';\nimport { CollapsibleHeader } from '../common/CollapsibleHeader';\nimport { PanelSeparator } from '../common/PanelSeparator';\nimport { ColorPickerOverlay } from './ColorPickerOverlay';\nimport { ImportPaletteDialog } from './ImportPaletteDialog';\nimport { ExportPaletteDialog } from './ExportPaletteDialog';\nimport { ManagePalettesDialog } from './ManagePalettesDialog';\nimport { EffectsSection } from './EffectsSection';\nimport { ANSI_COLORS } from '../../constants/colors';\n\ninterface ColorPickerProps {\n  className?: string;\n}\n\nexport const ColorPicker: React.FC<ColorPickerProps> = ({ className = '' }) => {\n  const { selectedColor, selectedBgColor, setSelectedColor, setSelectedBgColor } = useToolStore();\n  const { \n    palettes,\n    activePaletteId,\n    selectedColorId,\n    getActivePalette,\n    getActiveColors,\n    getCustomPalettes,\n    getPresetPalettes,\n    setActivePalette,\n    setSelectedColor: setSelectedColorId,\n    addColor,\n    removeColor,\n    updateColor,\n    moveColorLeft,\n    moveColorRight,\n    createCustomPalette,\n    initialize,\n    addRecentColor\n  } = usePaletteStore();\n\n  const [activeTab, setActiveTab] = useState(\"text\");\n  const [isColorPickerOpen, setIsColorPickerOpen] = useState(false);\n  const [colorPickerMode, setColorPickerMode] = useState<'foreground' | 'background' | 'palette'>('foreground');\n  const [colorPickerInitialColor, setColorPickerInitialColor] = useState('#000000');\n  const [colorPickerTriggerRef, setColorPickerTriggerRef] = useState<React.RefObject<HTMLElement | null> | undefined>(undefined);\n  const [editingColorId, setEditingColorId] = useState<string | null>(null);\n  const [isImportDialogOpen, setIsImportDialogOpen] = useState(false);\n  const [isExportDialogOpen, setIsExportDialogOpen] = useState(false);\n  const [isManagePalettesOpen, setIsManagePalettesOpen] = useState(false);\n  \n  // Collapsible section states\n  const [isPaletteSectionOpen, setIsPaletteSectionOpen] = useState(false);\n\n  // Initialize palette store on mount (ensure default palettes are loaded)\n  useEffect(() => {\n    if (palettes.length === 0) {\n      initialize();\n    }\n  }, [palettes.length, initialize]);\n\n  // Get active palette and colors\n  const activePalette = getActivePalette();\n  const activeColors = getActiveColors();\n  const customPalettes = getCustomPalettes();\n  const presetPalettes = getPresetPalettes();\n\n  // Filter colors for foreground (no transparent) and background (always include transparent)\n  const foregroundColors = activeColors.filter(color => color.value !== 'transparent' && color.value !== ANSI_COLORS.transparent);\n  const backgroundColors = [\n    { id: 'transparent', value: 'transparent', name: 'Transparent' }, \n    ...activeColors.filter(color => color.value !== 'transparent' && color.value !== ANSI_COLORS.transparent)\n  ];\n\n  // Handle palette selection\n  const handlePaletteChange = (paletteId: string) => {\n    setActivePalette(paletteId);\n    setSelectedColorId(null);\n  };\n\n  // Handle color selection from palette\n  const handleColorSelect = (color: string, isBackground = false) => {\n    if (isBackground) {\n      setSelectedBgColor(color);\n    } else {\n      setSelectedColor(color);\n    }\n    addRecentColor(color);\n  };\n\n  // Handle color selection for editing (single click)\n  const handleColorPaletteSelect = (colorId: string) => {\n    setSelectedColorId(selectedColorId === colorId ? null : colorId);\n  };\n\n  // Get current active color based on which tab is active\n  const getCurrentActiveColor = () => {\n    if (activeTab === 'bg') {\n      // If background is transparent, use default grey instead\n      if (selectedBgColor === 'transparent' || selectedBgColor === ANSI_COLORS.transparent) {\n        return '#808080';\n      }\n      return selectedBgColor;\n    }\n    return selectedColor;\n  };\n\n  // Drag and drop state\n  const [draggedColorId, setDraggedColorId] = useState<string | null>(null);\n  const [dropIndicatorIndex, setDropIndicatorIndex] = useState<number | null>(null);\n\n  // Handle drag start\n  const handleDragStart = (e: React.DragEvent, colorId: string) => {\n    if (!activePalette) {\n      e.preventDefault();\n      return;\n    }\n    setDraggedColorId(colorId);\n    e.dataTransfer.effectAllowed = 'move';\n  };\n\n  // Handle drag over\n  const handleDragOver = (e: React.DragEvent, targetColorId?: string) => {\n    if (!activePalette || !draggedColorId) return;\n    e.preventDefault();\n    e.dataTransfer.dropEffect = 'move';\n    \n    if (targetColorId) {\n      const targetIndex = activeColors.findIndex(c => c.id === targetColorId);\n      if (targetIndex !== -1) {\n        // Determine if we should show indicator before or after based on mouse position\n        const rect = (e.target as HTMLElement).getBoundingClientRect();\n        const mouseX = e.clientX - rect.left;\n        const isAfter = mouseX > rect.width / 2;\n        setDropIndicatorIndex(isAfter ? targetIndex + 1 : targetIndex);\n      }\n    }\n  };\n\n  // Handle drop\n  const handleDrop = (e: React.DragEvent, targetColorId: string) => {\n    e.preventDefault();\n    if (!activePalette || !draggedColorId || draggedColorId === targetColorId) {\n      setDraggedColorId(null);\n      setDropIndicatorIndex(null);\n      return;\n    }\n\n    // Find indices of source and target colors\n    const sourceIndex = activeColors.findIndex(c => c.id === draggedColorId);\n    const targetIndex = activeColors.findIndex(c => c.id === targetColorId);\n    \n    if (sourceIndex === -1 || targetIndex === -1) {\n      setDraggedColorId(null);\n      setDropIndicatorIndex(null);\n      return;\n    }\n\n    // Determine final position based on drop indicator\n    let finalTargetIndex = targetIndex;\n    if (dropIndicatorIndex === targetIndex + 1) {\n      finalTargetIndex = targetIndex + 1;\n    }\n\n    // Move the colors\n    let currentIndex = sourceIndex;\n    if (currentIndex < finalTargetIndex) {\n      // Moving right - use moveColorRight\n      for (let i = 0; i < finalTargetIndex - sourceIndex; i++) {\n        moveColorRight(activePaletteId, draggedColorId);\n      }\n    } else if (currentIndex > finalTargetIndex) {\n      // Moving left - use moveColorLeft\n      for (let i = 0; i < sourceIndex - finalTargetIndex; i++) {\n        moveColorLeft(activePaletteId, draggedColorId);\n      }\n    }\n\n    setDraggedColorId(null);\n    setDropIndicatorIndex(null);\n  };\n\n  // Handle drag leave\n  const handleDragLeave = (e: React.DragEvent) => {\n    // Only clear if leaving the grid container\n    if (!e.currentTarget.contains(e.relatedTarget as Node)) {\n      setDropIndicatorIndex(null);\n    }\n  };\n\n  // Handle color double-click to edit\n  const handleColorDoubleClick = (color: string, event: React.MouseEvent<HTMLElement>) => {\n    if (activePalette) {\n      const colorItem = activeColors.find(c => c.value === color);\n      setEditingColorId(colorItem?.id || null);\n      setColorPickerMode('palette');\n      setColorPickerInitialColor(color);\n      \n      // Create a ref from the clicked element\n      const elementRef = { current: event.currentTarget };\n      setColorPickerTriggerRef(elementRef);\n      \n      setIsColorPickerOpen(true);\n    }\n  };\n\n  // Handle color picker selection\n  const handleColorPickerSelect = (newColor: string) => {\n    if (colorPickerMode === 'palette' && editingColorId) {\n      // Update the color in the palette\n      updateColor(activePaletteId, editingColorId, newColor);\n      // Clear editing state\n      setEditingColorId(null);\n      setColorPickerMode('foreground');\n    } else if (colorPickerMode === 'foreground') {\n      setSelectedColor(newColor);\n    } else if (colorPickerMode === 'background') {\n      setSelectedBgColor(newColor);\n    }\n  };\n\n  // Handle real-time color changes (for live preview)\n  const handleColorPickerChange = (newColor: string) => {\n    // Apply color changes immediately for real-time feedback\n    if (colorPickerMode === 'foreground') {\n      setSelectedColor(newColor);\n    } else if (colorPickerMode === 'background') {\n      setSelectedBgColor(newColor);\n    }\n    // Note: palette colors don't get real-time updates to avoid confusion\n  };\n\n  // Check if color is currently selected \n  const isColorSelected = (color: string, isBackground = false) => {\n    return isBackground ? selectedBgColor === color : selectedColor === color;\n  };\n\n  return (\n    <div className={`space-y-3 ${className}`}>\n      {/* Color Palette Section */}\n      <Collapsible open={isPaletteSectionOpen} onOpenChange={setIsPaletteSectionOpen}>\n        <CollapsibleHeader isOpen={isPaletteSectionOpen}>\n          <div className=\"flex items-center gap-2\">\n            <Palette className=\"w-4 h-4\" />\n            Color Palette\n          </div>\n        </CollapsibleHeader>\n        <CollapsibleContent className=\"collapsible-content space-y-3 mt-2\">\n          {/* Palette selector with inline buttons */}\n          <div className=\"flex items-center gap-1\">\n            <div className=\"w-28 flex-shrink-0\">\n              <Select value={activePaletteId || ''} onValueChange={handlePaletteChange}>\n                <TooltipProvider>\n                  <Tooltip>\n                    <TooltipTrigger asChild>\n                      <SelectTrigger className=\"w-full h-8 text-xs\">\n                        <SelectValue placeholder=\"Select palette...\" className=\"truncate\" />\n                      </SelectTrigger>\n                    </TooltipTrigger>\n                    <TooltipContent>\n                      <p>Cycle colors with Shift + [ or ]</p>\n                    </TooltipContent>\n                  </Tooltip>\n                </TooltipProvider>\n              <SelectContent>\n                {customPalettes.length > 0 && (\n                  <>\n                    {customPalettes.map((palette) => (\n                      <SelectItem key={palette.id} value={palette.id} className=\"text-xs\">\n                        <span>{palette.name}</span>\n                      </SelectItem>\n                    ))}\n                    <SelectSeparator />\n                  </>\n                )}\n                {presetPalettes.map((palette) => (\n                  <SelectItem key={palette.id} value={palette.id} className=\"text-xs\">\n                    <span>{palette.name}</span>\n                  </SelectItem>\n                ))}\n              </SelectContent>\n            </Select>\n            </div>\n            \n            <TooltipProvider>\n              <Tooltip>\n                <TooltipTrigger asChild>\n                  <Button\n                    size=\"sm\"\n                    variant=\"outline\"\n                    className=\"h-8 w-8 p-0 flex-shrink-0\"\n                    onClick={() => {\n                      const newPaletteId = createCustomPalette('New Palette');\n                      setActivePalette(newPaletteId);\n                    }}\n                  >\n                    <Plus className=\"h-3 w-3\" />\n                  </Button>\n                </TooltipTrigger>\n                <TooltipContent>\n                  <p>Create new palette</p>\n                </TooltipContent>\n              </Tooltip>\n            </TooltipProvider>\n\n            <TooltipProvider>\n              <Tooltip>\n                <TooltipTrigger asChild>\n                  <Button\n                    size=\"sm\"\n                    variant=\"outline\"\n                    className=\"h-8 w-8 p-0 flex-shrink-0\"\n                    onClick={() => setIsManagePalettesOpen(true)}\n                  >\n                    <Settings className=\"h-3 w-3\" />\n                  </Button>\n                </TooltipTrigger>\n                <TooltipContent>\n                  <p>Manage palettes</p>\n                </TooltipContent>\n              </Tooltip>\n            </TooltipProvider>\n          </div>\n\n          {/* Color palette tabs */}\n          <Tabs value={activeTab} onValueChange={setActiveTab} className=\"w-full\">\n            <TabsList className=\"grid w-full grid-cols-2 h-8\">\n              <TabsTrigger value=\"text\" className=\"text-xs h-full flex items-center justify-center gap-1\">\n                <Type className=\"w-3 h-3\" />\n                Text\n              </TabsTrigger>\n              <TabsTrigger value=\"bg\" className=\"text-xs h-full flex items-center justify-center gap-1\">\n                <Palette className=\"w-3 h-3\" />\n                BG\n              </TabsTrigger>\n            </TabsList>\n\n            {/* Foreground colors */}\n            <TabsContent value=\"text\" className=\"mt-2\">\n              <Card className=\"bg-card/50 border-border/50\">\n                <CardContent className=\"p-2\">\n                  <TooltipProvider>\n                    <div className=\"grid grid-cols-6 gap-0.5 relative flex items-center justify-center\" onDragLeave={handleDragLeave}>\n                      {foregroundColors.map((color, index) => (\n                        <div key={`text-${color.id}`} className=\"relative flex items-center justify-center\">\n                          {/* Drop indicator line */}\n                          {dropIndicatorIndex === index && (\n                            <div className=\"absolute -left-0.5 top-0 bottom-0 w-0.5 bg-primary z-10 rounded-full\"></div>\n                          )}\n                          \n                          <Tooltip>\n                            <TooltipTrigger asChild>\n                              <button\n                                draggable={!!activePalette}\n                                className={`w-6 h-6 rounded border-2 transition-all hover:scale-105 relative ${\n                                  draggedColorId === color.id ? 'opacity-50 scale-95' : ''\n                                } ${\n                                  selectedColorId === color.id\n                                    ? 'border-primary ring-2 ring-primary/20 shadow-lg' \n                                    : isColorSelected(color.value, false)\n                                    ? 'border-primary ring-1 ring-primary/20' \n                                    : 'border-border'\n                                } cursor-move`}\n                                style={{ backgroundColor: color.value }}\n                                onClick={() => {\n                                  // Single click sets drawing color and selects for editing\n                                  handleColorSelect(color.value, false);\n                                  handleColorPaletteSelect(color.id);\n                                }}\n                                onDoubleClick={(e) => handleColorDoubleClick(color.value, e)}\n                                onDragStart={(e) => handleDragStart(e, color.id)}\n                                onDragOver={(e) => handleDragOver(e, color.id)}\n                                onDrop={(e) => handleDrop(e, color.id)}\n                              />\n                            </TooltipTrigger>\n                            <TooltipContent>\n                              <p>\n                                {color.name ? `${color.name}: ${color.value}` : color.value}\n                                {activePalette?.isCustom && ' (drag to reorder)'}\n                              </p>\n                              <p className=\"text-xs text-foreground/80 pt-1\">Shift+[ / Shift+] cycle colors</p>\n                            </TooltipContent>\n                          </Tooltip>\n                        \n                        {/* Drop indicator line after last item */}\n                        {dropIndicatorIndex === index + 1 && (\n                          <div className=\"absolute -right-0.5 top-0 bottom-0 w-0.5 bg-primary z-10 rounded-full\"></div>\n                        )}\n                        </div>\n                      ))}\n                    </div>\n                  </TooltipProvider>\n                </CardContent>\n              </Card>\n            </TabsContent>\n\n            {/* Background colors */}\n            <TabsContent value=\"bg\" className=\"mt-2\">\n              <Card className=\"bg-card/50 border-border/50\">\n                <CardContent className=\"p-2\">\n                  <TooltipProvider>\n                    <div className=\"grid grid-cols-6 gap-0.5 relative flex items-center justify-center\" onDragLeave={handleDragLeave}>\n                      {backgroundColors.map((color, index) => {\n                        const isTransparent = color.value === 'transparent';\n                        return (\n                          <div key={`bg-${color.id}`} className=\"relative flex items-center justify-center\">\n                            {/* Drop indicator line */}\n                            {dropIndicatorIndex === index && (\n                              <div className=\"absolute -left-0.5 top-0 bottom-0 w-0.5 bg-primary z-10 rounded-full\"></div>\n                            )}\n                            \n                            <Tooltip>\n                              <TooltipTrigger asChild>\n                                <button\n                                  draggable={!!activePalette && !isTransparent}\n                                  className={`w-6 h-6 rounded border-2 transition-all hover:scale-105 relative overflow-hidden ${\n                                    draggedColorId === color.id ? 'opacity-50 scale-95' : ''\n                                  } ${\n                                    selectedColorId === color.id\n                                      ? 'border-primary ring-2 ring-primary/20 shadow-lg' \n                                      : isColorSelected(color.value, true)\n                                      ? 'border-primary ring-1 ring-primary/20' \n                                      : 'border-border'\n                                  } ${!isTransparent ? 'cursor-move' : 'cursor-pointer'}`}\n                                  style={{\n                                    backgroundColor: isTransparent ? '#ffffff' : color.value,\n                                    backgroundImage: isTransparent \n                                      ? 'linear-gradient(45deg, #ccc 25%, transparent 25%), linear-gradient(-45deg, #ccc 25%, transparent 25%), linear-gradient(45deg, transparent 75%, #ccc 75%), linear-gradient(-45deg, transparent 75%, #ccc 75%)'\n                                      : 'none',\n                                    backgroundSize: isTransparent ? '8px 8px' : 'auto',\n                                    backgroundPosition: isTransparent ? '0 0, 0 4px, 4px -4px, -4px 0px' : 'auto'\n                                  }}\n                                  onClick={() => {\n                                    handleColorSelect(color.value, true);\n                                    handleColorPaletteSelect(color.id);\n                                  }}\n                                  onDoubleClick={(e) => !isTransparent && handleColorDoubleClick(color.value, e)}\n                                  onDragStart={(e) => handleDragStart(e, color.id)}\n                                  onDragOver={(e) => handleDragOver(e, color.id)}\n                                  onDrop={(e) => handleDrop(e, color.id)}\n                                >\n                            {isTransparent && (\n                              <svg \n                                className=\"absolute inset-0 w-full h-full pointer-events-none\" \n                                viewBox=\"0 0 24 24\"\n                                style={{ borderRadius: 'inherit' }}\n                              >\n                                <line \n                                  x1=\"2\" y1=\"2\" \n                                  x2=\"22\" y2=\"22\" \n                                  stroke=\"#ef4444\" \n                                  strokeWidth=\"2\"\n                                />\n                              </svg>\n                            )}\n                                </button>\n                              </TooltipTrigger>\n                              <TooltipContent>\n                                <p>\n                                  {isTransparent \n                                    ? 'Transparent background' \n                                    : color.name ? `${color.name}: ${color.value}` : color.value}\n                                  {!isTransparent && activePalette?.isCustom && ' (drag to reorder)'}\n                                </p>\n                                <p className=\"text-xs text-foreground/80 pt-1\">Shift+[ / Shift+] cycle colors</p>\n                              </TooltipContent>\n                            </Tooltip>\n                          \n                            {/* Drop indicator line after last item */}\n                            {dropIndicatorIndex === index + 1 && (\n                              <div className=\"absolute -right-0.5 top-0 bottom-0 w-0.5 bg-primary z-10 rounded-full\"></div>\n                            )}\n                          </div>\n                        );\n                      })}\n                    </div>\n                  </TooltipProvider>\n                </CardContent>\n              </Card>\n            </TabsContent>\n          </Tabs>\n\n          {/* Palette controls */}\n          {activePalette && (\n            <div className=\"flex items-center justify-between\">\n              {/* Editing controls (only for custom palettes) */}\n              <div className=\"flex gap-0.5\">\n                <TooltipProvider>\n                  <Tooltip>\n                    <TooltipTrigger asChild>\n                      <Button\n                        size=\"sm\"\n                        variant=\"outline\"\n                        className=\"h-6 w-6 p-0\"\n                        onClick={() => selectedColorId && moveColorLeft(activePaletteId, selectedColorId)}\n                        disabled={!selectedColorId || !activePalette?.isCustom}\n                      >\n                        <ChevronLeft className=\"h-3 w-3\" />\n                      </Button>\n                    </TooltipTrigger>\n                    <TooltipContent>\n                      <p>Move color left{!activePalette?.isCustom ? ' (will create custom copy)' : ''}</p>\n                    </TooltipContent>\n                  </Tooltip>\n                </TooltipProvider>\n\n                <TooltipProvider>\n                  <Tooltip>\n                    <TooltipTrigger asChild>\n                      <Button\n                        size=\"sm\"\n                        variant=\"outline\"\n                        className=\"h-6 w-6 p-0\"\n                        onClick={() => selectedColorId && moveColorRight(activePaletteId, selectedColorId)}\n                        disabled={!selectedColorId || !activePalette?.isCustom}\n                      >\n                        <ChevronRight className=\"h-3 w-3\" />\n                      </Button>\n                    </TooltipTrigger>\n                    <TooltipContent>\n                      <p>Move color right{!activePalette?.isCustom ? ' (will create custom copy)' : ''}</p>\n                    </TooltipContent>\n                  </Tooltip>\n                </TooltipProvider>\n\n                <TooltipProvider>\n                  <Tooltip>\n                    <TooltipTrigger asChild>\n                      <Button\n                        size=\"sm\"\n                        variant=\"outline\"\n                        className=\"h-6 w-6 p-0\"\n                        onClick={() => addColor(activePaletteId, getCurrentActiveColor())}\n                      >\n                        <Plus className=\"h-3 w-3\" />\n                      </Button>\n                    </TooltipTrigger>\n                    <TooltipContent>\n                      <p>Add color{!activePalette?.isCustom ? ' (will create custom copy)' : ''}</p>\n                    </TooltipContent>\n                  </Tooltip>\n                </TooltipProvider>\n\n                <TooltipProvider>\n                  <Tooltip>\n                    <TooltipTrigger asChild>\n                      <Button\n                        size=\"sm\"\n                        variant=\"outline\"\n                        className=\"h-6 w-6 p-0\"\n                        onClick={() => selectedColorId && removeColor(activePaletteId, selectedColorId)}\n                        disabled={!selectedColorId || activeColors.length <= 1}\n                      >\n                        <Trash2 className=\"h-3 w-3\" />\n                      </Button>\n                    </TooltipTrigger>\n                    <TooltipContent>\n                      <p>Remove color{!activePalette?.isCustom ? ' (will create custom copy)' : ''}</p>\n                    </TooltipContent>\n                    </Tooltip>\n                  </TooltipProvider>\n                </div>\n\n              {/* Import/Export buttons (always visible) */}\n              <div className=\"flex gap-0.5\">\n                <TooltipProvider>\n                  <Tooltip>\n                    <TooltipTrigger asChild>\n                      <Button\n                        size=\"sm\"\n                        variant=\"outline\"\n                        className=\"h-6 w-6 p-0\"\n                        onClick={() => setIsImportDialogOpen(true)}\n                      >\n                        <Upload className=\"h-3 w-3\" />\n                      </Button>\n                    </TooltipTrigger>\n                    <TooltipContent>\n                      <p>Import palette</p>\n                    </TooltipContent>\n                  </Tooltip>\n                </TooltipProvider>\n\n                <TooltipProvider>\n                  <Tooltip>\n                    <TooltipTrigger asChild>\n                      <Button\n                        size=\"sm\"\n                        variant=\"outline\"\n                        className=\"h-6 w-6 p-0\"\n                        onClick={() => setIsExportDialogOpen(true)}\n                      >\n                        <Download className=\"h-3 w-3\" />\n                      </Button>\n                    </TooltipTrigger>\n                    <TooltipContent>\n                      <p>Export palette</p>\n                    </TooltipContent>\n                  </Tooltip>\n                </TooltipProvider>\n              </div>\n            </div>\n          )}\n\n          {/* Status text */}\n          {activePalette && (\n            <div className=\"text-xs text-muted-foreground text-center\">\n              {activePalette.name} • {activeColors.length} colors\n              {selectedColorId && (\n                <span className=\"ml-2\">\n                  • Selected: {activeColors.find(c => c.id === selectedColorId)?.name || 'Color'}\n                </span>\n              )}\n            </div>\n          )}\n        </CollapsibleContent>\n      </Collapsible>\n\n      {/* Divider between Color Palette and Effects */}\n      <PanelSeparator />\n\n      {/* Effects Section */}\n      <EffectsSection />\n\n      {/* Divider after Effects */}\n      <PanelSeparator />\n\n      {/* Color Picker Modal */}\n      <ColorPickerOverlay\n        isOpen={isColorPickerOpen}\n        onOpenChange={(open) => {\n          setIsColorPickerOpen(open);\n          // Reset editing state when closing\n          if (!open && colorPickerMode === 'palette') {\n            setEditingColorId(null);\n            setColorPickerMode('foreground');\n            setColorPickerTriggerRef(undefined);\n          }\n        }}\n        onColorSelect={handleColorPickerSelect}\n        onColorChange={colorPickerMode !== 'palette' ? handleColorPickerChange : undefined}\n        initialColor={colorPickerInitialColor}\n        title={\n          colorPickerMode === 'palette' \n            ? 'Edit Palette Color' \n            : `Edit ${colorPickerMode === 'foreground' ? 'Foreground' : 'Background'} Color`\n        }\n        showTransparentOption={colorPickerMode === 'background'}\n        triggerRef={colorPickerTriggerRef}\n        anchorPosition=\"bottom-right\"\n      />\n\n      {/* Import/Export Dialogs */}\n      <ImportPaletteDialog\n        isOpen={isImportDialogOpen}\n        onOpenChange={setIsImportDialogOpen}\n      />\n      \n      <ExportPaletteDialog\n        isOpen={isExportDialogOpen}\n        onOpenChange={setIsExportDialogOpen}\n      />\n\n      {/* Manage Palettes Dialog */}\n      <ManagePalettesDialog\n        isOpen={isManagePalettesOpen}\n        onOpenChange={setIsManagePalettesOpen}\n      />\n    </div>\n  );\n};\n","usedDeprecatedRules":[]},{"filePath":"/Users/cameronfoxly/GitHubRepos/Ascii-Motion/src/components/features/ColorPickerOverlay.tsx","messages":[{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useEffect has a missing dependency: 'updateColorWheelPosition'. Either include it or remove the dependency array.","line":136,"column":6,"nodeType":"ArrayExpression","endLine":136,"endColumn":28,"suggestions":[{"desc":"Update the dependencies array to be: [isOpen, initialColor, updateColorWheelPosition]","fix":{"range":[5405,5427],"text":"[isOpen, initialColor, updateColorWheelPosition]"}}]},{"ruleId":"prefer-const","severity":2,"message":"'right' is never reassigned. Use 'const' instead.","line":242,"column":11,"nodeType":"Identifier","messageId":"useConst","endLine":242,"endColumn":16,"fix":{"range":[9140,9193],"text":"const right = window.innerWidth - triggerRect.left + 8;"}},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useEffect has a missing dependency: 'handleColorWheelInteraction'. Either include it or remove the dependency array.","line":594,"column":6,"nodeType":"ArrayExpression","endLine":594,"endColumn":18,"suggestions":[{"desc":"Update the dependencies array to be: [handleColorWheelInteraction, isDragging]","fix":{"range":[21272,21284],"text":"[handleColorWheelInteraction, isDragging]"}}]},{"ruleId":"@typescript-eslint/ban-ts-comment","severity":2,"message":"Use \"@ts-expect-error\" instead of \"@ts-ignore\", as \"@ts-ignore\" will do nothing if the following line is error-free.","line":600,"column":9,"nodeType":"Line","messageId":"tsIgnoreInsteadOfExpectError","endLine":600,"endColumn":55,"suggestions":[{"messageId":"replaceTsIgnoreWithTsExpectError","fix":{"range":[21413,21459],"text":"// @ts-expect-error - EyeDropper API is experimental"},"desc":"Replace \"@ts-ignore\" with \"@ts-expect-error\"."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'error' is defined but never used.","line":604,"column":16,"nodeType":null,"messageId":"unusedVar","endLine":604,"endColumn":21}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":1,"fixableWarningCount":0,"source":"// Advanced color picker overlay with improved HSV/RGB/HEX controls and interactive color wheel\n\nimport React, { useState, useCallback, useEffect, useRef } from 'react';\nimport { createPortal } from 'react-dom';\nimport { Button } from '@/components/ui/button';\nimport { Input } from '@/components/ui/input';\nimport { Slider } from '@/components/ui/slider';\nimport { Label } from '@/components/ui/label';\nimport { Separator } from '@/components/ui/separator';\nimport { Card, CardContent } from '@/components/ui/card';\nimport { Pipette, RotateCcw, Check, X } from 'lucide-react';\nimport { DraggableDialogBar } from '@/components/common/DraggableDialogBar';\nimport { usePaletteStore } from '../../stores/paletteStore';\nimport type { HSVColor, RGBColor } from '../../types/palette';\nimport { \n  hexToRgb, \n  rgbToHex, \n  hexToHsv, \n  hsvToHex, \n  hsvToRgb, \n  rgbToHsv,\n  normalizeHexColor\n} from '../../utils/colorConversion';\nimport { ANSI_COLORS } from '../../constants/colors';\n\ninterface ColorPickerOverlayProps {\n  isOpen: boolean;\n  onOpenChange: (open: boolean) => void;\n  onColorSelect: (color: string) => void;\n  onColorChange?: (color: string) => void; // For real-time updates\n  onCancel?: () => void; // For canceling changes\n  initialColor?: string;\n  title?: string;\n  showTransparentOption?: boolean; // whether to show the transparent quick-set button\n  triggerRef?: React.RefObject<HTMLElement | null>; // Reference to trigger element for positioning\n  anchorPosition?: 'left-slide' | 'right-slide' | 'bottom-left' | 'bottom-right' | 'gradient-panel' | 'import-media-panel';\n}\n\nexport const ColorPickerOverlay: React.FC<ColorPickerOverlayProps> = ({\n  isOpen,\n  onOpenChange,\n  onColorSelect,\n  onColorChange,\n  onCancel,\n  initialColor = '#000000',\n  title = 'Color Picker',\n  showTransparentOption = false,\n  triggerRef,\n  anchorPosition = 'left-slide'\n}) => {\n  const { updatePreviewColor, addRecentColor, recentColors } = usePaletteStore();\n  const pickerRef = useRef<HTMLDivElement>(null);\n  const previousColorRef = useRef<string | null>(null);\n\n  // Check if initial color is transparent\n  const isTransparent = initialColor === 'transparent' || initialColor === ANSI_COLORS.transparent;\n  \n  // Color state in different formats\n  const [currentColor, setCurrentColor] = useState(initialColor);\n  const [previewColor, setPreviewColor] = useState(isTransparent ? 'transparent' : initialColor);\n  const [hexInput, setHexInput] = useState(isTransparent ? '' : initialColor);\n  const [rgbValues, setRgbValues] = useState<RGBColor>({ r: 0, g: 0, b: 0 });\n  // Initialize HSV values from the initial color\n  const getInitialHSV = () => {\n    if (initialColor === 'transparent' || initialColor === ANSI_COLORS.transparent) {\n      return { h: 0, s: 0, v: 0 };\n    }\n    const hsv = hexToHsv(normalizeHexColor(initialColor));\n    return hsv || { h: 120, s: 100, v: 80 }; // Default to green if parsing fails\n  };\n  \n  const [hsvValues, setHsvValues] = useState<HSVColor>(getInitialHSV());\n  const [colorWheelPosition, setColorWheelPosition] = useState({ x: 80, y: 80 }); // Center of 160px wheel\n  const [valueSliderValue, setValueSliderValue] = useState(() => {\n    if (initialColor === 'transparent' || initialColor === ANSI_COLORS.transparent) {\n      return 0;\n    }\n    const hsv = hexToHsv(normalizeHexColor(initialColor));\n    return hsv ? hsv.v : 80; // Default to 80% if parsing fails\n  });\n  const [isDragging, setIsDragging] = useState(false);\n  const [isTransparentColor, setIsTransparentColor] = useState(isTransparent);\n  const [hasInitialized, setHasInitialized] = useState(false);\n  const [positionOffset, setPositionOffset] = useState({ x: 0, y: 0 });\n  const [isDraggingDialog, setIsDraggingDialog] = useState(false);\n  const [hasBeenDragged, setHasBeenDragged] = useState(false);\n  const dragStartOffsetRef = useRef({ x: 0, y: 0 });\n  \n  const colorWheelRef = useRef<HTMLDivElement>(null);\n  // Ref for hex input to auto-focus on open\n  const hexInputRef = useRef<HTMLInputElement | null>(null);\n\n  // Initialize color values when dialog opens or initial color changes\n  useEffect(() => {\n    if (isOpen) {\n      // Reset position offset and drag state when dialog opens\n      setPositionOffset({ x: 0, y: 0 });\n      setHasBeenDragged(false);\n      \n      const transparent = initialColor === 'transparent' || initialColor === ANSI_COLORS.transparent;\n      setIsTransparentColor(transparent);\n\n      \n      if (transparent) {\n        // Handle transparent color\n        setCurrentColor('transparent');\n        setPreviewColor('transparent');\n        setHexInput('');\n        setRgbValues({ r: 0, g: 0, b: 0 });\n        setHsvValues({ h: 0, s: 0, v: 0 });\n        setValueSliderValue(0);\n        setColorWheelPosition({ x: 80, y: 80 });\n      } else {\n        // Handle normal color\n        const color = normalizeHexColor(initialColor);\n        setCurrentColor(color);\n        setPreviewColor(color);\n        setHexInput(color);\n        \n        const rgb = hexToRgb(color);\n        const hsv = hexToHsv(color);\n        \n        if (rgb) setRgbValues(rgb);\n        if (hsv) {\n          setHsvValues(hsv);\n          setValueSliderValue(hsv.v);\n          updateColorWheelPosition(hsv);\n        }\n      }\n      \n      // Mark as initialized after setting all values\n      setTimeout(() => setHasInitialized(true), 0);\n    } else {\n      setHasInitialized(false);\n    }\n  }, [isOpen, initialColor]);\n\n  // Update preview color in store\n  useEffect(() => {\n    updatePreviewColor(previewColor);\n  }, [previewColor, updatePreviewColor]);\n\n  // Auto-focus and select hex input when dialog opens (if not transparent)\n  useEffect(() => {\n    if (isOpen) {\n      // Use rAF to ensure the input is mounted after dialog animation/layout\n      requestAnimationFrame(() => {\n        if (hexInputRef.current && !isTransparentColor) {\n          hexInputRef.current.focus();\n          // Select existing content for quick replacement/paste\n          hexInputRef.current.select();\n        }\n      });\n    }\n  }, [isOpen, isTransparentColor]);\n\n  // Close picker when clicking outside\n  useEffect(() => {\n    const handleClickOutside = (event: MouseEvent) => {\n      if (\n        isOpen &&\n        pickerRef.current &&\n        !pickerRef.current.contains(event.target as Node) &&\n        triggerRef?.current &&\n        !triggerRef.current.contains(event.target as Node)\n      ) {\n        onOpenChange(false);\n      }\n    };\n\n    if (isOpen) {\n      document.addEventListener('mousedown', handleClickOutside);\n      return () => document.removeEventListener('mousedown', handleClickOutside);\n    }\n  }, [isOpen, onOpenChange, triggerRef]);\n\n  // Close picker on escape key\n  useEffect(() => {\n    const handleEscape = (event: KeyboardEvent) => {\n      if (event.key === 'Escape' && isOpen) {\n        onOpenChange(false);\n      }\n    };\n\n    if (isOpen) {\n      document.addEventListener('keydown', handleEscape);\n      return () => document.removeEventListener('keydown', handleEscape);\n    }\n  }, [isOpen, onOpenChange]);\n\n  // Position calculation\n  const getPickerPosition = () => {\n    const pickerWidth = 400;\n    const pickerHeight = 600;\n    \n    // Special handling for gradient panel\n    if (anchorPosition === 'gradient-panel') {\n      // Center the picker vertically in the viewport\n      const viewportHeight = window.innerHeight;\n      const top = Math.max(8, (viewportHeight - pickerHeight) / 2 + window.scrollY);\n      \n      // Position to the left of the gradient panel (which is 320px wide and on the right side)\n      const gradientPanelWidth = 320;\n      const left = window.innerWidth - gradientPanelWidth - pickerWidth - 16; // 16px gap\n      \n      return {\n        top,\n        left: Math.max(8, left), // Ensure it doesn't go off-screen\n        right: 'auto'\n      };\n    }\n    \n    // Special handling for import media panel\n    if (anchorPosition === 'import-media-panel') {\n      // Center the picker vertically in the viewport\n      const viewportHeight = window.innerHeight;\n      const top = Math.max(8, (viewportHeight - pickerHeight) / 2 + window.scrollY);\n      \n      // Position to the left of the import media panel (which is 320px wide and on the right side)\n      // Align with the left edge of the import media panel\n      const importPanelWidth = 320; // 80*4 = 320px as seen in the MediaImportPanel\n      const left = window.innerWidth - importPanelWidth - pickerWidth - 8; // 8px gap for alignment with panel edge\n      \n      return {\n        top,\n        left: Math.max(8, left), // Ensure it doesn't go off-screen\n        right: 'auto'\n      };\n    }\n    \n    // For other anchor positions, we need a triggerRef\n    if (!triggerRef?.current) return { top: 100, left: 100 };\n    \n    const triggerRect = triggerRef.current.getBoundingClientRect();\n    \n    // Center the picker vertically in the viewport for other cases\n    const viewportHeight = window.innerHeight;\n    const top = Math.max(8, (viewportHeight - pickerHeight) / 2 + window.scrollY);\n    \n    if (anchorPosition === 'left-slide') {\n      // Slide out from the left side of the trigger, but center vertically\n      let right = window.innerWidth - triggerRect.left + 8; // 8px gap from trigger\n      \n      return {\n        top,\n        right,\n        left: 'auto'\n      };\n    } else if (anchorPosition === 'right-slide') {\n      // Slide out from the right side of the trigger, but center vertically\n      let left = triggerRect.right + 8; // 8px gap from trigger\n      \n      // Ensure picker doesn't go off-screen horizontally\n      if (left + pickerWidth > window.innerWidth) {\n        left = window.innerWidth - pickerWidth - 8;\n      }\n      \n      return {\n        top,\n        left,\n        right: 'auto'\n      };\n    } else if (anchorPosition === 'bottom-left') {\n      // Position below the trigger element, aligned to the left edge\n      let top = triggerRect.bottom + 8; // 8px gap below trigger\n      let left = triggerRect.left;\n      \n      // Ensure picker doesn't go off-screen horizontally\n      if (left + pickerWidth > window.innerWidth) {\n        left = window.innerWidth - pickerWidth - 8;\n      }\n      \n      // Check if it would go off bottom of screen\n      if (top + pickerHeight > window.innerHeight + window.scrollY) {\n        // Try positioning above the trigger instead\n        const topAbove = triggerRect.top + window.scrollY - pickerHeight - 8;\n        \n        // If positioning above would go off the top, use smart positioning\n        if (topAbove < window.scrollY + 8) {\n          // Position it in the viewport with available space\n          const maxTop = Math.max(window.scrollY + 8, triggerRect.bottom + window.scrollY + 8);\n          const maxBottom = window.scrollY + window.innerHeight - 8;\n          \n          // Use the position that gives us the most space\n          if (triggerRect.top > window.innerHeight / 2) {\n            // More space above, position above the trigger\n            top = Math.max(window.scrollY + 8, triggerRect.top + window.scrollY - pickerHeight - 8);\n          } else {\n            // More space below, position below the trigger but constrained\n            top = Math.min(maxTop, maxBottom - pickerHeight);\n          }\n        } else {\n          top = topAbove;\n        }\n      }\n      \n      return {\n        top,\n        left,\n        right: 'auto'\n      };\n    } else if (anchorPosition === 'bottom-right') {\n      // Position below the trigger element, aligned to the right edge\n      let top = triggerRect.bottom + 8; // 8px gap below trigger\n      let left = triggerRect.right - pickerWidth;\n      \n      // Ensure picker doesn't go off-screen horizontally\n      if (left < 8) {\n        left = 8;\n      }\n      \n      // Check if it would go off bottom of screen\n      if (top + pickerHeight > window.innerHeight + window.scrollY) {\n        // Try positioning above the trigger instead\n        const topAbove = triggerRect.top + window.scrollY - pickerHeight - 8;\n        \n        // If positioning above would go off the top, use smart positioning\n        if (topAbove < window.scrollY + 8) {\n          // Position it in the viewport with available space\n          const maxTop = Math.max(window.scrollY + 8, triggerRect.bottom + window.scrollY + 8);\n          const maxBottom = window.scrollY + window.innerHeight - 8;\n          \n          // Use the position that gives us the most space\n          if (triggerRect.top > window.innerHeight / 2) {\n            // More space above, position above the trigger\n            top = Math.max(window.scrollY + 8, triggerRect.top + window.scrollY - pickerHeight - 8);\n          } else {\n            // More space below, position below the trigger but constrained\n            top = Math.min(maxTop, maxBottom - pickerHeight);\n          }\n        } else {\n          top = topAbove;\n        }\n      }\n      \n      return {\n        top,\n        left,\n        right: 'auto'\n      };\n    } else {\n      // Default left-slide behavior with vertical centering\n      return {\n        top,\n        right: window.innerWidth - triggerRect.left + 8,\n        left: 'auto'\n      };\n    }\n  };\n\n  // Trigger real-time updates when color values change\n  useEffect(() => {\n    // Update preview color and trigger real-time callbacks when values change\n    if (hasInitialized && isOpen) {\n      let newColor: string;\n      if (isTransparentColor) {\n        newColor = 'transparent';\n      } else {\n        newColor = hsvToHex(hsvValues);\n      }\n      \n      setPreviewColor(newColor);\n      \n      // Trigger real-time update if callback is provided and color actually changed\n      // Using ref to track changes prevents circular dependencies in useEffect deps\n      // while ensuring we only fire callbacks when the color genuinely changes\n      if (onColorChange && newColor !== previousColorRef.current) {\n        previousColorRef.current = newColor;\n        const timeoutId = setTimeout(() => {\n          onColorChange(newColor);\n        }, 50); // 50ms debounce to prevent excessive calls during rapid changes\n        \n        return () => clearTimeout(timeoutId);\n      }\n    }\n  }, [hsvValues, isTransparentColor, hasInitialized, isOpen, onColorChange]);\n\n  // Update color wheel position based on HSV values\n  const updateColorWheelPosition = useCallback((hsv: HSVColor) => {\n    const centerX = 80; // Half of 160px wheel\n    const centerY = 80;\n    const maxRadius = 72; // Slightly less than 80 to stay within bounds\n    const angle = (hsv.h * Math.PI) / 180;\n    const radius = (hsv.s / 100) * maxRadius;\n    // Round to mitigate sub-pixel oscillation that can cause jitter when React recalculates layout\n    const x = +(centerX + radius * Math.cos(angle)).toFixed(2);\n    const y = +(centerY + radius * Math.sin(angle)).toFixed(2);\n    setColorWheelPosition({ x, y });\n  }, []);\n\n  // Color update handlers\n  const updateFromHex = useCallback((hex: string) => {\n    const normalizedHex = normalizeHexColor(hex);\n    const rgb = hexToRgb(normalizedHex);\n    const hsv = hexToHsv(normalizedHex);\n    \n    if (rgb && hsv) {\n      setPreviewColor(normalizedHex);\n      setHexInput(normalizedHex);\n      setRgbValues(rgb);\n      setHsvValues(hsv);\n      setValueSliderValue(hsv.v);\n      updateColorWheelPosition(hsv);\n      setIsTransparentColor(false);\n      \n      // Trigger real-time update\n      if (onColorChange) {\n        onColorChange(normalizedHex);\n      }\n    }\n  }, [updateColorWheelPosition, onColorChange]);\n\n  const updateFromRgb = useCallback((rgb: RGBColor) => {\n    const hex = rgbToHex(rgb);\n    const hsv = rgbToHsv(rgb);\n    \n    setPreviewColor(hex);\n    setHexInput(hex);\n    setHsvValues(hsv);\n    setValueSliderValue(hsv.v);\n    updateColorWheelPosition(hsv);\n    setIsTransparentColor(false);\n    \n    // Trigger real-time update\n    if (onColorChange) {\n      onColorChange(hex);\n    }\n  }, [updateColorWheelPosition, onColorChange]);\n\n  const updateFromHsv = useCallback((hsv: HSVColor, skipWheelPosition: boolean = false) => {\n    const rgb = hsvToRgb(hsv);\n    const hex = hsvToHex(hsv);\n    setPreviewColor(hex);\n    setHexInput(hex);\n    setRgbValues(rgb);\n    setValueSliderValue(hsv.v);\n    if (!skipWheelPosition) {\n      updateColorWheelPosition(hsv);\n    }\n    setIsTransparentColor(false);\n    \n    // Trigger real-time update\n    if (onColorChange) {\n      onColorChange(hex);\n    }\n  }, [updateColorWheelPosition, onColorChange]);\n\n  // Handle hex input change with live sanitization\n  const handleHexChange = (value: string) => {\n    // Remove any non-hex characters and convert to uppercase\n    let sanitized = value.replace(/[^#0-9A-Fa-f]/g, '').toUpperCase();\n    \n    // Ensure it starts with # and limit length\n    if (!sanitized.startsWith('#')) {\n      sanitized = '#' + sanitized.replace(/#/g, ''); // Remove any # that's not at the start\n    }\n    \n    // Limit to 7 characters max (#FFFFFF)\n    if (sanitized.length > 7) {\n      sanitized = sanitized.slice(0, 7);\n    }\n    \n    setHexInput(sanitized);\n    \n    // Only update color if we have a valid 6-digit hex\n    if (/^#[0-9A-F]{6}$/.test(sanitized)) {\n      updateFromHex(sanitized);\n    }\n  };\n\n  // Handle RGB slider changes\n  const handleRgbChange = (component: 'r' | 'g' | 'b', value: number) => {\n    if (isTransparentColor) {\n      // Wake from transparent mode\n      setIsTransparentColor(false);\n    }\n    const newRgb = { ...rgbValues, [component]: Math.round(value) };\n    setRgbValues(newRgb);\n    updateFromRgb(newRgb);\n  };\n\n  // Handle RGB input changes\n  const handleRgbInputChange = (component: 'r' | 'g' | 'b', value: string) => {\n    const numValue = parseInt(value);\n    if (!isNaN(numValue) && numValue >= 0 && numValue <= 255) {\n      handleRgbChange(component, numValue);\n    }\n  };\n\n  // Handle HSV slider changes\n  const handleHsvChange = (component: 'h' | 's' | 'v', value: number) => {\n    if (isTransparentColor) {\n      setIsTransparentColor(false);\n    }\n    const roundedValue = component === 'h' ? Math.round(value * 100) / 100 : Math.round(value);\n    const newHsv = { ...hsvValues, [component]: roundedValue };\n    setHsvValues(newHsv);\n    updateFromHsv(newHsv, component === 'v');\n  };\n\n  // Handle HSV input changes\n  const handleHsvInputChange = (component: 'h' | 's' | 'v', value: string) => {\n    const numValue = parseFloat(value);\n    const maxValues = { h: 360, s: 100, v: 100 };\n    if (!isNaN(numValue) && numValue >= 0 && numValue <= maxValues[component]) {\n      handleHsvChange(component, numValue);\n    }\n  };\n\n  // Handle value slider change (affects the entire color wheel brightness)\n  const handleValueSliderChange = (value: number) => {\n    if (isTransparentColor) {\n      setIsTransparentColor(false);\n    }\n    const newHsv = { ...hsvValues, v: value };\n    setHsvValues(newHsv);\n    setValueSliderValue(value);\n    updateFromHsv(newHsv, true);\n  };\n\n  // Color wheel interaction with drag support\n  const handleColorWheelInteraction = (event: React.MouseEvent<HTMLDivElement> | MouseEvent) => {\n    if (!colorWheelRef.current) return;\n    if (isTransparentColor) {\n      setIsTransparentColor(false);\n    }\n    \n    const rect = colorWheelRef.current.getBoundingClientRect();\n    const centerX = rect.width / 2;\n    const centerY = rect.height / 2;\n    const x = (event.clientX - rect.left) - centerX;\n    const y = (event.clientY - rect.top) - centerY;\n    \n    const distance = Math.sqrt(x * x + y * y);\n    const maxDistance = Math.min(centerX, centerY) - 10;\n    \n    // Always calculate the angle for hue\n    let angle = Math.atan2(y, x);\n    angle = (angle * 180 / Math.PI + 360) % 360; // Convert to 0-360 degrees\n    \n    // Calculate saturation based on distance, but clamp to maximum when outside\n    let saturation: number;\n    let displayX: number;\n    let displayY: number;\n    \n    if (distance <= maxDistance) {\n      // Inside circle - normal behavior\n      saturation = (distance / maxDistance) * 100;\n      displayX = centerX + x;\n      displayY = centerY + y;\n    } else {\n      // Outside circle - snap to edge with full saturation\n      saturation = 100;\n      \n      // Calculate position on the edge of the circle\n      const edgeX = Math.cos(angle * Math.PI / 180) * maxDistance;\n      const edgeY = Math.sin(angle * Math.PI / 180) * maxDistance;\n      displayX = centerX + edgeX;\n      displayY = centerY + edgeY;\n    }\n    \n    const newHsv = { ...hsvValues, h: angle, s: saturation };\n    setHsvValues(newHsv);\n    updateFromHsv(newHsv);\n    \n    // Update position for visual feedback\n    setColorWheelPosition({ x: displayX, y: displayY });\n  };\n\n  const handleColorWheelMouseDown = (event: React.MouseEvent<HTMLDivElement>) => {\n    setIsDragging(true);\n    handleColorWheelInteraction(event);\n  };\n\n  // Mouse move handler for dragging\n  useEffect(() => {\n    if (!isDragging) return;\n\n    const handleMouseMove = (event: MouseEvent) => {\n      handleColorWheelInteraction(event);\n    };\n\n    const handleMouseUp = () => {\n      setIsDragging(false);\n    };\n\n    document.addEventListener('mousemove', handleMouseMove);\n    document.addEventListener('mouseup', handleMouseUp);\n\n    return () => {\n      document.removeEventListener('mousemove', handleMouseMove);\n      document.removeEventListener('mouseup', handleMouseUp);\n    };\n  }, [isDragging]);\n\n  // Eyedropper functionality\n  const handleEyedropper = async () => {\n    if ('EyeDropper' in window) {\n      try {\n        // @ts-ignore - EyeDropper API is experimental\n        const eyeDropper = new window.EyeDropper();\n        const result = await eyeDropper.open();\n        updateFromHex(result.sRGBHex);\n      } catch (error) {\n        // Eyedropper cancelled or not supported - silently handle\n      }\n    }\n  };\n\n  // Recent color selection\n  const handleRecentColorSelect = (color: string) => {\n    updateFromHex(color);\n  };\n\n  // Reset to current color\n  const handleReset = () => {\n    if (currentColor === 'transparent' || currentColor === ANSI_COLORS.transparent) {\n      setIsTransparentColor(true);\n      setPreviewColor('transparent');\n      setHexInput('');\n      setRgbValues({ r: 0, g: 0, b: 0 });\n      setHsvValues({ h: 0, s: 0, v: 0 });\n      setValueSliderValue(0);\n      setColorWheelPosition({ x: 80, y: 80 });\n    } else {\n      updateFromHex(currentColor);\n    }\n  };\n\n  // Confirm color selection\n  const handleConfirm = () => {\n    addRecentColor(previewColor);\n    onColorSelect(previewColor);\n    onOpenChange(false);\n  };\n\n  // Cancel selection\n  const handleCancel = () => {\n    if (onCancel) {\n      onCancel();\n    } else {\n      onOpenChange(false);\n    }\n  };\n\n  // Set preview state to transparent (without committing until confirm)\n  const handleSetTransparent = () => {\n    setIsTransparentColor(true);\n    setPreviewColor('transparent');\n    setHexInput('');\n    setRgbValues({ r: 0, g: 0, b: 0 });\n    setHsvValues({ h: 0, s: 0, v: 0 });\n    setValueSliderValue(0);\n    setColorWheelPosition({ x: 80, y: 80 });\n  };\n  \n  // Handler for dragging the dialog\n  const handleDrag = useCallback((deltaX: number, deltaY: number) => {\n    // Add the drag delta to the stored offset from when drag started\n    setPositionOffset({\n      x: dragStartOffsetRef.current.x + deltaX,\n      y: dragStartOffsetRef.current.y + deltaY\n    });\n  }, []);\n  \n  // Track dialog drag state for animation control\n  const handleDragStart = useCallback(() => {\n    setIsDraggingDialog(true);\n    setHasBeenDragged(true);\n    // Store the current offset when drag starts\n    dragStartOffsetRef.current = { ...positionOffset };\n  }, [positionOffset]);\n  \n  const handleDragEnd = useCallback(() => {\n    setIsDraggingDialog(false);\n    // Update the ref with the final position\n    dragStartOffsetRef.current = { ...positionOffset };\n  }, [positionOffset]);\n\n  // Create canvas-based HSV color wheel\n  const canvasRef = useRef<HTMLCanvasElement>(null);\n  \n  // Generate base HSV color wheel once (at full brightness)\n  const renderingRef = useRef(false);\n  const baseRendered = useRef(false);\n  // Cache original wheel pixel data at V=100 for brightness adjustments\n  const baseImageDataRef = useRef<ImageData | null>(null);\n  const lastAppliedValueRef = useRef<number | null>(null);\n  const dprRef = useRef<number>(typeof window !== 'undefined' ? window.devicePixelRatio || 1 : 1);\n  \n  useEffect(() => {\n    if (!isOpen || !hasInitialized || baseRendered.current) return;\n    \n    const canvas = canvasRef.current;\n    if (!canvas || renderingRef.current) return;\n    \n    renderingRef.current = true;\n    \n    const ctx = canvas.getContext('2d');\n    if (!ctx) {\n      renderingRef.current = false;\n      return;\n    }\n      \n      const logicalSize = 160; // CSS pixels\n      const dpr = dprRef.current;\n      const size = Math.round(logicalSize * dpr); // backing store size\n      const center = size / 2;\n      const radius = center - 4 * dpr; // scale border inset with DPR\n      \n      // Set dimensions only once to prevent layout recalculation\n      if (canvas.width !== size || canvas.height !== size) {\n        canvas.style.width = `${logicalSize}px`;\n        canvas.style.height = `${logicalSize}px`;\n        canvas.width = size;\n        canvas.height = size;\n      }\n      \n      // Enable canvas smoothing\n      ctx.imageSmoothingEnabled = true;\n      ctx.imageSmoothingQuality = 'high';\n      ctx.setTransform(1,0,0,1,0,0); // reset\n      ctx.scale(dpr, dpr); // scale drawing operations to logical pixels\n      \n      const imageData = ctx.createImageData(size, size); // we draw in backing pixel space manually\n      const data = imageData.data;\n      \n      for (let y = 0; y < size; y++) {\n        for (let x = 0; x < size; x++) {\n          const dx = x - center;\n          const dy = y - center;\n          const distance = Math.sqrt(dx * dx + dy * dy);\n          \n          if (distance <= radius) {\n            // Calculate hue from angle\n            let angle = Math.atan2(dy, dx);\n            angle = (angle * 180 / Math.PI + 360) % 360;\n            \n            // Calculate saturation from distance\n            const saturation = Math.min(100, (distance / radius) * 100);\n            \n          // Use full brightness for base canvas\n          const rgb = hsvToRgb({ h: angle, s: saturation, v: 100 });            // Anti-aliasing for smooth edges\n            let alpha = 255;\n            if (distance > radius - 1) {\n              alpha = Math.round(255 * (radius - distance));\n            }\n            \n            const index = (y * size + x) * 4;\n            data[index] = rgb.r;\n            data[index + 1] = rgb.g;\n            data[index + 2] = rgb.b;\n            data[index + 3] = alpha;\n          } else {\n            // Outside circle - transparent\n            const index = (y * size + x) * 4;\n            data[index + 3] = 0;\n          }\n        }\n      }\n      \n    ctx.putImageData(imageData, 0, 0);\n    baseImageDataRef.current = imageData; // store base pixels\n    baseRendered.current = true;\n    lastAppliedValueRef.current = 100; // initial brightness\n    renderingRef.current = false;\n  }, [isOpen, hasInitialized]);\n  \n  // Reset base canvas when dialog closes\n  useEffect(() => {\n    if (!isOpen) {\n      baseRendered.current = false;\n    }\n  }, [isOpen]);\n\n  // Re-render brightness when V changes without shifting underlying wheel pixels\n  useEffect(() => {\n    if (!isOpen || !baseRendered.current) return;\n    if (lastAppliedValueRef.current === valueSliderValue) return; // no change\n    const canvas = canvasRef.current;\n    const base = baseImageDataRef.current;\n    if (!canvas || !base) return;\n    const ctx = canvas.getContext('2d');\n    if (!ctx) return;\n    // Create a copy to avoid mutating the base reference\n    const copy = ctx.createImageData(base.width, base.height);\n    const src = base.data;\n    const dst = copy.data;\n    const factor = valueSliderValue / 100; // linear scale\n    for (let i = 0; i < src.length; i += 4) {\n      dst[i] = Math.round(src[i] * factor);\n      dst[i + 1] = Math.round(src[i + 1] * factor);\n      dst[i + 2] = Math.round(src[i + 2] * factor);\n      dst[i + 3] = src[i + 3]; // preserve alpha\n    }\n    ctx.putImageData(copy, 0, 0);\n    lastAppliedValueRef.current = valueSliderValue;\n  }, [valueSliderValue, isOpen]);\n\n  if (!isOpen) return null;\n\n  const position = getPickerPosition();\n\n  return createPortal(\n    <div\n      ref={pickerRef}\n      className={`fixed z-[99999] ${\n        !hasBeenDragged ? `animate-in duration-200 ${\n          anchorPosition === 'right-slide' ? 'slide-in-from-left-2 fade-in-0' : \n          anchorPosition === 'gradient-panel' ? 'slide-in-from-right-2 fade-in-0' : 'slide-in-from-right-2 fade-in-0'\n        }` : ''\n      }`}\n      style={{\n        top: position.top + positionOffset.y,\n        right: position.right !== 'auto' && typeof position.right === 'number' ? position.right - positionOffset.x : undefined,\n        left: position.left !== 'auto' && typeof position.left === 'number' ? position.left + positionOffset.x : undefined,\n        maxWidth: '400px',\n        width: '400px',\n        transition: isDraggingDialog ? 'none' : undefined\n      }}\n      onMouseDown={(e) => e.stopPropagation()}\n      onClick={(e) => e.stopPropagation()}\n    >\n      <Card className=\"border border-border/50 shadow-lg\">\n        <DraggableDialogBar \n          title={title} \n          onDrag={handleDrag}\n          onDragStart={handleDragStart}\n          onDragEnd={handleDragEnd}\n          onClose={handleCancel}\n        />\n        <CardContent className=\"space-y-3 pt-3\">{/* Color Preview */}\n          <div className=\"flex items-center gap-2\">\n            <div className=\"flex-1\">\n              <div className=\"flex h-8 border border-border rounded overflow-hidden\">\n                {/* Current Color */}\n                <div className=\"flex-1 relative\">\n                  {(currentColor === 'transparent' || currentColor === ANSI_COLORS.transparent) ? (\n                    <div className=\"w-full h-full relative bg-white\">\n                      <div \n                        className=\"absolute inset-0\"\n                        style={{\n                          backgroundImage: 'linear-gradient(45deg, #ccc 25%, transparent 25%), linear-gradient(-45deg, #ccc 25%, transparent 25%), linear-gradient(45deg, transparent 75%, #ccc 75%), linear-gradient(-45deg, transparent 75%, #ccc 75%)',\n                          backgroundSize: '8px 8px',\n                          backgroundPosition: '0 0, 0 4px, 4px -4px, -4px 0px'\n                        }}\n                      />\n                      <svg className=\"absolute inset-0 w-full h-full\" viewBox=\"0 0 48 48\">\n                        <line x1=\"4\" y1=\"44\" x2=\"44\" y2=\"4\" stroke=\"#dc2626\" strokeWidth=\"2\" strokeLinecap=\"round\" />\n                      </svg>\n                    </div>\n                  ) : (\n                    <div \n                      className=\"w-full h-full\"\n                      style={{ backgroundColor: currentColor }}\n                      title=\"Current Color\"\n                    />\n                  )}\n                </div>\n                \n                {/* Preview Color */}\n                <div className=\"flex-1 relative border-l border-border\">\n                  {(previewColor === 'transparent' || isTransparentColor) ? (\n                    <div className=\"w-full h-full relative bg-white\">\n                      <div \n                        className=\"absolute inset-0\"\n                        style={{\n                          backgroundImage: 'linear-gradient(45deg, #ccc 25%, transparent 25%), linear-gradient(-45deg, #ccc 25%, transparent 25%), linear-gradient(45deg, transparent 75%, #ccc 75%), linear-gradient(-45deg, transparent 75%, #ccc 75%)',\n                          backgroundSize: '8px 8px',\n                          backgroundPosition: '0 0, 0 4px, 4px -4px, -4px 0px'\n                        }}\n                      />\n                      <svg className=\"absolute inset-0 w-full h-full\" viewBox=\"0 0 48 48\">\n                        <line x1=\"4\" y1=\"44\" x2=\"44\" y2=\"4\" stroke=\"#dc2626\" strokeWidth=\"2\" strokeLinecap=\"round\" />\n                      </svg>\n                    </div>\n                  ) : (\n                    <div \n                      className=\"w-full h-full\"\n                      style={{ backgroundColor: previewColor }}\n                      title=\"New Color\"\n                    />\n                  )}\n                </div>\n              </div>\n            </div>\n            \n            {/* Eyedropper Button */}\n            {'EyeDropper' in window && (\n              <Button\n                size=\"sm\"\n                variant=\"outline\" \n                onClick={handleEyedropper}\n                className=\"h-8 w-8 p-0\"\n              >\n                <Pipette className=\"h-4 w-4\" />\n              </Button>\n            )}\n          </div>\n\n          {/* Color Wheel and Value Slider */}\n          <div className=\"space-y-1\">\n            <div className=\"flex justify-center items-start gap-4\">\n              {/* Color Wheel */}\n              <div \n                ref={colorWheelRef}\n                className=\"rounded-full border border-border cursor-crosshair relative select-none overflow-hidden\"\n                onMouseDown={handleColorWheelMouseDown}\n                style={{ \n                  width: '160px',\n                  height: '160px',\n                  clipPath: 'circle(50% at 50% 50%)',\n                  borderRadius: '50%',\n                  flexShrink: 0,\n                  contain: 'layout style paint',\n                  willChange: 'contents',\n                  transform: 'translateZ(0)' // Force hardware acceleration\n                }}\n              >\n                <canvas\n                  ref={canvasRef}\n                  width={160}\n                  height={160}\n                  style={{ \n                    width: '160px',\n                    height: '160px',\n                    borderRadius: '50%',\n                    position: 'absolute',\n                    top: 0,\n                    left: 0,\n                    display: 'block',\n                    backfaceVisibility: 'hidden'\n                  }}\n                />\n                <div \n                  className=\"absolute w-3 h-3 bg-white border-2 border-black rounded-full transform -translate-x-1.5 -translate-y-1.5 pointer-events-none\"\n                  style={{\n                    left: Math.round(colorWheelPosition.x),\n                    top: Math.round(colorWheelPosition.y)\n                  }}\n                />\n              </div>\n              \n              {/* Value Slider - Vertical */}\n              <div className=\"flex flex-col items-center gap-2 ml-4 select-none w-12 flex-shrink-0\">\n                <Label className=\"text-xs font-medium select-none\">V</Label>\n                <div className=\"relative h-32 w-4 flex items-center justify-center select-none\">\n                  {/* Custom vertical slider track */}\n                  <div className=\"absolute h-32 w-1 bg-muted rounded-full\"></div>\n                  {/* Slider handle */}\n                  <div \n                    className=\"absolute w-3 h-3 bg-primary rounded-full cursor-pointer shadow-sm border border-background z-10\"\n                    style={{\n                      top: `${((100 - valueSliderValue) / 100) * 128 - 6}px`,\n                      left: '50%',\n                      transform: 'translateX(-50%)'\n                    }}\n                    onMouseDown={(e) => {\n                      // Wake from transparent mode if needed\n                      if (isTransparentColor) {\n                        setIsTransparentColor(false);\n                      }\n                      e.preventDefault(); // Prevent text selection\n                      e.stopPropagation(); // Prevent track click handler\n                      \n                      const startY = e.clientY;\n                      const startValue = valueSliderValue;\n                      \n                      const handleMouseMove = (moveEvent: MouseEvent) => {\n                        const deltaY = moveEvent.clientY - startY;\n                        const newValue = Math.max(0, Math.min(100, startValue - (deltaY / 128) * 100));\n                        handleValueSliderChange(newValue);\n                      };\n                      \n                      const handleMouseUp = () => {\n                        document.removeEventListener('mousemove', handleMouseMove);\n                        document.removeEventListener('mouseup', handleMouseUp);\n                      };\n                      \n                      document.addEventListener('mousemove', handleMouseMove);\n                      document.addEventListener('mouseup', handleMouseUp);\n                    }}\n                  />\n                  {/* Click on track to set value */}\n                  <div \n                    className=\"absolute inset-0 cursor-pointer select-none\"\n                    onMouseDown={(e) => {\n                      if (isTransparentColor) {\n                        setIsTransparentColor(false);\n                      }\n                      e.preventDefault(); // Prevent text selection\n                      \n                      const rect = e.currentTarget.getBoundingClientRect();\n                      const y = e.clientY - rect.top;\n                      const newValue = Math.max(0, Math.min(100, 100 - (y / rect.height) * 100));\n                      handleValueSliderChange(newValue);\n                      \n                      // Start dragging from track click\n                      const handleMouseMove = (moveEvent: MouseEvent) => {\n                        const moveY = moveEvent.clientY - rect.top;\n                        const moveValue = Math.max(0, Math.min(100, 100 - (moveY / rect.height) * 100));\n                        handleValueSliderChange(moveValue);\n                      };\n                      \n                      const handleMouseUp = () => {\n                        document.removeEventListener('mousemove', handleMouseMove);\n                        document.removeEventListener('mouseup', handleMouseUp);\n                      };\n                      \n                      document.addEventListener('mousemove', handleMouseMove);\n                      document.addEventListener('mouseup', handleMouseUp);\n                    }}\n                  />\n                </div>\n                <span \n                  className=\"text-xs text-muted-foreground inline-block text-center\"\n                  style={{ width: '100%', fontVariantNumeric: 'tabular-nums' }}\n                >\n                  {isTransparentColor ? '-' : `${Math.round(valueSliderValue)}%`}\n                </span>\n              </div>\n            </div>\n          </div>\n\n          <Separator />\n\n          {/* HSV Controls */}\n          <div className=\"space-y-2\">\n            {/* Hue */}\n            <div className=\"flex items-center gap-1.5\">\n                <Label className=\"w-3 text-xs\">H</Label>\n              <Slider\n                value={hsvValues.h}\n                onValueChange={(value) => handleHsvChange('h', value)}\n                max={360}\n                step={0.1}\n                className=\"flex-1\"\n              />\n              <Input\n                value={hsvValues.h.toFixed(2)}\n                onChange={(e) => handleHsvInputChange('h', e.target.value)}\n                className=\"w-16 h-7 text-xs select-text\"\n              />\n              <span className=\"text-xs text-muted-foreground w-2\">°</span>\n            </div>\n            \n            {/* Saturation */}\n            <div className=\"flex items-center gap-1.5\">\n              <Label className=\"w-3 text-xs\">S</Label>\n              <Slider\n                value={hsvValues.s}\n                onValueChange={(value) => handleHsvChange('s', value)}\n                max={100}\n                step={1}\n                className=\"flex-1\"\n              />\n              <Input\n                value={Math.round(hsvValues.s).toString()}\n                onChange={(e) => handleHsvInputChange('s', e.target.value)}\n                className=\"w-16 h-7 text-xs\"\n              />\n              <span className=\"text-xs text-muted-foreground w-2\">%</span>\n            </div>\n            \n            {/* Value */}\n            <div className=\"flex items-center gap-1.5\">\n              <Label className=\"w-3 text-xs\">V</Label>\n              <Slider\n                value={hsvValues.v}\n                onValueChange={(value) => handleHsvChange('v', value)}\n                max={100}\n                step={1}\n                className=\"flex-1\"\n              />\n              <Input\n                value={Math.round(hsvValues.v).toString()}\n                onChange={(e) => handleHsvInputChange('v', e.target.value)}\n                className=\"w-16 h-7 text-xs\"\n              />\n              <span className=\"text-xs text-muted-foreground w-2\">%</span>\n            </div>\n          </div>\n\n          <Separator />\n\n          {/* RGB Controls */}\n          <div className=\"space-y-2\">\n            {/* Red */}\n            <div className=\"flex items-center gap-1.5\">\n              <Label className=\"w-3 text-xs\">R</Label>\n              <Slider\n                value={rgbValues.r}\n                onValueChange={(value) => handleRgbChange('r', value)}\n                max={255}\n                step={1}\n                className=\"flex-1\"\n              />\n              <Input\n                value={rgbValues.r.toString()}\n                onChange={(e) => handleRgbInputChange('r', e.target.value)}\n                className=\"w-14 h-7 text-xs\"\n              />\n            </div>\n            \n            {/* Green */}\n            <div className=\"flex items-center gap-1.5\">\n              <Label className=\"w-3 text-xs\">G</Label>\n              <Slider\n                value={rgbValues.g}\n                onValueChange={(value) => handleRgbChange('g', value)}\n                max={255}\n                step={1}\n                className=\"flex-1\"\n              />\n              <Input\n                value={rgbValues.g.toString()}\n                onChange={(e) => handleRgbInputChange('g', e.target.value)}\n                className=\"w-14 h-7 text-xs\"\n              />\n            </div>\n            \n            {/* Blue */}\n            <div className=\"flex items-center gap-1.5\">\n              <Label className=\"w-3 text-xs\">B</Label>\n              <Slider\n                value={rgbValues.b}\n                onValueChange={(value) => handleRgbChange('b', value)}\n                max={255}\n                step={1}\n                className=\"flex-1\"\n              />\n              <Input\n                value={rgbValues.b.toString()}\n                onChange={(e) => handleRgbInputChange('b', e.target.value)}\n                className=\"w-14 h-7 text-xs\"\n              />\n            </div>\n          </div>\n\n          <Separator />\n\n          {/* Hex Input (and optional Transparent Button) */}\n          <div className={`flex items-center ${showTransparentOption ? 'gap-2' : ''}`}>\n            <Input\n              ref={hexInputRef}\n              value={hexInput}\n              onChange={(e) => {\n                if (isTransparentColor) {\n                  setIsTransparentColor(false);\n                }\n                handleHexChange(e.target.value);\n              }}\n              placeholder={isTransparentColor ? 'Transparent' : '#000000'}\n              className={`font-mono h-7 text-xs ${showTransparentOption ? 'flex-1' : 'w-full'}`}\n            />\n            {showTransparentOption && (\n              <Button\n                type=\"button\"\n                variant=\"outline\"\n                size=\"sm\"\n                onClick={handleSetTransparent}\n                title=\"Set Transparent\"\n                aria-label=\"Set Transparent\"\n                className={`h-7 w-7 p-0 overflow-hidden ${isTransparentColor ? 'ring-2 ring-primary ring-offset-1' : ''}`}\n              >\n                <div className=\"w-full h-full relative bg-white\">\n                  <div\n                    className=\"absolute inset-0\"\n                    style={{\n                      backgroundImage: 'linear-gradient(45deg, #ccc 25%, transparent 25%), linear-gradient(-45deg, #ccc 25%, transparent 25%), linear-gradient(45deg, transparent 75%, #ccc 75%), linear-gradient(-45deg, transparent 75%, #ccc 75%)',\n                      backgroundSize: '8px 8px',\n                      backgroundPosition: '0 0, 0 4px, 4px -4px, -4px 0px'\n                    }}\n                  />\n                  <svg className=\"absolute inset-0 w-full h-full\" viewBox=\"0 0 48 48\">\n                    <line x1=\"4\" y1=\"44\" x2=\"44\" y2=\"4\" stroke=\"#dc2626\" strokeWidth=\"2\" strokeLinecap=\"round\" />\n                  </svg>\n                </div>\n              </Button>\n            )}\n          </div>\n\n          {/* Recent Colors */}\n          {recentColors.length > 0 && (\n            <div className=\"space-y-1\">\n              <Label className=\"text-sm font-medium\">Recent Colors</Label>\n              <div className=\"flex gap-1 flex-wrap\">\n                {recentColors.slice(0, 10).map((color, index) => (\n                  <button\n                    key={index}\n                    className=\"w-5 h-5 rounded border border-border hover:scale-110 transition-transform\"\n                    style={{ backgroundColor: color }}\n                    onClick={() => handleRecentColorSelect(color)}\n                    title={color}\n                  />\n                ))}\n              </div>\n            </div>\n          )}\n\n        {/* Dialog Footer */} \n        <div className=\"flex justify-between pt-3\">\n          <Button\n            variant=\"outline\"\n            onClick={handleReset}\n            className=\"gap-2\"\n          >\n            <RotateCcw className=\"h-4 w-4\" />\n            Reset\n          </Button>\n          \n          <div className=\"flex gap-2\">\n            <Button\n              variant=\"outline\"\n              onClick={handleCancel}\n              className=\"gap-2\"\n            >\n              <X className=\"h-4 w-4\" />\n              Cancel\n            </Button>\n            \n            <Button\n              onClick={handleConfirm}\n              className=\"gap-2\"\n            >\n              <Check className=\"h-4 w-4\" />\n              OK\n            </Button>\n          </div>\n        </div>\n        </CardContent>\n      </Card>\n    </div>,\n    document.body\n  );\n};\n","usedDeprecatedRules":[]},{"filePath":"/Users/cameronfoxly/GitHubRepos/Ascii-Motion/src/components/features/ColorPickerOverlay_new.tsx","messages":[{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useEffect has a missing dependency: 'updateColorWheelPosition'. Either include it or remove the dependency array.","line":90,"column":6,"nodeType":"ArrayExpression","endLine":90,"endColumn":28,"suggestions":[{"desc":"Update the dependencies array to be: [isOpen, initialColor, updateColorWheelPosition]","fix":{"range":[3358,3380],"text":"[isOpen, initialColor, updateColorWheelPosition]"}}]},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useEffect has a missing dependency: 'handleColorWheelInteraction'. Either include it or remove the dependency array.","line":254,"column":6,"nodeType":"ArrayExpression","endLine":254,"endColumn":18,"suggestions":[{"desc":"Update the dependencies array to be: [handleColorWheelInteraction, isDragging]","fix":{"range":[8582,8594],"text":"[handleColorWheelInteraction, isDragging]"}}]},{"ruleId":"@typescript-eslint/ban-ts-comment","severity":2,"message":"Use \"@ts-expect-error\" instead of \"@ts-ignore\", as \"@ts-ignore\" will do nothing if the following line is error-free.","line":260,"column":9,"nodeType":"Line","messageId":"tsIgnoreInsteadOfExpectError","endLine":260,"endColumn":55,"suggestions":[{"messageId":"replaceTsIgnoreWithTsExpectError","fix":{"range":[8723,8769],"text":"// @ts-expect-error - EyeDropper API is experimental"},"desc":"Replace \"@ts-ignore\" with \"@ts-expect-error\"."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'error' is defined but never used.","line":264,"column":16,"nodeType":null,"messageId":"unusedVar","endLine":264,"endColumn":21},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":427,"column":56,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":427,"endColumn":59,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[15646,15649],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[15646,15649],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// Advanced color picker overlay with improved HSV/RGB/HEX controls and interactive color wheel\n\nimport React, { useState, useCallback, useEffect, useRef } from 'react';\nimport { Dialog, DialogContent, DialogHeader, DialogTitle } from '@/components/ui/dialog';\nimport { Button } from '@/components/ui/button';\nimport { Input } from '@/components/ui/input';\nimport { Slider } from '@/components/ui/slider';\nimport { Label } from '@/components/ui/label';\nimport { Separator } from '@/components/ui/separator';\nimport { Pipette, RotateCcw, Check, X } from 'lucide-react';\nimport { usePaletteStore } from '../../stores/paletteStore';\nimport type { HSVColor, RGBColor } from '../../types/palette';\nimport { \n  hexToRgb, \n  rgbToHex, \n  hexToHsv, \n  hsvToHex, \n  hsvToRgb, \n  rgbToHsv,\n  normalizeHexColor\n} from '../../utils/colorConversion';\nimport { ANSI_COLORS } from '../../constants/colors';\n\ninterface ColorPickerOverlayProps {\n  isOpen: boolean;\n  onOpenChange: (open: boolean) => void;\n  onColorSelect: (color: string) => void;\n  initialColor?: string;\n  title?: string;\n}\n\nexport const ColorPickerOverlay: React.FC<ColorPickerOverlayProps> = ({\n  isOpen,\n  onOpenChange,\n  onColorSelect,\n  initialColor = '#000000',\n  title = 'Color Picker'\n}) => {\n  const { updatePreviewColor, addRecentColor, recentColors } = usePaletteStore();\n  \n  // Check if initial color is transparent\n  const isTransparent = initialColor === 'transparent' || initialColor === ANSI_COLORS.transparent;\n  \n  // Color state in different formats\n  const [currentColor, setCurrentColor] = useState(initialColor);\n  const [previewColor, setPreviewColor] = useState(isTransparent ? 'transparent' : initialColor);\n  const [hexInput, setHexInput] = useState(isTransparent ? '' : initialColor);\n  const [rgbValues, setRgbValues] = useState<RGBColor>({ r: 0, g: 0, b: 0 });\n  const [hsvValues, setHsvValues] = useState<HSVColor>({ h: 0, s: 0, v: 0 });\n  const [colorWheelPosition, setColorWheelPosition] = useState({ x: 64, y: 64 }); // Center of 128px wheel\n  const [valueSliderValue, setValueSliderValue] = useState(100);\n  const [isDragging, setIsDragging] = useState(false);\n  const [isTransparentColor, setIsTransparentColor] = useState(isTransparent);\n  \n  const colorWheelRef = useRef<HTMLDivElement>(null);\n\n  // Initialize color values when dialog opens or initial color changes\n  useEffect(() => {\n    if (isOpen) {\n      const transparent = initialColor === 'transparent' || initialColor === ANSI_COLORS.transparent;\n      setIsTransparentColor(transparent);\n      \n      if (transparent) {\n        // Handle transparent color\n        setCurrentColor('transparent');\n        setPreviewColor('transparent');\n        setHexInput('');\n        setRgbValues({ r: 0, g: 0, b: 0 });\n        setHsvValues({ h: 0, s: 0, v: 0 });\n        setValueSliderValue(0);\n        setColorWheelPosition({ x: 64, y: 64 });\n      } else {\n        // Handle normal color\n        const color = normalizeHexColor(initialColor);\n        setCurrentColor(color);\n        setPreviewColor(color);\n        setHexInput(color);\n        \n        const rgb = hexToRgb(color);\n        const hsv = hexToHsv(color);\n        \n        if (rgb) setRgbValues(rgb);\n        if (hsv) {\n          setHsvValues(hsv);\n          setValueSliderValue(hsv.v);\n          updateColorWheelPosition(hsv);\n        }\n      }\n    }\n  }, [isOpen, initialColor]);\n\n  // Update preview color in store\n  useEffect(() => {\n    updatePreviewColor(previewColor);\n  }, [previewColor, updatePreviewColor]);\n\n  // Update color wheel position based on HSV values\n  const updateColorWheelPosition = useCallback((hsv: HSVColor) => {\n    const centerX = 64; // Half of 128px wheel\n    const centerY = 64;\n    const maxRadius = 54; // Slightly less than 64 to stay within bounds\n    \n    const angle = (hsv.h * Math.PI) / 180;\n    const radius = (hsv.s / 100) * maxRadius;\n    \n    const x = centerX + radius * Math.cos(angle);\n    const y = centerY + radius * Math.sin(angle);\n    \n    setColorWheelPosition({ x, y });\n  }, []);\n\n  // Color update handlers\n  const updateFromHex = useCallback((hex: string) => {\n    const normalizedHex = normalizeHexColor(hex);\n    const rgb = hexToRgb(normalizedHex);\n    const hsv = hexToHsv(normalizedHex);\n    \n    if (rgb && hsv) {\n      setPreviewColor(normalizedHex);\n      setRgbValues(rgb);\n      setHsvValues(hsv);\n      setValueSliderValue(hsv.v);\n      updateColorWheelPosition(hsv);\n      setIsTransparentColor(false);\n    }\n  }, [updateColorWheelPosition]);\n\n  const updateFromRgb = useCallback((rgb: RGBColor) => {\n    const hex = rgbToHex(rgb);\n    const hsv = rgbToHsv(rgb);\n    \n    setPreviewColor(hex);\n    setHexInput(hex);\n    setHsvValues(hsv);\n    setValueSliderValue(hsv.v);\n    updateColorWheelPosition(hsv);\n    setIsTransparentColor(false);\n  }, [updateColorWheelPosition]);\n\n  const updateFromHsv = useCallback((hsv: HSVColor) => {\n    const rgb = hsvToRgb(hsv);\n    const hex = hsvToHex(hsv);\n    \n    setPreviewColor(hex);\n    setHexInput(hex);\n    setRgbValues(rgb);\n    setValueSliderValue(hsv.v);\n    updateColorWheelPosition(hsv);\n    setIsTransparentColor(false);\n  }, [updateColorWheelPosition]);\n\n  // Handle hex input change\n  const handleHexChange = (value: string) => {\n    setHexInput(value);\n    if (/^#[0-9A-Fa-f]{6}$/.test(value)) {\n      updateFromHex(value);\n    }\n  };\n\n  // Handle RGB slider changes\n  const handleRgbChange = (component: 'r' | 'g' | 'b', value: number) => {\n    const newRgb = { ...rgbValues, [component]: Math.round(value) };\n    setRgbValues(newRgb);\n    updateFromRgb(newRgb);\n  };\n\n  // Handle RGB input changes\n  const handleRgbInputChange = (component: 'r' | 'g' | 'b', value: string) => {\n    const numValue = parseInt(value);\n    if (!isNaN(numValue) && numValue >= 0 && numValue <= 255) {\n      handleRgbChange(component, numValue);\n    }\n  };\n\n  // Handle HSV slider changes\n  const handleHsvChange = (component: 'h' | 's' | 'v', value: number) => {\n    const roundedValue = component === 'h' ? Math.round(value * 100) / 100 : Math.round(value);\n    const newHsv = { ...hsvValues, [component]: roundedValue };\n    setHsvValues(newHsv);\n    updateFromHsv(newHsv);\n  };\n\n  // Handle HSV input changes\n  const handleHsvInputChange = (component: 'h' | 's' | 'v', value: string) => {\n    const numValue = parseFloat(value);\n    const maxValues = { h: 360, s: 100, v: 100 };\n    if (!isNaN(numValue) && numValue >= 0 && numValue <= maxValues[component]) {\n      handleHsvChange(component, numValue);\n    }\n  };\n\n  // Handle value slider change (affects the entire color wheel brightness)\n  const handleValueSliderChange = (value: number) => {\n    const newHsv = { ...hsvValues, v: value };\n    setHsvValues(newHsv);\n    setValueSliderValue(value);\n    updateFromHsv(newHsv);\n  };\n\n  // Color wheel interaction with drag support\n  const handleColorWheelInteraction = (event: React.MouseEvent<HTMLDivElement> | MouseEvent) => {\n    if (!colorWheelRef.current) return;\n    \n    const rect = colorWheelRef.current.getBoundingClientRect();\n    const centerX = rect.width / 2;\n    const centerY = rect.height / 2;\n    const x = (event.clientX - rect.left) - centerX;\n    const y = (event.clientY - rect.top) - centerY;\n    \n    const distance = Math.sqrt(x * x + y * y);\n    const maxDistance = Math.min(centerX, centerY) - 10;\n    \n    if (distance <= maxDistance) {\n      let angle = Math.atan2(y, x);\n      angle = (angle * 180 / Math.PI + 360) % 360; // Convert to 0-360 degrees\n      \n      const saturation = Math.min(100, (distance / maxDistance) * 100);\n      \n      const newHsv = { ...hsvValues, h: angle, s: saturation };\n      setHsvValues(newHsv);\n      updateFromHsv(newHsv);\n      \n      // Update position for visual feedback\n      const displayX = centerX + x;\n      const displayY = centerY + y;\n      setColorWheelPosition({ x: displayX, y: displayY });\n    }\n  };\n\n  const handleColorWheelMouseDown = (event: React.MouseEvent<HTMLDivElement>) => {\n    setIsDragging(true);\n    handleColorWheelInteraction(event);\n  };\n\n  // Mouse move handler for dragging\n  useEffect(() => {\n    if (!isDragging) return;\n\n    const handleMouseMove = (event: MouseEvent) => {\n      handleColorWheelInteraction(event);\n    };\n\n    const handleMouseUp = () => {\n      setIsDragging(false);\n    };\n\n    document.addEventListener('mousemove', handleMouseMove);\n    document.addEventListener('mouseup', handleMouseUp);\n\n    return () => {\n      document.removeEventListener('mousemove', handleMouseMove);\n      document.removeEventListener('mouseup', handleMouseUp);\n    };\n  }, [isDragging]);\n\n  // Eyedropper functionality\n  const handleEyedropper = async () => {\n    if ('EyeDropper' in window) {\n      try {\n        // @ts-ignore - EyeDropper API is experimental\n        const eyeDropper = new window.EyeDropper();\n        const result = await eyeDropper.open();\n        updateFromHex(result.sRGBHex);\n      } catch (error) {\n        // Eyedropper cancelled or not supported\n      }\n    }\n  };\n\n  // Recent color selection\n  const handleRecentColorSelect = (color: string) => {\n    updateFromHex(color);\n  };\n\n  // Reset to current color\n  const handleReset = () => {\n    if (currentColor === 'transparent' || currentColor === ANSI_COLORS.transparent) {\n      setIsTransparentColor(true);\n      setPreviewColor('transparent');\n      setHexInput('');\n      setRgbValues({ r: 0, g: 0, b: 0 });\n      setHsvValues({ h: 0, s: 0, v: 0 });\n      setValueSliderValue(0);\n      setColorWheelPosition({ x: 64, y: 64 });\n    } else {\n      updateFromHex(currentColor);\n    }\n  };\n\n  // Confirm color selection\n  const handleConfirm = () => {\n    addRecentColor(previewColor);\n    onColorSelect(previewColor);\n    onOpenChange(false);\n  };\n\n  // Cancel selection\n  const handleCancel = () => {\n    onOpenChange(false);\n  };\n\n  // Create radial gradient for saturation in color wheel\n  const createColorWheelStyle = () => {\n    const lightness = 50 + (valueSliderValue - 50) * 0.5; // Adjust lightness based on value\n    return {\n      background: `conic-gradient(\n        hsl(0, 100%, ${lightness}%),\n        hsl(60, 100%, ${lightness}%),\n        hsl(120, 100%, ${lightness}%),\n        hsl(180, 100%, ${lightness}%),\n        hsl(240, 100%, ${lightness}%),\n        hsl(300, 100%, ${lightness}%),\n        hsl(0, 100%, ${lightness}%)\n      ), radial-gradient(circle, transparent 0%, rgba(255,255,255,0.8) 70%)`\n    };\n  };\n\n  return (\n    <Dialog open={isOpen} onOpenChange={onOpenChange}>\n      <DialogContent className=\"max-w-md\">\n        <DialogHeader>\n          <DialogTitle>{title}</DialogTitle>\n        </DialogHeader>\n        \n        <div className=\"space-y-4\">\n          {/* Color Preview */}\n          <div className=\"flex items-center gap-3\">\n            <div className=\"flex-1\">\n              <Label className=\"text-sm font-medium\">Preview</Label>\n              <div className=\"flex h-12 border border-border rounded overflow-hidden\">\n                {/* Current Color */}\n                <div className=\"flex-1 relative\">\n                  {(currentColor === 'transparent' || currentColor === ANSI_COLORS.transparent) ? (\n                    <div className=\"w-full h-full relative bg-white\">\n                      <div \n                        className=\"absolute inset-0\"\n                        style={{\n                          backgroundImage: 'linear-gradient(45deg, #ccc 25%, transparent 25%), linear-gradient(-45deg, #ccc 25%, transparent 25%), linear-gradient(45deg, transparent 75%, #ccc 75%), linear-gradient(-45deg, transparent 75%, #ccc 75%)',\n                          backgroundSize: '8px 8px',\n                          backgroundPosition: '0 0, 0 4px, 4px -4px, -4px 0px'\n                        }}\n                      />\n                      <svg className=\"absolute inset-0 w-full h-full\" viewBox=\"0 0 48 48\">\n                        <line x1=\"4\" y1=\"44\" x2=\"44\" y2=\"4\" stroke=\"#dc2626\" strokeWidth=\"2\" strokeLinecap=\"round\" />\n                      </svg>\n                    </div>\n                  ) : (\n                    <div \n                      className=\"w-full h-full\"\n                      style={{ backgroundColor: currentColor }}\n                      title=\"Current Color\"\n                    />\n                  )}\n                </div>\n                \n                {/* Preview Color */}\n                <div className=\"flex-1 relative border-l border-border\">\n                  {(previewColor === 'transparent' || isTransparentColor) ? (\n                    <div className=\"w-full h-full relative bg-white\">\n                      <div \n                        className=\"absolute inset-0\"\n                        style={{\n                          backgroundImage: 'linear-gradient(45deg, #ccc 25%, transparent 25%), linear-gradient(-45deg, #ccc 25%, transparent 25%), linear-gradient(45deg, transparent 75%, #ccc 75%), linear-gradient(-45deg, transparent 75%, #ccc 75%)',\n                          backgroundSize: '8px 8px',\n                          backgroundPosition: '0 0, 0 4px, 4px -4px, -4px 0px'\n                        }}\n                      />\n                      <svg className=\"absolute inset-0 w-full h-full\" viewBox=\"0 0 48 48\">\n                        <line x1=\"4\" y1=\"44\" x2=\"44\" y2=\"4\" stroke=\"#dc2626\" strokeWidth=\"2\" strokeLinecap=\"round\" />\n                      </svg>\n                    </div>\n                  ) : (\n                    <div \n                      className=\"w-full h-full\"\n                      style={{ backgroundColor: previewColor }}\n                      title=\"New Color\"\n                    />\n                  )}\n                </div>\n              </div>\n            </div>\n            \n            {/* Eyedropper Button */}\n            {'EyeDropper' in window && (\n              <Button\n                size=\"sm\"\n                variant=\"outline\" \n                onClick={handleEyedropper}\n                className=\"h-8 w-8 p-0\"\n              >\n                <Pipette className=\"h-4 w-4\" />\n              </Button>\n            )}\n          </div>\n\n          {/* Color Wheel and Value Slider */}\n          <div className=\"space-y-2\">\n            <Label className=\"text-sm font-medium\">Color Wheel</Label>\n            <div className=\"flex justify-center items-center gap-4\">\n              {/* Color Wheel */}\n              <div \n                ref={colorWheelRef}\n                className=\"w-32 h-32 rounded-full border border-border cursor-crosshair relative select-none\"\n                style={createColorWheelStyle()}\n                onMouseDown={handleColorWheelMouseDown}\n              >\n                <div \n                  className=\"absolute w-3 h-3 bg-white border-2 border-black rounded-full transform -translate-x-1.5 -translate-y-1.5 pointer-events-none\"\n                  style={{\n                    left: colorWheelPosition.x,\n                    top: colorWheelPosition.y\n                  }}\n                />\n              </div>\n              \n              {/* Value Slider */}\n              <div className=\"flex flex-col items-center gap-2\">\n                <Label className=\"text-xs font-medium\">V</Label>\n                <div className=\"w-6 flex flex-col items-center\">\n                  <input\n                    type=\"range\"\n                    value={valueSliderValue}\n                    onChange={(e) => handleValueSliderChange(parseFloat(e.target.value))}\n                    max={100}\n                    step={1}\n                    className=\"h-32 w-2 bg-muted rounded-lg appearance-none cursor-pointer transform -rotate-90 origin-center\"\n                    style={{ writingMode: 'bt-lr' } as any}\n                    disabled={isTransparentColor}\n                  />\n                </div>\n                <span className=\"text-xs text-muted-foreground\">\n                  {isTransparentColor ? '-' : `${Math.round(valueSliderValue)}%`}\n                </span>\n              </div>\n            </div>\n          </div>\n\n          <Separator />\n\n          {/* HSV Controls */}\n          <div className=\"space-y-3\">\n            <Label className=\"text-sm font-medium\">HSV</Label>\n            \n            {/* Hue */}\n            <div className=\"flex items-center gap-2\">\n              <Label className=\"w-4 text-xs\">H</Label>\n              <Slider\n                value={isTransparentColor ? 0 : hsvValues.h}\n                onValueChange={(value) => handleHsvChange('h', value)}\n                max={360}\n                step={0.1}\n                className=\"flex-1\"\n                disabled={isTransparentColor}\n              />\n              <Input\n                value={isTransparentColor ? '-' : hsvValues.h.toFixed(2)}\n                onChange={(e) => handleHsvInputChange('h', e.target.value)}\n                className=\"w-20 h-8 text-xs\"\n                disabled={isTransparentColor}\n              />\n              <span className=\"text-xs text-muted-foreground\">°</span>\n            </div>\n            \n            {/* Saturation */}\n            <div className=\"flex items-center gap-2\">\n              <Label className=\"w-4 text-xs\">S</Label>\n              <Slider\n                value={isTransparentColor ? 0 : hsvValues.s}\n                onValueChange={(value) => handleHsvChange('s', value)}\n                max={100}\n                step={1}\n                className=\"flex-1\"\n                disabled={isTransparentColor}\n              />\n              <Input\n                value={isTransparentColor ? '-' : Math.round(hsvValues.s).toString()}\n                onChange={(e) => handleHsvInputChange('s', e.target.value)}\n                className=\"w-20 h-8 text-xs\"\n                disabled={isTransparentColor}\n              />\n              <span className=\"text-xs text-muted-foreground\">%</span>\n            </div>\n            \n            {/* Value */}\n            <div className=\"flex items-center gap-2\">\n              <Label className=\"w-4 text-xs\">V</Label>\n              <Slider\n                value={isTransparentColor ? 0 : hsvValues.v}\n                onValueChange={(value) => handleHsvChange('v', value)}\n                max={100}\n                step={1}\n                className=\"flex-1\"\n                disabled={isTransparentColor}\n              />\n              <Input\n                value={isTransparentColor ? '-' : Math.round(hsvValues.v).toString()}\n                onChange={(e) => handleHsvInputChange('v', e.target.value)}\n                className=\"w-20 h-8 text-xs\"\n                disabled={isTransparentColor}\n              />\n              <span className=\"text-xs text-muted-foreground\">%</span>\n            </div>\n          </div>\n\n          <Separator />\n\n          {/* RGB Controls */}\n          <div className=\"space-y-3\">\n            <Label className=\"text-sm font-medium\">RGB</Label>\n            \n            {/* Red */}\n            <div className=\"flex items-center gap-2\">\n              <Label className=\"w-4 text-xs\">R</Label>\n              <Slider\n                value={isTransparentColor ? 0 : rgbValues.r}\n                onValueChange={(value) => handleRgbChange('r', value)}\n                max={255}\n                step={1}\n                className=\"flex-1\"\n                disabled={isTransparentColor}\n              />\n              <Input\n                value={isTransparentColor ? '-' : rgbValues.r.toString()}\n                onChange={(e) => handleRgbInputChange('r', e.target.value)}\n                className=\"w-16 h-8 text-xs\"\n                disabled={isTransparentColor}\n              />\n            </div>\n            \n            {/* Green */}\n            <div className=\"flex items-center gap-2\">\n              <Label className=\"w-4 text-xs\">G</Label>\n              <Slider\n                value={isTransparentColor ? 0 : rgbValues.g}\n                onValueChange={(value) => handleRgbChange('g', value)}\n                max={255}\n                step={1}\n                className=\"flex-1\"\n                disabled={isTransparentColor}\n              />\n              <Input\n                value={isTransparentColor ? '-' : rgbValues.g.toString()}\n                onChange={(e) => handleRgbInputChange('g', e.target.value)}\n                className=\"w-16 h-8 text-xs\"\n                disabled={isTransparentColor}\n              />\n            </div>\n            \n            {/* Blue */}\n            <div className=\"flex items-center gap-2\">\n              <Label className=\"w-4 text-xs\">B</Label>\n              <Slider\n                value={isTransparentColor ? 0 : rgbValues.b}\n                onValueChange={(value) => handleRgbChange('b', value)}\n                max={255}\n                step={1}\n                className=\"flex-1\"\n                disabled={isTransparentColor}\n              />\n              <Input\n                value={isTransparentColor ? '-' : rgbValues.b.toString()}\n                onChange={(e) => handleRgbInputChange('b', e.target.value)}\n                className=\"w-16 h-8 text-xs\"\n                disabled={isTransparentColor}\n              />\n            </div>\n          </div>\n\n          <Separator />\n\n          {/* Hex Input */}\n          <div className=\"space-y-2\">\n            <Label className=\"text-sm font-medium\">Hex</Label>\n            <Input\n              value={isTransparentColor ? '-' : hexInput}\n              onChange={(e) => handleHexChange(e.target.value)}\n              placeholder={isTransparentColor ? \"Transparent\" : \"#000000\"}\n              className=\"font-mono\"\n              disabled={isTransparentColor}\n            />\n          </div>\n\n          {/* Recent Colors */}\n          {recentColors.length > 0 && (\n            <div className=\"space-y-2\">\n              <Label className=\"text-sm font-medium\">Recent Colors</Label>\n              <div className=\"flex gap-1 flex-wrap\">\n                {recentColors.slice(0, 10).map((color, index) => (\n                  <button\n                    key={index}\n                    className=\"w-6 h-6 rounded border border-border hover:scale-110 transition-transform\"\n                    style={{ backgroundColor: color }}\n                    onClick={() => handleRecentColorSelect(color)}\n                    title={color}\n                  />\n                ))}\n              </div>\n            </div>\n          )}\n        </div>\n\n        {/* Dialog Footer */} \n        <div className=\"flex justify-between pt-4\">\n          <Button\n            variant=\"outline\"\n            onClick={handleReset}\n            className=\"gap-2\"\n          >\n            <RotateCcw className=\"h-4 w-4\" />\n            Reset\n          </Button>\n          \n          <div className=\"flex gap-2\">\n            <Button\n              variant=\"outline\"\n              onClick={handleCancel}\n              className=\"gap-2\"\n            >\n              <X className=\"h-4 w-4\" />\n              Cancel\n            </Button>\n            \n            <Button\n              onClick={handleConfirm}\n              className=\"gap-2\"\n            >\n              <Check className=\"h-4 w-4\" />\n              OK\n            </Button>\n          </div>\n        </div>\n      </DialogContent>\n    </Dialog>\n  );\n};\n","usedDeprecatedRules":[]},{"filePath":"/Users/cameronfoxly/GitHubRepos/Ascii-Motion/src/components/features/ColorPicker_new.tsx","messages":[{"ruleId":"prefer-const","severity":2,"message":"'currentIndex' is never reassigned. Use 'const' instead.","line":156,"column":9,"nodeType":"Identifier","messageId":"useConst","endLine":156,"endColumn":21,"fix":{"range":[6041,6072],"text":"const currentIndex = sourceIndex;"}}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":1,"fixableWarningCount":0,"source":"import React, { useState, useEffect } from 'react';\nimport { useToolStore } from '../../stores/toolStore';\nimport { usePaletteStore } from '../../stores/paletteStore';\nimport { Card, CardContent } from '@/components/ui/card';\nimport { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs';\nimport { Button } from '@/components/ui/button';\nimport { Select, SelectContent, SelectItem, SelectSeparator, SelectTrigger, SelectValue } from '@/components/ui/select';\nimport { Tooltip, TooltipContent, TooltipProvider, TooltipTrigger } from '@/components/ui/tooltip';\nimport { Collapsible, CollapsibleContent, CollapsibleTrigger } from '@/components/ui/collapsible';\nimport { Palette, Type, Settings, Plus, Trash2, ChevronLeft, ChevronRight, Upload, Download, ChevronDown, ChevronUp } from 'lucide-react';\nimport { ForegroundBackgroundSelector } from './ForegroundBackgroundSelector';\nimport { ColorPickerOverlay } from './ColorPickerOverlay';\nimport { ImportPaletteDialog } from './ImportPaletteDialog';\nimport { ExportPaletteDialog } from './ExportPaletteDialog';\nimport { ManagePalettesDialog } from './ManagePalettesDialog';\nimport { ANSI_COLORS } from '../../constants/colors';\n\ninterface ColorPickerProps {\n  className?: string;\n}\n\nexport const ColorPicker: React.FC<ColorPickerProps> = ({ className = '' }) => {\n  const { selectedColor, selectedBgColor, setSelectedColor, setSelectedBgColor } = useToolStore();\n  const { \n    palettes,\n    activePaletteId,\n    selectedColorId,\n    getActivePalette,\n    getActiveColors,\n    getCustomPalettes,\n    getPresetPalettes,\n    setActivePalette,\n    setSelectedColor: setSelectedColorId,\n    addColor,\n    removeColor,\n    updateColor,\n    moveColorLeft,\n    moveColorRight,\n    createCustomPalette,\n    initialize,\n    addRecentColor\n  } = usePaletteStore();\n\n  const [activeTab, setActiveTab] = useState(\"text\");\n  const [isColorPickerOpen, setIsColorPickerOpen] = useState(false);\n  const [colorPickerMode, setColorPickerMode] = useState<'foreground' | 'background' | 'palette'>('foreground');\n  const [colorPickerInitialColor, setColorPickerInitialColor] = useState('#000000');\n  const [editingColorId, setEditingColorId] = useState<string | null>(null);\n  const [isImportDialogOpen, setIsImportDialogOpen] = useState(false);\n  const [isExportDialogOpen, setIsExportDialogOpen] = useState(false);\n  const [isManagePalettesOpen, setIsManagePalettesOpen] = useState(false);\n  \n  // Collapsible section states\n  const [isColorSectionOpen, setIsColorSectionOpen] = useState(true);\n  const [isPaletteSectionOpen, setIsPaletteSectionOpen] = useState(true);\n\n  // Initialize palette store on mount (ensure default palettes are loaded)\n  useEffect(() => {\n    if (palettes.length === 0) {\n      initialize();\n    }\n  }, [palettes.length, initialize]);\n\n  // Get active palette and colors\n  const activePalette = getActivePalette();\n  const activeColors = getActiveColors();\n  const customPalettes = getCustomPalettes();\n  const presetPalettes = getPresetPalettes();\n\n  // Filter colors for foreground (no transparent) and background (always include transparent)\n  const foregroundColors = activeColors.filter(color => color.value !== 'transparent' && color.value !== ANSI_COLORS.transparent);\n  const backgroundColors = [\n    { id: 'transparent', value: 'transparent', name: 'Transparent' }, \n    ...activeColors.filter(color => color.value !== 'transparent' && color.value !== ANSI_COLORS.transparent)\n  ];\n\n  // Handle palette selection\n  const handlePaletteChange = (paletteId: string) => {\n    setActivePalette(paletteId);\n    setSelectedColorId(null);\n  };\n\n  // Handle color selection from palette\n  const handleColorSelect = (color: string, isBackground = false) => {\n    if (isBackground) {\n      setSelectedBgColor(color);\n    } else {\n      setSelectedColor(color);\n    }\n    addRecentColor(color);\n  };\n\n  // Handle color selection for editing (single click)\n  const handleColorPaletteSelect = (colorId: string) => {\n    setSelectedColorId(selectedColorId === colorId ? null : colorId);\n  };\n\n  // Drag and drop state\n  const [draggedColorId, setDraggedColorId] = useState<string | null>(null);\n  const [dropIndicatorIndex, setDropIndicatorIndex] = useState<number | null>(null);\n\n  // Handle drag start\n  const handleDragStart = (e: React.DragEvent, colorId: string) => {\n    if (!activePalette) {\n      e.preventDefault();\n      return;\n    }\n    setDraggedColorId(colorId);\n    e.dataTransfer.effectAllowed = 'move';\n  };\n\n  // Handle drag over\n  const handleDragOver = (e: React.DragEvent, targetColorId?: string) => {\n    if (!activePalette || !draggedColorId) return;\n    e.preventDefault();\n    e.dataTransfer.dropEffect = 'move';\n    \n    if (targetColorId) {\n      const targetIndex = activeColors.findIndex(c => c.id === targetColorId);\n      if (targetIndex !== -1) {\n        // Determine if we should show indicator before or after based on mouse position\n        const rect = (e.target as HTMLElement).getBoundingClientRect();\n        const mouseX = e.clientX - rect.left;\n        const isAfter = mouseX > rect.width / 2;\n        setDropIndicatorIndex(isAfter ? targetIndex + 1 : targetIndex);\n      }\n    }\n  };\n\n  // Handle drop\n  const handleDrop = (e: React.DragEvent, targetColorId: string) => {\n    e.preventDefault();\n    if (!activePalette || !draggedColorId || draggedColorId === targetColorId) {\n      setDraggedColorId(null);\n      setDropIndicatorIndex(null);\n      return;\n    }\n\n    // Find indices of source and target colors\n    const sourceIndex = activeColors.findIndex(c => c.id === draggedColorId);\n    const targetIndex = activeColors.findIndex(c => c.id === targetColorId);\n    \n    if (sourceIndex === -1 || targetIndex === -1) {\n      setDraggedColorId(null);\n      setDropIndicatorIndex(null);\n      return;\n    }\n\n    // Determine final position based on drop indicator\n    let finalTargetIndex = targetIndex;\n    if (dropIndicatorIndex === targetIndex + 1) {\n      finalTargetIndex = targetIndex + 1;\n    }\n\n    // Move the colors\n    let currentIndex = sourceIndex;\n    if (currentIndex < finalTargetIndex) {\n      // Moving right - use moveColorRight\n      for (let i = 0; i < finalTargetIndex - sourceIndex; i++) {\n        moveColorRight(activePaletteId, draggedColorId);\n      }\n    } else if (currentIndex > finalTargetIndex) {\n      // Moving left - use moveColorLeft\n      for (let i = 0; i < sourceIndex - finalTargetIndex; i++) {\n        moveColorLeft(activePaletteId, draggedColorId);\n      }\n    }\n\n    setDraggedColorId(null);\n    setDropIndicatorIndex(null);\n  };\n\n  // Handle drag leave\n  const handleDragLeave = (e: React.DragEvent) => {\n    // Only clear if leaving the grid container\n    if (!e.currentTarget.contains(e.relatedTarget as Node)) {\n      setDropIndicatorIndex(null);\n    }\n  };\n\n  // Handle color double-click to edit\n  const handleColorDoubleClick = (color: string) => {\n    if (activePalette) {\n      const colorItem = activeColors.find(c => c.value === color);\n      setEditingColorId(colorItem?.id || null);\n      setColorPickerMode('palette');\n      setColorPickerInitialColor(color);\n      setIsColorPickerOpen(true);\n    }\n  };\n\n  // Handle opening color picker from foreground/background selector\n  const handleOpenColorPicker = (mode: 'foreground' | 'background', currentColor: string) => {\n    setColorPickerMode(mode);\n    setColorPickerInitialColor(currentColor);\n    setIsColorPickerOpen(true);\n  };\n\n  // Handle color picker selection\n  const handleColorPickerSelect = (newColor: string) => {\n    if (colorPickerMode === 'palette' && editingColorId) {\n      // Update the color in the palette\n      updateColor(activePaletteId, editingColorId, newColor);\n      // Clear editing state\n      setEditingColorId(null);\n      setColorPickerMode('foreground');\n    } else if (colorPickerMode === 'foreground') {\n      setSelectedColor(newColor);\n    } else if (colorPickerMode === 'background') {\n      setSelectedBgColor(newColor);\n    }\n  };\n\n  // Check if color is currently selected \n  const isColorSelected = (color: string, isBackground = false) => {\n    return isBackground ? selectedBgColor === color : selectedColor === color;\n  };\n\n  return (\n    <div className={`space-y-3 ${className}`}>\n      {/* Color Section */}\n      <Collapsible open={isColorSectionOpen} onOpenChange={setIsColorSectionOpen}>\n        <CollapsibleTrigger asChild>\n          <Button variant=\"ghost\" className=\"w-full justify-between p-2 h-auto font-medium text-sm\">\n            Color\n            {isColorSectionOpen ? (\n              <ChevronUp className=\"h-4 w-4\" />\n            ) : (\n              <ChevronDown className=\"h-4 w-4\" />\n            )}\n          </Button>\n        </CollapsibleTrigger>\n        <CollapsibleContent className=\"space-y-3\">\n          {/* Photoshop-style foreground/background selector */}\n          <ForegroundBackgroundSelector onOpenColorPicker={handleOpenColorPicker} />\n        </CollapsibleContent>\n      </Collapsible>\n\n      {/* Palette Section */}\n      <Collapsible open={isPaletteSectionOpen} onOpenChange={setIsPaletteSectionOpen}>\n        <CollapsibleTrigger asChild>\n          <Button variant=\"ghost\" className=\"w-full justify-between p-2 h-auto font-medium text-sm\">\n            Palette\n            {isPaletteSectionOpen ? (\n              <ChevronUp className=\"h-4 w-4\" />\n            ) : (\n              <ChevronDown className=\"h-4 w-4\" />\n            )}\n          </Button>\n        </CollapsibleTrigger>\n        <CollapsibleContent className=\"space-y-3\">\n          {/* Palette selector */}\n          <div className=\"space-y-2\">\n            <div className=\"flex items-center justify-between\">\n              <label className=\"text-sm font-medium text-muted-foreground\">Active Palette</label>\n              <div className=\"flex gap-1\">\n                <TooltipProvider>\n                  <Tooltip>\n                    <TooltipTrigger asChild>\n                      <Button\n                        size=\"sm\"\n                        variant=\"outline\"\n                        className=\"h-6 w-6 p-0\"\n                        onClick={() => {\n                          const newPaletteId = createCustomPalette('New Palette');\n                          setActivePalette(newPaletteId);\n                        }}\n                      >\n                        <Plus className=\"h-3 w-3\" />\n                      </Button>\n                    </TooltipTrigger>\n                    <TooltipContent>\n                      <p>Create new palette</p>\n                    </TooltipContent>\n                  </Tooltip>\n                </TooltipProvider>\n\n                <TooltipProvider>\n                  <Tooltip>\n                    <TooltipTrigger asChild>\n                      <Button\n                        size=\"sm\"\n                        variant=\"outline\"\n                        className=\"h-6 w-6 p-0\"\n                        onClick={() => setIsManagePalettesOpen(true)}\n                      >\n                        <Settings className=\"h-3 w-3\" />\n                      </Button>\n                    </TooltipTrigger>\n                    <TooltipContent>\n                      <p>Manage palettes</p>\n                    </TooltipContent>\n                  </Tooltip>\n                </TooltipProvider>\n              </div>\n            </div>\n\n            <Select value={activePaletteId || ''} onValueChange={handlePaletteChange}>\n              <SelectTrigger className=\"w-full h-8 text-xs\">\n                <SelectValue placeholder=\"Select palette...\" />\n              </SelectTrigger>\n              <SelectContent>\n                {customPalettes.length > 0 && (\n                  <>\n                    {customPalettes.map((palette) => (\n                      <SelectItem key={palette.id} value={palette.id} className=\"text-xs\">\n                        <span>{palette.name}</span>\n                      </SelectItem>\n                    ))}\n                    <SelectSeparator />\n                  </>\n                )}\n                {presetPalettes.map((palette) => (\n                  <SelectItem key={palette.id} value={palette.id} className=\"text-xs\">\n                    <span>{palette.name}</span>\n                  </SelectItem>\n                ))}\n              </SelectContent>\n            </Select>\n          </div>\n\n          {/* Color palette tabs */}\n          <Tabs value={activeTab} onValueChange={setActiveTab} className=\"w-full\">\n            <TabsList className=\"grid w-full grid-cols-2 h-8\">\n              <TabsTrigger value=\"text\" className=\"text-xs h-full flex items-center justify-center gap-1\">\n                <Type className=\"w-3 h-3\" />\n                Text\n              </TabsTrigger>\n              <TabsTrigger value=\"bg\" className=\"text-xs h-full flex items-center justify-center gap-1\">\n                <Palette className=\"w-3 h-3\" />\n                BG\n              </TabsTrigger>\n            </TabsList>\n\n            {/* Foreground colors */}\n            <TabsContent value=\"text\" className=\"mt-2\">\n              <Card className=\"bg-card/50 border-border/50\">\n                <CardContent className=\"p-2\">\n                  <div className=\"grid grid-cols-6 gap-0.5 relative flex items-center justify-center\" onDragLeave={handleDragLeave}>\n                    {foregroundColors.map((color, index) => (\n                      <div key={`text-${color.id}`} className=\"relative flex items-center justify-center\">\n                        {/* Drop indicator line */}\n                        {dropIndicatorIndex === index && (\n                          <div className=\"absolute -left-0.5 top-0 bottom-0 w-0.5 bg-primary z-10 rounded-full\"></div>\n                        )}\n                        \n                        <button\n                          draggable={!!activePalette}\n                          className={`w-6 h-6 rounded border-2 transition-all hover:scale-105 relative ${\n                            draggedColorId === color.id ? 'opacity-50 scale-95' : ''\n                          } ${\n                            selectedColorId === color.id\n                              ? 'border-primary ring-2 ring-primary/20 shadow-lg' \n                              : isColorSelected(color.value, false)\n                              ? 'border-primary ring-1 ring-primary/20' \n                              : 'border-border'\n                          } cursor-move`}\n                          style={{ backgroundColor: color.value }}\n                          onClick={() => {\n                            // Single click sets drawing color and selects for editing\n                            handleColorSelect(color.value, false);\n                            handleColorPaletteSelect(color.id);\n                          }}\n                          onDoubleClick={() => handleColorDoubleClick(color.value)}\n                          onDragStart={(e) => handleDragStart(e, color.id)}\n                          onDragOver={(e) => handleDragOver(e, color.id)}\n                          onDrop={(e) => handleDrop(e, color.id)}\n                          title={\n                            activePalette?.isCustom \n                              ? `${color.name ? `${color.name}: ${color.value}` : color.value} (drag to reorder)` \n                              : color.name ? `${color.name}: ${color.value}` : color.value\n                          }\n                        />\n                        \n                        {/* Drop indicator line after last item */}\n                        {dropIndicatorIndex === index + 1 && (\n                          <div className=\"absolute -right-0.5 top-0 bottom-0 w-0.5 bg-primary z-10 rounded-full\"></div>\n                        )}\n                      </div>\n                    ))}\n                  </div>\n                </CardContent>\n              </Card>\n            </TabsContent>\n\n            {/* Background colors */}\n            <TabsContent value=\"bg\" className=\"mt-2\">\n              <Card className=\"bg-card/50 border-border/50\">\n                <CardContent className=\"p-2\">\n                  <div className=\"grid grid-cols-6 gap-0.5 relative flex items-center justify-center\" onDragLeave={handleDragLeave}>\n                    {backgroundColors.map((color, index) => {\n                      const isTransparent = color.value === 'transparent';\n                      return (\n                        <div key={`bg-${color.id}`} className=\"relative flex items-center justify-center\">\n                          {/* Drop indicator line */}\n                          {dropIndicatorIndex === index && (\n                            <div className=\"absolute -left-0.5 top-0 bottom-0 w-0.5 bg-primary z-10 rounded-full\"></div>\n                          )}\n                          \n                          <button\n                            draggable={!!activePalette && !isTransparent}\n                            className={`w-6 h-6 rounded border-2 transition-all hover:scale-105 relative overflow-hidden ${\n                              draggedColorId === color.id ? 'opacity-50 scale-95' : ''\n                            } ${\n                              selectedColorId === color.id\n                                ? 'border-primary ring-2 ring-primary/20 shadow-lg' \n                                : isColorSelected(color.value, true)\n                                ? 'border-primary ring-1 ring-primary/20' \n                                : 'border-border'\n                            } ${!isTransparent ? 'cursor-move' : 'cursor-pointer'}`}\n                            style={{\n                              backgroundColor: isTransparent ? '#ffffff' : color.value,\n                              backgroundImage: isTransparent \n                                ? 'linear-gradient(45deg, #ccc 25%, transparent 25%), linear-gradient(-45deg, #ccc 25%, transparent 25%), linear-gradient(45deg, transparent 75%, #ccc 75%), linear-gradient(-45deg, transparent 75%, #ccc 75%)'\n                                : 'none',\n                              backgroundSize: isTransparent ? '8px 8px' : 'auto',\n                              backgroundPosition: isTransparent ? '0 0, 0 4px, 4px -4px, -4px 0px' : 'auto'\n                            }}\n                            onClick={() => {\n                              handleColorSelect(color.value, true);\n                              handleColorPaletteSelect(color.id);\n                            }}\n                            onDoubleClick={() => !isTransparent && handleColorDoubleClick(color.value)}\n                            onDragStart={(e) => handleDragStart(e, color.id)}\n                            onDragOver={(e) => handleDragOver(e, color.id)}\n                            onDrop={(e) => handleDrop(e, color.id)}\n                            title={\n                              isTransparent \n                                ? 'Transparent background' \n                                : activePalette?.isCustom \n                                ? `${color.name ? `${color.name}: ${color.value}` : color.value} (drag to reorder)` \n                                : color.name ? `${color.name}: ${color.value}` : color.value\n                            }\n                          >\n                            {isTransparent && (\n                              <svg \n                                className=\"absolute inset-0 w-full h-full pointer-events-none\" \n                                viewBox=\"0 0 24 24\"\n                                style={{ borderRadius: 'inherit' }}\n                              >\n                                <line \n                                  x1=\"2\" y1=\"2\" \n                                  x2=\"22\" y2=\"22\" \n                                  stroke=\"#ef4444\" \n                                  strokeWidth=\"2\"\n                                />\n                              </svg>\n                            )}\n                          </button>\n                          \n                          {/* Drop indicator line after last item */}\n                          {dropIndicatorIndex === index + 1 && (\n                            <div className=\"absolute -right-0.5 top-0 bottom-0 w-0.5 bg-primary z-10 rounded-full\"></div>\n                          )}\n                        </div>\n                      );\n                    })}\n                  </div>\n                </CardContent>\n              </Card>\n            </TabsContent>\n          </Tabs>\n\n          {/* Palette controls */}\n          {activePalette && (\n            <div className=\"flex items-center justify-between\">\n              {/* Editing controls (only for custom palettes) */}\n              <div className=\"flex gap-0.5\">\n                <TooltipProvider>\n                  <Tooltip>\n                    <TooltipTrigger asChild>\n                      <Button\n                        size=\"sm\"\n                        variant=\"outline\"\n                        className=\"h-6 w-6 p-0\"\n                        onClick={() => selectedColorId && moveColorLeft(activePaletteId, selectedColorId)}\n                        disabled={!selectedColorId || !activePalette?.isCustom}\n                      >\n                        <ChevronLeft className=\"h-3 w-3\" />\n                      </Button>\n                    </TooltipTrigger>\n                    <TooltipContent>\n                      <p>Move color left{!activePalette?.isCustom ? ' (will create custom copy)' : ''}</p>\n                    </TooltipContent>\n                  </Tooltip>\n                </TooltipProvider>\n\n                <TooltipProvider>\n                  <Tooltip>\n                    <TooltipTrigger asChild>\n                      <Button\n                        size=\"sm\"\n                        variant=\"outline\"\n                        className=\"h-6 w-6 p-0\"\n                        onClick={() => selectedColorId && moveColorRight(activePaletteId, selectedColorId)}\n                        disabled={!selectedColorId || !activePalette?.isCustom}\n                      >\n                        <ChevronRight className=\"h-3 w-3\" />\n                      </Button>\n                    </TooltipTrigger>\n                    <TooltipContent>\n                      <p>Move color right{!activePalette?.isCustom ? ' (will create custom copy)' : ''}</p>\n                    </TooltipContent>\n                  </Tooltip>\n                </TooltipProvider>\n\n                <TooltipProvider>\n                  <Tooltip>\n                    <TooltipTrigger asChild>\n                      <Button\n                        size=\"sm\"\n                        variant=\"outline\"\n                        className=\"h-6 w-6 p-0\"\n                        onClick={() => addColor(activePaletteId, '#808080')}\n                      >\n                        <Plus className=\"h-3 w-3\" />\n                      </Button>\n                    </TooltipTrigger>\n                    <TooltipContent>\n                      <p>Add color{!activePalette?.isCustom ? ' (will create custom copy)' : ''}</p>\n                    </TooltipContent>\n                  </Tooltip>\n                </TooltipProvider>\n\n                <TooltipProvider>\n                  <Tooltip>\n                    <TooltipTrigger asChild>\n                      <Button\n                        size=\"sm\"\n                        variant=\"outline\"\n                        className=\"h-6 w-6 p-0\"\n                        onClick={() => selectedColorId && removeColor(activePaletteId, selectedColorId)}\n                        disabled={!selectedColorId || activeColors.length <= 1}\n                      >\n                        <Trash2 className=\"h-3 w-3\" />\n                      </Button>\n                    </TooltipTrigger>\n                    <TooltipContent>\n                      <p>Remove color{!activePalette?.isCustom ? ' (will create custom copy)' : ''}</p>\n                    </TooltipContent>\n                    </Tooltip>\n                  </TooltipProvider>\n                </div>\n\n              {/* Import/Export buttons (always visible) */}\n              <div className=\"flex gap-0.5\">\n                <TooltipProvider>\n                  <Tooltip>\n                    <TooltipTrigger asChild>\n                      <Button\n                        size=\"sm\"\n                        variant=\"outline\"\n                        className=\"h-6 w-6 p-0\"\n                        onClick={() => setIsImportDialogOpen(true)}\n                      >\n                        <Upload className=\"h-3 w-3\" />\n                      </Button>\n                    </TooltipTrigger>\n                    <TooltipContent>\n                      <p>Import palette</p>\n                    </TooltipContent>\n                  </Tooltip>\n                </TooltipProvider>\n\n                <TooltipProvider>\n                  <Tooltip>\n                    <TooltipTrigger asChild>\n                      <Button\n                        size=\"sm\"\n                        variant=\"outline\"\n                        className=\"h-6 w-6 p-0\"\n                        onClick={() => setIsExportDialogOpen(true)}\n                      >\n                        <Download className=\"h-3 w-3\" />\n                      </Button>\n                    </TooltipTrigger>\n                    <TooltipContent>\n                      <p>Export palette</p>\n                    </TooltipContent>\n                  </Tooltip>\n                </TooltipProvider>\n              </div>\n            </div>\n          )}\n\n          {/* Status text */}\n          {activePalette && (\n            <div className=\"text-xs text-muted-foreground text-center\">\n              {activePalette.name} • {activeColors.length} colors\n              {selectedColorId && (\n                <span className=\"ml-2\">\n                  • Selected: {activeColors.find(c => c.id === selectedColorId)?.name || 'Color'}\n                </span>\n              )}\n            </div>\n          )}\n        </CollapsibleContent>\n      </Collapsible>\n\n      {/* Color Picker Modal */}\n      <ColorPickerOverlay\n        isOpen={isColorPickerOpen}\n        onOpenChange={(open) => {\n          setIsColorPickerOpen(open);\n          // Reset editing state when closing\n          if (!open && colorPickerMode === 'palette') {\n            setEditingColorId(null);\n            setColorPickerMode('foreground');\n          }\n        }}\n        onColorSelect={handleColorPickerSelect}\n        initialColor={colorPickerInitialColor}\n        title={\n          colorPickerMode === 'palette' \n            ? 'Edit Palette Color' \n            : `Edit ${colorPickerMode === 'foreground' ? 'Foreground' : 'Background'} Color`\n        }\n        showTransparentOption={colorPickerMode === 'background'}\n      />\n\n      {/* Import/Export Dialogs */}\n      <ImportPaletteDialog\n        isOpen={isImportDialogOpen}\n        onOpenChange={setIsImportDialogOpen}\n      />\n      \n      <ExportPaletteDialog\n        isOpen={isExportDialogOpen}\n        onOpenChange={setIsExportDialogOpen}\n      />\n\n      {/* Manage Palettes Dialog */}\n      <ManagePalettesDialog\n        isOpen={isManagePalettesOpen}\n        onOpenChange={setIsManagePalettesOpen}\n      />\n    </div>\n  );\n};\n","usedDeprecatedRules":[]},{"filePath":"/Users/cameronfoxly/GitHubRepos/Ascii-Motion/src/components/features/ColorReadout.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/cameronfoxly/GitHubRepos/Ascii-Motion/src/components/features/EffectsIntegrationTest.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/cameronfoxly/GitHubRepos/Ascii-Motion/src/components/features/EffectsPanel.tsx","messages":[{"ruleId":"@typescript-eslint/no-empty-object-type","severity":2,"message":"An empty interface declaration allows any non-nullish value, including literals like `0` and `\"\"`.\n- If that's what you want, disable this lint rule with an inline comment or configure the 'allowInterfaces' rule option.\n- If you want a type meaning \"any object\", you probably want `object` instead.\n- If you want a type meaning \"any value\", you probably want `unknown` instead.","line":48,"column":11,"nodeType":"Identifier","messageId":"noEmptyInterface","endLine":48,"endColumn":28,"suggestions":[{"messageId":"replaceEmptyInterface","data":{"replacement":"object"},"fix":{"range":[1635,1706],"text":"type EffectsPanelProps = object"},"desc":"Replace empty interface with `object`."},{"messageId":"replaceEmptyInterface","data":{"replacement":"unknown"},"fix":{"range":[1635,1706],"text":"type EffectsPanelProps = unknown"},"desc":"Replace empty interface with `unknown`."}]},{"ruleId":"no-empty-pattern","severity":2,"message":"Unexpected empty object pattern.","line":52,"column":30,"nodeType":"ObjectPattern","messageId":"unexpected","endLine":52,"endColumn":51}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * EffectsPanel - Main overlay panel for effects system\n * \n * Features:\n * - Fixed right-side overlay with slide animation\n * - Header with effect name and close button\n * - Scrollable content area for effect-specific controls\n * - Footer with Apply to Timeline toggle and Apply/Cancel buttons\n * - Follows MediaImportPanel and GradientPanel patterns exactly\n */\n\nimport { useEffect, useMemo, useState } from 'react';\nimport { Button } from '../ui/button';\nimport { ScrollArea } from '../ui/scroll-area';\nimport { Separator } from '../ui/separator';\nimport { Switch } from '../ui/switch';\nimport { useEffectsStore } from '../../stores/effectsStore';\nimport { useEffectsHistory } from '../../hooks/useEffectsHistory';\nimport { EFFECT_DEFINITIONS } from '../../constants/effectsDefaults';\nimport { PANEL_ANIMATION } from '../../constants';\nimport { cn } from '../../lib/utils';\nimport { LevelsEffectPanel } from './effects/LevelsEffectPanel';\nimport { HueSaturationEffectPanel } from './effects/HueSaturationEffectPanel';\nimport { RemapColorsEffectPanel } from './effects/RemapColorsEffectPanel';\nimport { RemapCharactersEffectPanel } from './effects/RemapCharactersEffectPanel';\nimport {\n  X,\n  BarChart3,\n  Palette,\n  RefreshCcw,\n  Type\n} from 'lucide-react';\n\n// Icon mapping for effect headers\nconst EFFECT_ICONS = {\n  'BarChart3': BarChart3,\n  'Palette': Palette,\n  'RefreshCcw': RefreshCcw,\n  'Type': Type\n} as const;\n\n// Parse Tailwind duration for animation timing\nconst parseTailwindDuration = (token: string): number | null => {\n  const match = token.match(/duration-(\\d+)/);\n  return match ? Number(match[1]) : null;\n};\n\ninterface EffectsPanelProps {\n  // No props needed - uses store state\n}\n\nexport function EffectsPanel({}: EffectsPanelProps) {\n  const { \n    isOpen, \n    activeEffect, \n    applyToTimeline,\n    setApplyToTimeline,\n    closeEffectPanel,\n    isAnalyzing\n  } = useEffectsStore();\n  \n  // Use history-aware effects hook\n  const { \n    applyEffectWithHistory, \n    canApplyEffect,\n    getEffectDescription \n  } = useEffectsHistory();\n\n  const animationDurationMs = useMemo(\n    () => parseTailwindDuration(PANEL_ANIMATION.DURATION) ?? 300,\n    []\n  );\n\n  // Animation state to handle transitions properly (from GradientPanel pattern)\n  const [shouldRender, setShouldRender] = useState(isOpen);\n  const [isAnimating, setIsAnimating] = useState(isOpen);\n\n  // Handle panel animation states\n  useEffect(() => {\n    if (isOpen) {\n      setShouldRender(true);\n      // Trigger animation on next frame to ensure DOM is ready\n      requestAnimationFrame(() => {\n        setIsAnimating(true);\n      });\n    } else if (shouldRender) {\n      // Only start exit animation if panel was previously rendered\n      setIsAnimating(false);\n      // Wait for animation to complete before removing from DOM\n      const timer = setTimeout(() => {\n        setShouldRender(false);\n      }, animationDurationMs);\n      return () => clearTimeout(timer);\n    }\n  }, [isOpen, shouldRender, animationDurationMs]);\n\n  // Get current effect definition\n  const currentEffectDef = activeEffect \n    ? EFFECT_DEFINITIONS.find(def => def.id === activeEffect)\n    : null;\n\n  // Get effect icon component\n  const EffectIconComponent = currentEffectDef \n    ? EFFECT_ICONS[currentEffectDef.icon as keyof typeof EFFECT_ICONS]\n    : null;\n\n  // Handle cancel - stop preview and close panel\n  const handleCancel = async () => {\n    const { stopPreview } = useEffectsStore.getState();\n    stopPreview();\n    closeEffectPanel();\n  };\n\n  // Handle apply effect\n  const handleApplyEffect = async () => {\n    if (!activeEffect) return;\n    \n    const success = await applyEffectWithHistory(activeEffect);\n    if (success) {\n      // Panel will close automatically via store\n      console.log(`${activeEffect} effect applied successfully with history tracking`);\n    } else {\n      console.error(`Failed to apply ${activeEffect} effect`);\n    }\n  };\n\n  // Don't render if panel should not be visible\n  if (!shouldRender) return null;\n\n  return (\n    <div className={cn(\n      \"fixed inset-y-0 right-0 w-80 bg-background border-l border-border shadow-lg z-50\",\n      \"flex flex-col overflow-hidden\",\n      PANEL_ANIMATION.TRANSITION,\n      isAnimating ? \"translate-x-0\" : \"translate-x-full\"\n    )}>\n      {/* Header */}\n      <div className=\"flex items-center justify-between p-3 border-b border-border\">\n        <h2 className=\"text-sm font-medium flex items-center gap-2\">\n          {EffectIconComponent && <EffectIconComponent className=\"w-3 h-3\" />}\n          {currentEffectDef?.name || 'Effect'}\n        </h2>\n        <Button\n          onClick={closeEffectPanel}\n          variant=\"ghost\"\n          size=\"sm\"\n          className=\"h-6 w-6 p-0\"\n        >\n          <X className=\"w-3 h-3\" />\n        </Button>\n      </div>\n\n      {/* Scrollable Content Area */}\n      <ScrollArea className=\"flex-1\">\n        <div className=\"p-3 space-y-3\" style={{ width: '296px', maxWidth: '296px' }}>\n          \n          {/* Effect-specific content will be rendered here */}\n          {activeEffect === 'levels' && (\n            <LevelsEffectPanel />\n          )}\n          \n          {activeEffect === 'hue-saturation' && (\n            <HueSaturationEffectPanel />\n          )}\n          \n          {activeEffect === 'remap-colors' && (\n            <RemapColorsEffectPanel />\n          )}\n          \n          {activeEffect === 'remap-characters' && (\n            <RemapCharactersEffectPanel />\n          )}\n          \n          {/* Analysis status */}\n          {isAnalyzing && (\n            <div className=\"flex items-center gap-2 text-xs text-muted-foreground animate-pulse\">\n              <div className=\"w-2 h-2 bg-primary rounded-full animate-pulse\" />\n              Analyzing canvas...\n            </div>\n          )}\n          \n        </div>\n      </ScrollArea>\n\n      {/* Footer */}\n      <div className=\"border-t border-border p-3 space-y-3\">\n        {/* Apply to Timeline Toggle */}\n        <div className=\"flex items-center justify-between\">\n          <label className=\"flex items-center gap-2 text-xs cursor-pointer\">\n            <Switch\n              checked={applyToTimeline}\n              onCheckedChange={setApplyToTimeline}\n            />\n            <span>Apply to entire timeline</span>\n          </label>\n        </div>\n        \n        <div className=\"text-xs text-muted-foreground\">\n          {applyToTimeline \n            ? 'Effect will be applied to all frames' \n            : 'Effect will be applied to current canvas only'\n          }\n        </div>\n        \n        <Separator className=\"-mx-3\" />\n        \n        {/* Action Buttons */}\n        <div className=\"flex gap-2\">\n          <Button\n            variant=\"outline\"\n            size=\"sm\"\n            onClick={handleCancel}\n            className=\"flex-1 h-8\"\n          >\n            Cancel\n          </Button>\n          <Button\n            variant=\"default\"\n            size=\"sm\"\n            onClick={handleApplyEffect}\n            disabled={!activeEffect || isAnalyzing || !canApplyEffect()}\n            className=\"flex-1 h-8\"\n            title={\n              !canApplyEffect() \n                ? 'No canvas data to apply effect to' \n                : `Apply ${getEffectDescription(activeEffect || 'levels')} effect`\n            }\n          >\n            Apply\n          </Button>\n        </div>\n      </div>\n    </div>\n  );\n}","usedDeprecatedRules":[]},{"filePath":"/Users/cameronfoxly/GitHubRepos/Ascii-Motion/src/components/features/EffectsSection.tsx","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":49,"column":33,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":49,"endColumn":36,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1238,1241],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1238,1241],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * EffectsSection - Collapsible effects section for the right panel\n * \n * Features:\n * - Collapsible section header with effects icon\n * - Effect buttons with icons and names\n * - Timeline toggle for applying effects to entire timeline\n * - Follows MainCharacterPaletteSection patterns exactly\n */\n\nimport { useState } from 'react';\nimport { Button } from '../ui/button';\nimport { \n  Collapsible,\n  CollapsibleContent,\n} from '../ui/collapsible';\nimport { CollapsibleHeader } from '../common/CollapsibleHeader';\nimport { useEffectsStore } from '../../stores/effectsStore';\nimport { EFFECT_DEFINITIONS } from '../../constants/effectsDefaults';\nimport { \n  Wand2,\n  BarChart3,\n  Palette,\n  RefreshCcw,\n  Type\n} from 'lucide-react';\n\n// Icon mapping for effect buttons\nconst EFFECT_ICONS = {\n  'BarChart3': BarChart3,\n  'Palette': Palette,\n  'RefreshCcw': RefreshCcw,\n  'Type': Type\n} as const;\n\ninterface EffectsSectionProps {\n  className?: string;\n}\n\nexport function EffectsSection({ className = '' }: EffectsSectionProps) {\n  const [isOpen, setIsOpen] = useState(false);\n  \n  const { \n    openEffectPanel, \n    isAnalyzing\n  } = useEffectsStore();\n\n  const handleEffectClick = (effectId: string) => {\n    openEffectPanel(effectId as any);\n  };\n\n  return (\n    <div className={`space-y-3 ${className}`}>\n      <Collapsible open={isOpen} onOpenChange={setIsOpen}>\n        <CollapsibleHeader isOpen={isOpen}>\n          <div className=\"flex items-center gap-2\">\n            <Wand2 className=\"w-4 h-4\" />\n            Effects\n          </div>\n        </CollapsibleHeader>\n        \n        <CollapsibleContent className=\"collapsible-content mt-2\">\n          <div className=\"space-y-3\">\n            {/* Effect Buttons */}\n            <div className=\"space-y-2\">\n              {EFFECT_DEFINITIONS.map(effect => {\n                const IconComponent = EFFECT_ICONS[effect.icon as keyof typeof EFFECT_ICONS];\n                \n                return (\n                  <Button\n                    key={effect.id}\n                    variant=\"outline\"\n                    size=\"sm\"\n                    onClick={() => handleEffectClick(effect.id)}\n                    disabled={isAnalyzing}\n                    className=\"w-full justify-start gap-2 h-8 text-xs\"\n                    title={effect.description}\n                  >\n                    {IconComponent && <IconComponent className=\"w-3 h-3\" />}\n                    {effect.name}\n                  </Button>\n                );\n              })}\n            </div>\n            \n            {/* Analysis Status */}\n            {isAnalyzing && (\n              <div className=\"text-xs text-muted-foreground animate-pulse\">\n                Analyzing canvas...\n              </div>\n            )}\n          </div>\n        </CollapsibleContent>\n      </Collapsible>\n    </div>\n  );\n}","usedDeprecatedRules":[]},{"filePath":"/Users/cameronfoxly/GitHubRepos/Ascii-Motion/src/components/features/EnhancedCharacterPicker.tsx","messages":[{"ruleId":"prefer-const","severity":2,"message":"'right' is never reassigned. Use 'const' instead.","line":161,"column":11,"nodeType":"Identifier","messageId":"useConst","endLine":161,"endColumn":16,"fix":{"range":[5582,5635],"text":"const right = window.innerWidth - triggerRect.left + 8;"}},{"ruleId":"prefer-const","severity":2,"message":"'right' is never reassigned. Use 'const' instead.","line":174,"column":11,"nodeType":"Identifier","messageId":"useConst","endLine":174,"endColumn":16,"fix":{"range":[6104,6157],"text":"const right = window.innerWidth - triggerRect.left + 8;"}}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":2,"fixableWarningCount":0,"source":"import React, { useState, useRef, useEffect, useCallback } from 'react';\nimport { createPortal } from 'react-dom';\nimport { Button } from '@/components/ui/button';\nimport { Card } from '@/components/ui/card';\nimport { Tooltip, TooltipContent, TooltipProvider, TooltipTrigger } from '@/components/ui/tooltip';\nimport { DraggableDialogBar } from '@/components/common/DraggableDialogBar';\nimport { CHARACTER_CATEGORIES } from '@/constants';\nimport { \n  Type, \n  Hash, \n  Grid3X3, \n  Square, \n  Navigation, \n  Triangle, \n  Sparkles,\n  Minus\n} from 'lucide-react';\n\ninterface EnhancedCharacterPickerProps {\n  isOpen: boolean;\n  onClose: () => void;\n  onSelectCharacter: (character: string) => void;\n  triggerRef: React.RefObject<HTMLElement | null>;\n  anchorPosition?: 'bottom-right' | 'left-slide' | 'left-bottom' | 'left-bottom-aligned' | 'gradient-panel';\n  initialValue?: string;\n  title?: string;\n}\n\nconst CATEGORY_ICONS = {\n  \"Basic Text\": Type,\n  \"Punctuation\": Minus,\n  \"Math/Symbols\": Hash,\n  \"Lines/Borders\": Grid3X3,\n  \"Blocks/Shading\": Square,\n  \"Arrows\": Navigation,\n  \"Geometric\": Triangle,\n  \"Special\": Sparkles\n};\n\nexport const EnhancedCharacterPicker: React.FC<EnhancedCharacterPickerProps> = ({\n  isOpen,\n  onClose,\n  onSelectCharacter,\n  triggerRef,\n  anchorPosition = 'left-slide',\n  initialValue = '',\n  title = 'Select Character'\n}) => {\n  const [selectedCategory, setSelectedCategory] = useState(\"Basic Text\");\n  const [positionOffset, setPositionOffset] = useState({ x: 0, y: 0 });\n  const [isDraggingDialog, setIsDraggingDialog] = useState(false);\n  const [hasBeenDragged, setHasBeenDragged] = useState(false);\n  const dragStartOffsetRef = useRef({ x: 0, y: 0 });\n  const pickerRef = useRef<HTMLDivElement>(null);\n\n  // Reset position offset and drag state when dialog opens\n  useEffect(() => {\n    if (isOpen) {\n      setPositionOffset({ x: 0, y: 0 });\n      setHasBeenDragged(false);\n    }\n  }, [isOpen]);\n\n  // Close picker when clicking outside\n  useEffect(() => {\n    const handleClickOutside = (event: MouseEvent) => {\n      if (\n        isOpen &&\n        pickerRef.current &&\n        !pickerRef.current.contains(event.target as Node) &&\n        triggerRef.current &&\n        !triggerRef.current.contains(event.target as Node)\n      ) {\n        onClose();\n      }\n    };\n\n    document.addEventListener('mousedown', handleClickOutside);\n    return () => document.removeEventListener('mousedown', handleClickOutside);\n  }, [isOpen, onClose, triggerRef]);\n\n  // Close picker on escape key\n  useEffect(() => {\n    const handleEscape = (event: KeyboardEvent) => {\n      if (event.key === 'Escape' && isOpen) {\n        onClose();\n      }\n    };\n\n    document.addEventListener('keydown', handleEscape);\n    return () => document.removeEventListener('keydown', handleEscape);\n  }, [isOpen, onClose]);\n\n  const handleCharacterSelect = (character: string) => {\n    onSelectCharacter(character);\n    onClose();\n  };\n  \n  // Handler for dragging the dialog\n  const handleDrag = useCallback((deltaX: number, deltaY: number) => {\n    // Add the drag delta to the stored offset from when drag started\n    setPositionOffset({\n      x: dragStartOffsetRef.current.x + deltaX,\n      y: dragStartOffsetRef.current.y + deltaY\n    });\n  }, []);\n  \n  // Track dialog drag state for animation control\n  const handleDragStart = useCallback(() => {\n    setIsDraggingDialog(true);\n    setHasBeenDragged(true);\n    // Store the current offset when drag starts\n    dragStartOffsetRef.current = { ...positionOffset };\n  }, [positionOffset]);\n  \n  const handleDragEnd = useCallback(() => {\n    setIsDraggingDialog(false);\n    // Update the ref with the final position\n    dragStartOffsetRef.current = { ...positionOffset };\n  }, [positionOffset]);\n\n  // Position calculation with support for all existing anchor positions\n  const getPickerPosition = () => {\n    if (!triggerRef.current) return { top: 0, right: 0, left: 0 };\n    \n    const triggerRect = triggerRef.current.getBoundingClientRect();\n    const pickerWidth = 400; // Enhanced width for better breathing room\n    const pickerHeight = 500; // Enhanced height for better visual hierarchy\n    \n    if (anchorPosition === 'gradient-panel') {\n      // Center the picker vertically in the viewport (from GradientStopPicker)\n      const viewportHeight = window.innerHeight;\n      const top = Math.max(8, (viewportHeight - pickerHeight) / 2 + window.scrollY);\n      \n      // Position to the left of the gradient panel (which is 320px wide and on the right side)\n      const gradientPanelWidth = 320;\n      const left = window.innerWidth - gradientPanelWidth - pickerWidth - 16; // 16px gap\n      \n      return {\n        top,\n        left: Math.max(8, left), // Ensure it doesn't go off-screen\n        right: 'auto'\n      };\n    } else if (anchorPosition === 'bottom-right') {\n      // Anchor bottom-right corner of picker to the trigger element\n      let top = triggerRect.bottom + window.scrollY - pickerHeight - 8; // 8px gap above trigger\n      let left = triggerRect.right - pickerWidth + window.scrollX;\n      \n      // Ensure picker doesn't go off-screen\n      if (left < 0) left = 8; // 8px margin from left edge\n      if (top < window.scrollY) top = triggerRect.bottom + window.scrollY + 8; // Show below if no room above\n      \n      return {\n        top,\n        left,\n        right: 'auto'\n      };\n    } else if (anchorPosition === 'left-bottom') {\n      // Anchor bottom-right corner of picker to the left side of trigger, with bottom alignment\n      let top = triggerRect.bottom + window.scrollY - pickerHeight;\n      let right = window.innerWidth - triggerRect.left + 8; // 8px gap from trigger\n      \n      // Ensure picker doesn't go off-screen vertically\n      if (top < window.scrollY) top = window.scrollY + 8; // 8px margin from top\n      \n      return {\n        top,\n        right,\n        left: 'auto'\n      };\n    } else if (anchorPosition === 'left-bottom-aligned') {\n      // Align bottom of picker with bottom of trigger element, positioned to the left\n      let top = triggerRect.bottom + window.scrollY - pickerHeight;\n      let right = window.innerWidth - triggerRect.left + 8; // 8px gap from trigger\n      \n      // Ensure picker doesn't go off-screen vertically\n      if (top < window.scrollY) top = window.scrollY + 8; // 8px margin from top\n      \n      return {\n        top,\n        right,\n        left: 'auto'\n      };\n    } else {\n      // Default left-slide behavior (for edit button from palette container)\n      return {\n        top: triggerRect.top + window.scrollY,\n        right: window.innerWidth - triggerRect.left + 8, // 8px gap from trigger\n        left: 'auto'\n      };\n    }\n  };\n\n  if (!isOpen) return null;\n\n  const position = getPickerPosition();\n\n  return createPortal(\n    <div\n      ref={pickerRef}\n      className={`fixed z-[99999] ${\n        !hasBeenDragged ? `animate-in duration-200 ${\n          anchorPosition === 'bottom-right' ? 'slide-in-from-bottom-2 fade-in-0' : 'slide-in-from-right-2 fade-in-0'\n        }` : ''\n      }`}\n      style={{\n        top: position.top + positionOffset.y,\n        right: position.right !== 'auto' && typeof position.right === 'number' ? position.right - positionOffset.x : undefined,\n        left: position.left !== 'auto' && typeof position.left === 'number' ? position.left + positionOffset.x : undefined,\n        maxWidth: '400px',\n        width: '400px',\n        transition: isDraggingDialog ? 'none' : undefined\n      }}\n      onMouseDown={(e) => e.stopPropagation()}\n      onClick={(e) => e.stopPropagation()}\n    >\n      <Card className=\"border border-border/50 shadow-lg\">\n        <DraggableDialogBar \n          title={title} \n          onDrag={handleDrag}\n          onDragStart={handleDragStart}\n          onDragEnd={handleDragEnd}\n          onClose={onClose}\n        />\n        <div className=\"p-4 pt-2\">\n          \n          <div className=\"space-y-4\">\n            {/* Category Selection - Enhanced 4-column grid with icons */}\n            <div className=\"grid grid-cols-4 gap-2\">\n              {Object.entries(CHARACTER_CATEGORIES).map(([category]) => {\n                const Icon = CATEGORY_ICONS[category as keyof typeof CATEGORY_ICONS] || Type;\n                return (\n                  <Button\n                    key={category}\n                    variant={selectedCategory === category ? \"default\" : \"outline\"}\n                    className=\"h-12 flex flex-col items-center gap-1 text-xs\"\n                    onClick={() => setSelectedCategory(category)}\n                  >\n                    <Icon className=\"w-4 h-4\" />\n                    <span className=\"text-xs leading-none\">{category.split('/')[0]}</span>\n                  </Button>\n                );\n              })}\n            </div>\n            \n            {/* Character Grid - Enhanced 8-column grid for better spacing */}\n            <div className=\"max-h-60 overflow-y-auto\">\n              <div className=\"grid grid-cols-8 gap-1 p-2 border border-border rounded bg-muted/30\">\n                <TooltipProvider>\n                  {CHARACTER_CATEGORIES[selectedCategory as keyof typeof CHARACTER_CATEGORIES]?.map((char, index) => (\n                    <Tooltip key={index}>\n                      <TooltipTrigger asChild>\n                        <Button\n                          variant={initialValue === char ? \"default\" : \"ghost\"}\n                          className=\"h-8 w-8 p-0 font-mono text-sm hover:bg-accent hover:text-accent-foreground flex items-center justify-center\"\n                          onClick={() => handleCharacterSelect(char)}\n                        >\n                          {char}\n                        </Button>\n                      </TooltipTrigger>\n                      <TooltipContent>\n                        <p>Insert \"{char}\"</p>\n                      </TooltipContent>\n                    </Tooltip>\n                  ))}\n                </TooltipProvider>\n              </div>\n            </div>\n          </div>\n        </div>\n      </Card>\n    </div>,\n    document.body\n  );\n};","usedDeprecatedRules":[]},{"filePath":"/Users/cameronfoxly/GitHubRepos/Ascii-Motion/src/components/features/ExportCharacterPaletteDialog.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/cameronfoxly/GitHubRepos/Ascii-Motion/src/components/features/ExportImportButtons.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/cameronfoxly/GitHubRepos/Ascii-Motion/src/components/features/ExportPaletteDialog.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/cameronfoxly/GitHubRepos/Ascii-Motion/src/components/features/ForegroundBackgroundSelector.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/cameronfoxly/GitHubRepos/Ascii-Motion/src/components/features/FrameControls.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/cameronfoxly/GitHubRepos/Ascii-Motion/src/components/features/FrameThumbnail.tsx","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":22,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":22,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[854,857],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[854,857],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useState, useMemo } from 'react';\nimport { Badge } from '../ui/badge';\nimport { Button } from '../ui/button';\nimport { Card } from '../ui/card';\nimport type { Frame } from '../../types';\nimport { X, Copy } from 'lucide-react';\nimport { useCanvasStore } from '../../stores/canvasStore';\n\ninterface FrameThumbnailProps {\n  frame: Frame;\n  frameIndex: number;\n  isActive: boolean;      // Is this the active frame (displayed on canvas)?\n  isSelected: boolean;    // Is this frame in the selection?\n  canvasWidth: number;\n  canvasHeight: number;\n  scaleZoom?: number; // Timeline zoom scaling (0.5 to 1.0)\n  onSelect: (event: React.MouseEvent) => void; // Now passes event for shift-click detection\n  onDuplicate: () => void;\n  onDelete: () => void;\n  onDurationChange: (duration: number) => void;\n  isDragging?: boolean;\n  dragHandleProps?: any;\n  // Onion skin props\n  isOnionSkinPrevious?: boolean;\n  isOnionSkinNext?: boolean;\n  onionSkinDistance?: number;\n}\n\n/**\n * Individual frame thumbnail component with ASCII preview\n * Renders a miniaturized version of the frame's ASCII art\n */\nexport const FrameThumbnail: React.FC<FrameThumbnailProps> = ({\n  frame,\n  frameIndex,\n  isActive,\n  isSelected,\n  canvasWidth,\n  canvasHeight,\n  scaleZoom = 1.0,\n  onSelect,\n  onDuplicate,\n  onDelete,\n  onDurationChange,\n  isDragging = false,\n  dragHandleProps,\n  isOnionSkinPrevious = false,\n  isOnionSkinNext = false,\n  onionSkinDistance = 0\n}) => {\n  // Local state for duration input to allow free typing\n  const [durationInput, setDurationInput] = useState(frame.duration.toString());\n  const [isEditingDuration, setIsEditingDuration] = useState(false);\n  \n  // Get canvas background color from store\n  const { canvasBackgroundColor } = useCanvasStore();\n  \n  // Calculate scaled dimensions based on timeline zoom\n  const baseCardSize = 144; // w-36 = 144px\n  const scaledCardSize = Math.round(baseCardSize * scaleZoom);\n  \n\n  \n  // Scale thumbnail proportionally but ensure it fits in the card\n  const baseThumbnailWidth = 120;\n  const baseThumbnailHeight = 60;\n  const maxThumbnailWidth = scaledCardSize - 16; // account for padding\n  \n  // Scale thumbnail to fit within the available space\n  let scaledThumbnailWidth = Math.round(baseThumbnailWidth * scaleZoom);\n  let scaledThumbnailHeight = Math.round(baseThumbnailHeight * scaleZoom);\n  \n  // Ensure thumbnail fits within the card\n  if (scaledThumbnailWidth > maxThumbnailWidth) {\n    const scale = maxThumbnailWidth / scaledThumbnailWidth;\n    scaledThumbnailWidth = maxThumbnailWidth;\n    scaledThumbnailHeight = Math.round(scaledThumbnailHeight * scale);\n  }\n  \n  // Ensure minimum thumbnail size for readability\n  if (scaledThumbnailHeight < 30) {\n    scaledThumbnailHeight = 30; \n    scaledThumbnailWidth = Math.round(scaledThumbnailHeight * (baseThumbnailWidth / baseThumbnailHeight));\n  }\n  \n\n  \n  // Update local input when frame duration changes externally\n  React.useEffect(() => {\n    if (!isEditingDuration) {\n      setDurationInput(frame.duration.toString());\n    }\n  }, [frame.duration, isEditingDuration]);\n\n  // Generate pixel-based thumbnail canvas\n  const thumbnailCanvas = useMemo(() => {\n    const canvas = document.createElement('canvas');\n    const ctx = canvas.getContext('2d');\n    if (!ctx) return null;\n\n    // Set thumbnail dimensions (scaled based on timeline zoom)\n    const thumbnailWidth = scaledThumbnailWidth;\n    const thumbnailHeight = scaledThumbnailHeight;\n    canvas.width = thumbnailWidth;\n    canvas.height = thumbnailHeight;\n\n    // Calculate scaling factors\n    const scaleX = thumbnailWidth / canvasWidth;\n    const scaleY = thumbnailHeight / canvasHeight;\n    const cellWidth = Math.max(1, scaleX);\n    const cellHeight = Math.max(1, scaleY);\n\n    // Use canvas background color instead of hardcoded color\n    ctx.fillStyle = canvasBackgroundColor || '#1a1a1a';\n    ctx.fillRect(0, 0, thumbnailWidth, thumbnailHeight);\n\n    // If frame is empty, show a subtle grid pattern\n    if (frame.data.size === 0) {\n      ctx.strokeStyle = '#333333';\n      ctx.lineWidth = 0.5;\n      const gridSpacing = 8;\n      \n      // Draw vertical lines\n      for (let x = 0; x < thumbnailWidth; x += gridSpacing) {\n        ctx.beginPath();\n        ctx.moveTo(x, 0);\n        ctx.lineTo(x, thumbnailHeight);\n        ctx.stroke();\n      }\n      \n      // Draw horizontal lines\n      for (let y = 0; y < thumbnailHeight; y += gridSpacing) {\n        ctx.beginPath();\n        ctx.moveTo(0, y);\n        ctx.lineTo(thumbnailWidth, y);\n        ctx.stroke();\n      }\n      \n      return canvas.toDataURL();\n    }\n\n    // Render each cell as a colored rectangle\n    for (const [key, cell] of frame.data) {\n      const coords = key.split(',').map(Number);\n      const x = coords[0];\n      const y = coords[1];\n\n      if (x >= 0 && x < canvasWidth && y >= 0 && y < canvasHeight) {\n        // Calculate pixel position in thumbnail\n        const pixelX = Math.floor(x * scaleX);\n        const pixelY = Math.floor(y * scaleY);\n\n        // Use character color (foreground) primarily, fallback to background, then white\n        const color = cell.color || cell.bgColor || '#ffffff';\n        ctx.fillStyle = color;\n        ctx.fillRect(pixelX, pixelY, Math.ceil(cellWidth), Math.ceil(cellHeight));\n      }\n    }\n\n    return canvas.toDataURL();\n  }, [frame.data, canvasWidth, canvasHeight, canvasBackgroundColor, scaledThumbnailWidth, scaledThumbnailHeight]);\n\n  // Handle duration input change (allow free typing)\n  const handleDurationInputChange = (event: React.ChangeEvent<HTMLInputElement>) => {\n    setDurationInput(event.target.value);\n  };\n\n  // Handle duration input focus (start editing)\n  const handleDurationFocus = () => {\n    setIsEditingDuration(true);\n  };\n\n  // Handle duration input blur (validate and commit)\n  const handleDurationBlur = () => {\n    setIsEditingDuration(false);\n    const parsedDuration = parseInt(durationInput);\n    \n    if (isNaN(parsedDuration) || parsedDuration < 50) {\n      // Invalid input, reset to minimum and update store\n      setDurationInput('50');\n      onDurationChange(50);\n    } else if (parsedDuration > 10000) {\n      // Exceeds maximum, clamp and update store\n      setDurationInput('10000');\n      onDurationChange(10000);\n    } else {\n      // Valid input, update store\n      onDurationChange(parsedDuration);\n    }\n  };\n\n  // Handle Enter and Tab keys to commit changes\n  const handleDurationKeyDown = (event: React.KeyboardEvent<HTMLInputElement>) => {\n    if (event.key === 'Enter' || event.key === 'Tab') {\n      // For Tab, we let the default behavior happen but ensure blur occurs first\n      if (event.key === 'Enter') {\n        event.preventDefault(); // Prevent form submission\n      }\n      event.currentTarget.blur(); // Trigger blur event to commit changes\n    }\n  };\n\n  // Handle mouse down on duration input to prevent drag initiation\n  const handleDurationMouseDown = (event: React.MouseEvent<HTMLInputElement>) => {\n    // Stop propagation to prevent drag handlers from being triggered\n    event.stopPropagation();\n  };\n\n  // Handle mouse enter on duration input to disable dragging\n  const handleDurationMouseEnter = () => {\n    // Disable dragging on the parent card when mouse is over the input\n    const parentCard = document.querySelector(`[data-frame-index=\"${frameIndex}\"]`) as HTMLElement;\n    if (parentCard) {\n      parentCard.draggable = false;\n    }\n  };\n\n  // Handle mouse leave on duration input to re-enable dragging\n  const handleDurationMouseLeave = () => {\n    // Re-enable dragging on the parent card when mouse leaves the input\n    const parentCard = document.querySelector(`[data-frame-index=\"${frameIndex}\"]`) as HTMLElement;\n    if (parentCard) {\n      parentCard.draggable = true;\n    }\n  };\n\n  // Calculate frame card border styling based on state\n  const getBorderStyle = () => {\n    if (isDragging) {\n      return 'border-primary/50 bg-primary/10';\n    }\n    \n    if (isActive) {\n      // Active frame: Full white border\n      return 'border-white bg-white/5';\n    }\n    \n    if (isSelected) {\n      // Selected but not active: Dimmer white border (60% opacity)\n      return 'border-white/60 bg-white/5';\n    }\n    \n    // Unselected: Default border\n    return 'border-border hover:border-primary/50';\n  };\n\n  // Onion skin indicator on canvas preview box (not card border)\n  const getCanvasPreviewBorder = () => {\n    if (isOnionSkinPrevious) {\n      return 'border-purple-500/60';\n    }\n    if (isOnionSkinNext) {\n      return 'border-red-500/60';\n    }\n    return 'border-border';\n  };\n\n  return (\n    <Card\n      className={`\n        relative flex-shrink-0 cursor-pointer transition-all duration-150 ease-out select-none overflow-hidden flex flex-col\n        ${getBorderStyle()}\n        ${isDragging ? 'opacity-50 scale-95' : ''}\n      `}\n      onClick={(e) => onSelect(e)} // Pass event to parent\n      {...dragHandleProps}\n      data-frame-index={frameIndex}\n      style={{\n        width: `${scaledCardSize}px`,\n        height: `${scaledCardSize}px`,\n        maxWidth: `${scaledCardSize}px`,\n        maxHeight: `${scaledCardSize}px`,\n        padding: '8px', // Fixed padding\n        userSelect: 'none',\n        WebkitUserSelect: 'none',\n        MozUserSelect: 'none',\n        msUserSelect: 'none',\n        ...dragHandleProps?.style\n      }}\n    >\n      {/* Frame number and controls - pinned to top */}\n      <div className=\"flex items-center justify-between mb-1.5 flex-shrink-0\">\n        <div className=\"flex items-center gap-1\">\n          <Badge variant=\"outline\" className=\"text-xs px-1 py-0\">\n            {frameIndex + 1}\n          </Badge>\n          \n          {/* Onion skin distance indicator */}\n          {(isOnionSkinPrevious || isOnionSkinNext) && onionSkinDistance > 0 && (\n            <Badge \n              variant=\"outline\" \n              className={`text-xs px-1 py-0 ${\n                isOnionSkinPrevious \n                  ? 'border-purple-500 text-purple-600' \n                  : 'border-red-500 text-red-600'\n              }`}\n            >\n              -{onionSkinDistance}\n            </Badge>\n          )}\n        </div>\n        \n        <div className=\"flex gap-1\">\n          <Button\n            size=\"sm\"\n            variant=\"ghost\"\n            className=\"h-5 w-5 p-0\"\n            tabIndex={-1} // Remove from tab order - tab should skip to next frame's duration input\n            onClick={(e) => {\n              e.stopPropagation();\n              onDuplicate();\n            }}\n          >\n            <Copy className=\"h-3 w-3\" />\n          </Button>\n          \n          <Button\n            size=\"sm\"\n            variant=\"ghost\"\n            className=\"h-5 w-5 p-0 text-destructive hover:text-destructive\"\n            tabIndex={-1} // Remove from tab order - tab should skip to next frame's duration input\n            onClick={(e) => {\n              e.stopPropagation();\n              onDelete();\n            }}\n          >\n            <X className=\"h-3 w-3\" />\n          </Button>\n        </div>\n      </div>\n\n      {/* Frame preview - flexible space between header and duration */}\n      <div className=\"flex-1 mb-1 overflow-hidden min-h-0\">\n        <div className={`bg-muted/30 p-1 rounded border h-full flex items-center justify-center ${getCanvasPreviewBorder()}`}>\n          {thumbnailCanvas ? (\n            <img \n              src={thumbnailCanvas} \n              alt={`Frame ${frameIndex} preview`}\n              className=\"max-w-full max-h-full object-contain rounded-sm pointer-events-none\"\n              style={{ imageRendering: 'pixelated' }}\n            />\n          ) : (\n            <div className=\"text-muted-foreground italic text-center text-xs pointer-events-none\">\n              Empty\n            </div>\n          )}\n        </div>\n      </div>\n\n      {/* Duration control - pinned to bottom with fixed height */}\n      <div className=\"flex items-center gap-1 flex-shrink-0\" style={{ height: '24px' }}>\n        <input\n          type=\"number\"\n          value={durationInput}\n          onChange={handleDurationInputChange}\n          onFocus={handleDurationFocus}\n          onBlur={handleDurationBlur}\n          onKeyDown={handleDurationKeyDown}\n          onMouseDown={handleDurationMouseDown}\n          onMouseEnter={handleDurationMouseEnter}\n          onMouseLeave={handleDurationMouseLeave}\n          onClick={(e) => e.stopPropagation()}\n          tabIndex={frameIndex + 1} // Sequential tab order: frame 0 = tabIndex 1, frame 1 = tabIndex 2, etc.\n          className=\"flex-1 text-xs px-1 py-0.5 border border-border rounded w-12 bg-background\"\n          min=\"50\"\n          max=\"10000\"\n          step=\"10\"\n        />\n        <span className=\"text-xs text-muted-foreground\">ms</span>\n      </div>\n    </Card>\n  );\n};\n","usedDeprecatedRules":[]},{"filePath":"/Users/cameronfoxly/GitHubRepos/Ascii-Motion/src/components/features/FullscreenToggle.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/cameronfoxly/GitHubRepos/Ascii-Motion/src/components/features/GradientPanel.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/cameronfoxly/GitHubRepos/Ascii-Motion/src/components/features/GradientPropertyPreview.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/cameronfoxly/GitHubRepos/Ascii-Motion/src/components/features/GradientStopPicker.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/cameronfoxly/GitHubRepos/Ascii-Motion/src/components/features/HamburgerMenu.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/cameronfoxly/GitHubRepos/Ascii-Motion/src/components/features/HtmlExportDialog.tsx","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":66,"column":71,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":66,"endColumn":74,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2373,2376],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2373,2376],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useState } from 'react';\nimport { Dialog, DialogContent, DialogHeader, DialogTitle } from '../ui/dialog';\nimport { Button } from '../ui/button';\nimport { Input } from '../ui/input';\nimport { Label } from '../ui/label';\nimport { Card, CardContent } from '../ui/card';\nimport { Badge } from '../ui/badge';\nimport { Switch } from '../ui/switch';\nimport { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '../ui/select';\nimport { Globe, Download, Loader2, Palette, Type } from 'lucide-react';\nimport { useExportStore } from '../../stores/exportStore';\nimport { useExportDataCollector } from '../../utils/exportDataCollector';\nimport { ExportRenderer } from '../../utils/exportRenderer';\n\n/**\n * HTML Export Dialog\n * Handles HTML animation export with customization options\n */\nexport const HtmlExportDialog: React.FC = () => {\n  const activeFormat = useExportStore(state => state.activeFormat);\n  const showExportModal = useExportStore(state => state.showExportModal);\n  const setShowExportModal = useExportStore(state => state.setShowExportModal);\n  const htmlSettings = useExportStore(state => state.htmlSettings);\n  const setHtmlSettings = useExportStore(state => state.setHtmlSettings);\n  const setProgress = useExportStore(state => state.setProgress);\n  const setIsExporting = useExportStore(state => state.setIsExporting);\n  const isExporting = useExportStore(state => state.isExporting);\n  \n  const exportData = useExportDataCollector();\n\n  const [filename, setFilename] = useState('ascii-motion-animation');\n\n  const isOpen = showExportModal && activeFormat === 'html';\n\n  const handleClose = () => {\n    setShowExportModal(false);\n  };\n\n  const handleExport = async () => {\n    if (!exportData) {\n      console.error('No export data available');\n      return;\n    }\n\n    try {\n      setIsExporting(true);\n\n      // Create renderer with progress callback\n      const renderer = new ExportRenderer((progress) => {\n        setProgress(progress);\n      });\n\n      // Perform the export\n      await renderer.exportHtml(exportData, htmlSettings, filename);\n\n      // Close dialog on success\n      handleClose();\n    } catch (error) {\n      console.error('HTML export failed:', error);\n    } finally {\n      setIsExporting(false);\n      setProgress(null);\n    }\n  };\n\n  const handleSettingChange = (key: keyof typeof htmlSettings, value: any) => {\n    setHtmlSettings({ [key]: value });\n  };\n\n  return (\n    <Dialog open={isOpen} onOpenChange={setShowExportModal}>\n      <DialogContent className=\"max-w-lg p-0 overflow-hidden\">\n        <DialogHeader className=\"px-6 pt-6 pb-4 border-b bg-background\">\n          <DialogTitle className=\"flex items-center gap-2\">\n            <Globe className=\"w-5 h-5\" />\n            Export HTML Animation\n          </DialogTitle>\n        </DialogHeader>\n\n        <div className=\"flex flex-col max-h-[80vh]\">\n          {/* Sticky File Name Input */}\n          <div className=\"sticky top-0 z-10 bg-background px-6 py-4 border-b space-y-2\">\n            <Label htmlFor=\"filename\">File Name</Label>\n            <div className=\"flex\">\n              <Input\n                id=\"filename\"\n                value={filename}\n                onChange={(e) => setFilename(e.target.value)}\n                placeholder=\"Enter filename\"\n                className=\"flex-1\"\n                disabled={isExporting}\n              />\n              <Badge variant=\"outline\" className=\"ml-2 self-center\">\n                .html\n              </Badge>\n            </div>\n          </div>\n\n          {/* Scrollable Settings */}\n          <div className=\"flex-1 overflow-y-auto px-6 py-4 space-y-4\">\n            {/* Appearance Settings */}\n            <Card>\n              <CardContent className=\"pt-4 space-y-4\">\n                <div className=\"flex items-center gap-2\">\n                  <Palette className=\"w-4 h-4\" />\n                  <Label className=\"text-sm font-medium\">Appearance Settings</Label>\n                </div>\n\n                {/* Background Color */}\n                <div className=\"space-y-2\">\n                  <Label className=\"text-sm\">Background Color</Label>\n                  <div className=\"flex gap-2\">\n                    <Input\n                      type=\"color\"\n                      value={htmlSettings.backgroundColor}\n                      onChange={(e) => handleSettingChange('backgroundColor', e.target.value)}\n                      className=\"w-12 h-8 p-0 border-0\"\n                      disabled={isExporting}\n                    />\n                    <Input\n                      type=\"text\"\n                      value={htmlSettings.backgroundColor}\n                      onChange={(e) => handleSettingChange('backgroundColor', e.target.value)}\n                      className=\"flex-1 font-mono text-sm\"\n                      disabled={isExporting}\n                    />\n                  </div>\n                </div>\n\n                {/* Font Settings */}\n                <div className=\"grid grid-cols-2 gap-4\">\n                  <div className=\"space-y-2\">\n                    <Label className=\"text-sm\">Font Family</Label>\n                    <Select\n                      value={htmlSettings.fontFamily}\n                      onValueChange={(value) => handleSettingChange('fontFamily', value)}\n                      disabled={isExporting}\n                    >\n                      <SelectTrigger>\n                        <SelectValue />\n                      </SelectTrigger>\n                      <SelectContent>\n                        <SelectItem value=\"monospace\">Monospace</SelectItem>\n                        <SelectItem value=\"courier\">Courier New</SelectItem>\n                        <SelectItem value=\"consolas\">Consolas</SelectItem>\n                      </SelectContent>\n                    </Select>\n                  </div>\n\n                  <div className=\"space-y-2\">\n                    <Label className=\"text-sm\">Font Size (px)</Label>\n                    <Select\n                      value={htmlSettings.fontSize.toString()}\n                      onValueChange={(value) => handleSettingChange('fontSize', parseInt(value))}\n                      disabled={isExporting}\n                    >\n                      <SelectTrigger>\n                        <SelectValue />\n                      </SelectTrigger>\n                      <SelectContent>\n                        <SelectItem value=\"10\">10px</SelectItem>\n                        <SelectItem value=\"12\">12px</SelectItem>\n                        <SelectItem value=\"14\">14px</SelectItem>\n                        <SelectItem value=\"16\">16px</SelectItem>\n                        <SelectItem value=\"18\">18px</SelectItem>\n                        <SelectItem value=\"20\">20px</SelectItem>\n                        <SelectItem value=\"24\">24px</SelectItem>\n                      </SelectContent>\n                    </Select>\n                  </div>\n                </div>\n              </CardContent>\n            </Card>\n\n            {/* Additional Options */}\n            <Card>\n              <CardContent className=\"pt-4 space-y-4\">\n                <div className=\"flex items-center gap-2\">\n                  <Type className=\"w-4 h-4\" />\n                  <Label className=\"text-sm font-medium\">Additional Options</Label>\n                </div>\n\n                {/* Include Metadata */}\n                <div className=\"flex items-center justify-between\">\n                  <div className=\"space-y-1\">\n                    <Label className=\"text-sm\">Include Project Info</Label>\n                    <p className=\"text-xs text-muted-foreground\">\n                      Show frame count, duration, and export date\n                    </p>\n                  </div>\n                  <Switch\n                    checked={htmlSettings.includeMetadata}\n                    onCheckedChange={(checked) => handleSettingChange('includeMetadata', checked)}\n                    disabled={isExporting}\n                  />\n                </div>\n              </CardContent>\n            </Card>\n\n            {/* Info Card */}\n            <Card className=\"bg-muted/50\">\n              <CardContent className=\"pt-4\">\n                <div className=\"text-xs text-muted-foreground\">\n                  <div className=\"font-medium mb-2\">HTML Export Features:</div>\n                  <ul className=\"space-y-1\">\n                    <li>• Standalone HTML file with no external dependencies</li>\n                    <li>• Built-in play/pause controls and speed adjustment</li>\n                    <li>• Preserves all character colors and backgrounds</li>\n                    <li>• Works in any modern web browser</li>\n                  </ul>\n                </div>\n              </CardContent>\n            </Card>\n          </div>\n\n          {/* Sticky Action Buttons */}\n          <div className=\"sticky bottom-0 z-10 bg-background px-6 py-4 border-t flex justify-end gap-2\">\n            <Button variant=\"outline\" onClick={handleClose} disabled={isExporting}>\n              Cancel\n            </Button>\n            <Button onClick={handleExport} disabled={isExporting || !filename.trim()}>\n              {isExporting ? (\n                <>\n                  <Loader2 className=\"w-4 h-4 mr-2 animate-spin\" />\n                  Exporting...\n                </>\n              ) : (\n                <>\n                  <Download className=\"w-4 h-4 mr-2\" />\n                  Export HTML\n                </>\n              )}\n            </Button>\n          </div>\n        </div>\n      </DialogContent>\n    </Dialog>\n  );\n};","usedDeprecatedRules":[]},{"filePath":"/Users/cameronfoxly/GitHubRepos/Ascii-Motion/src/components/features/ImageExportDialog.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/cameronfoxly/GitHubRepos/Ascii-Motion/src/components/features/ImportCharacterPaletteDialog.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/cameronfoxly/GitHubRepos/Ascii-Motion/src/components/features/ImportModal.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/cameronfoxly/GitHubRepos/Ascii-Motion/src/components/features/ImportPaletteDialog.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'error' is defined but never used.","line":87,"column":14,"nodeType":null,"messageId":"unusedVar","endLine":87,"endColumn":19}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// Import palette dialog with JSON validation and preview\n\nimport React, { useState, useCallback } from 'react';\nimport { Dialog, DialogContent, DialogHeader, DialogTitle, DialogFooter } from '@/components/ui/dialog';\nimport { Button } from '@/components/ui/button';\nimport { Input } from '@/components/ui/input';\nimport { Label } from '@/components/ui/label';\nimport { Separator } from '@/components/ui/separator';\nimport { Alert, AlertDescription } from '@/components/ui/alert';\nimport { Tooltip, TooltipContent, TooltipProvider, TooltipTrigger } from '@/components/ui/tooltip';\nimport { Upload, FileText, AlertCircle, CheckCircle, X } from 'lucide-react';\nimport { usePaletteStore } from '../../stores/paletteStore';\nimport { validatePaletteJSON, getValidationSummary } from '../../utils/paletteValidation';\nimport type { PaletteExportFormat } from '../../types/palette';\n\ninterface ImportPaletteDialogProps {\n  isOpen: boolean;\n  onOpenChange: (open: boolean) => void;\n}\n\nexport const ImportPaletteDialog: React.FC<ImportPaletteDialogProps> = ({\n  isOpen,\n  onOpenChange\n}) => {\n  const { importPalette } = usePaletteStore();\n  \n  const [importMethod, setImportMethod] = useState<'file' | 'text'>('file');\n  const [jsonText, setJsonText] = useState('');\n  const [validationResult, setValidationResult] = useState<ReturnType<typeof validatePaletteJSON> | null>(null);\n  const [previewData, setPreviewData] = useState<PaletteExportFormat | null>(null);\n  const [isImporting, setIsImporting] = useState(false);\n  const [importSuccess, setImportSuccess] = useState<string | null>(null);\n\n  // Handle file upload\n  const handleFileUpload = useCallback((event: React.ChangeEvent<HTMLInputElement>) => {\n    const file = event.target.files?.[0];\n    if (!file) return;\n\n    const reader = new FileReader();\n    reader.onload = (e) => {\n      const content = e.target?.result as string;\n      setJsonText(content);\n      validateAndPreview(content);\n    };\n    reader.readAsText(file);\n  }, []);\n\n  // Handle text input change\n  const handleTextChange = (value: string) => {\n    setJsonText(value);\n    if (value.trim()) {\n      validateAndPreview(value);\n    } else {\n      setValidationResult(null);\n      setPreviewData(null);\n    }\n  };\n\n  // Validate JSON and show preview\n  const validateAndPreview = (jsonString: string) => {\n    const result = validatePaletteJSON(jsonString);\n    setValidationResult(result);\n    setPreviewData(result.isValid ? result.data || null : null);\n  };\n\n  // Handle import confirmation\n  const handleImport = async () => {\n    if (!jsonText.trim() || !validationResult?.isValid) return;\n\n    setIsImporting(true);\n    try {\n      const result = importPalette(jsonText);\n      if (result.success) {\n        setImportSuccess(result.message);\n        // Clear form after successful import\n        setTimeout(() => {\n          handleReset();\n          onOpenChange(false);\n        }, 2000);\n      } else {\n        setValidationResult({\n          isValid: false,\n          errors: [result.message],\n          warnings: []\n        });\n      }\n    } catch (error) {\n      setValidationResult({\n        isValid: false,\n        errors: ['An unexpected error occurred during import.'],\n        warnings: []\n      });\n    } finally {\n      setIsImporting(false);\n    }\n  };\n\n  // Reset form\n  const handleReset = () => {\n    setJsonText('');\n    setValidationResult(null);\n    setPreviewData(null);\n    setImportSuccess(null);\n    setImportMethod('file');\n  };\n\n  // Handle dialog close\n  const handleClose = () => {\n    handleReset();\n    onOpenChange(false);\n  };\n\n  return (\n    <Dialog open={isOpen} onOpenChange={onOpenChange}>\n      <DialogContent className=\"max-w-lg\">\n        <DialogHeader>\n          <DialogTitle>Import Color Palette</DialogTitle>\n        </DialogHeader>\n\n        <div className=\"space-y-4\">\n          {/* Import method selection */}\n          <div className=\"space-y-2\">\n            <Label className=\"text-sm font-medium\">Import Method</Label>\n            <div className=\"flex gap-2\">\n              <Button\n                size=\"sm\"\n                variant={importMethod === 'file' ? 'default' : 'outline'}\n                onClick={() => setImportMethod('file')}\n                className=\"gap-2\"\n              >\n                <Upload className=\"h-4 w-4\" />\n                File Upload\n              </Button>\n              <Button\n                size=\"sm\"\n                variant={importMethod === 'text' ? 'default' : 'outline'}\n                onClick={() => setImportMethod('text')}\n                className=\"gap-2\"\n              >\n                <FileText className=\"h-4 w-4\" />\n                Paste JSON\n              </Button>\n            </div>\n          </div>\n\n          <Separator />\n\n          {/* File upload */}\n          {importMethod === 'file' && (\n            <div className=\"space-y-2\">\n              <Label className=\"text-sm font-medium\">Select Palette File</Label>\n              <Input\n                type=\"file\"\n                accept=\".json,.palette,.pal\"\n                onChange={handleFileUpload}\n                className=\"cursor-pointer\"\n              />\n              <p className=\"text-xs text-muted-foreground\">\n                Supported formats: .json, .palette, .pal\n              </p>\n            </div>\n          )}\n\n          {/* Text input */}\n          {importMethod === 'text' && (\n            <div className=\"space-y-2\">\n              <Label className=\"text-sm font-medium\">Paste JSON Data</Label>\n              <textarea\n                value={jsonText}\n                onChange={(e) => handleTextChange(e.target.value)}\n                placeholder='{\"name\": \"My Palette\", \"colors\": [\"#ff0000\", \"#00ff00\", \"#0000ff\"]}'\n                className=\"w-full h-24 px-3 py-2 text-sm border border-border rounded-md bg-background resize-none focus:outline-none focus:ring-1 focus:ring-ring\"\n              />\n            </div>\n          )}\n\n          {/* Validation results */}\n          {validationResult && (\n            <div className=\"space-y-2\">\n              <Alert className={validationResult.isValid ? 'border-green-200' : 'border-red-200'}>\n                <div className=\"flex items-start gap-2\">\n                  {validationResult.isValid ? (\n                    <CheckCircle className=\"h-4 w-4 text-green-600 mt-0.5\" />\n                  ) : (\n                    <AlertCircle className=\"h-4 w-4 text-red-600 mt-0.5\" />\n                  )}\n                  <div className=\"flex-1\">\n                    <AlertDescription>\n                      <div className=\"font-medium mb-1\">\n                        {getValidationSummary(validationResult)}\n                      </div>\n                      \n                      {validationResult.errors.length > 0 && (\n                        <div className=\"space-y-1\">\n                          <div className=\"text-xs font-medium text-red-600\">Errors:</div>\n                          {validationResult.errors.map((error, index) => (\n                            <div key={index} className=\"text-xs text-red-600\">• {error}</div>\n                          ))}\n                        </div>\n                      )}\n                      \n                      {validationResult.warnings.length > 0 && (\n                        <div className=\"space-y-1 mt-2\">\n                          <div className=\"text-xs font-medium text-yellow-600\">Warnings:</div>\n                          {validationResult.warnings.map((warning, index) => (\n                            <div key={index} className=\"text-xs text-yellow-600\">• {warning}</div>\n                          ))}\n                        </div>\n                      )}\n                    </AlertDescription>\n                  </div>\n                </div>\n              </Alert>\n            </div>\n          )}\n\n          {/* Preview */}\n          {previewData && (\n            <div className=\"space-y-3 p-4 bg-muted/50 rounded-lg\">\n              <div className=\"flex items-center gap-2\">\n                <CheckCircle className=\"h-4 w-4 text-green-600\" />\n                <span className=\"font-medium\">Palette Preview</span>\n              </div>\n              \n              <div className=\"space-y-2\">\n                <div>\n                  <span className=\"text-sm font-medium\">Name:</span>{' '}\n                  <span className=\"text-sm\">{previewData.name}</span>\n                </div>\n                <div>\n                  <span className=\"text-sm font-medium\">Colors:</span>{' '}\n                  <span className=\"text-sm\">{previewData.colors.length}</span>\n                </div>\n                \n                {/* Color Preview */}\n                <div className=\"space-y-1\">\n                  <span className=\"text-sm font-medium\">Preview:</span>\n                  <TooltipProvider>\n                    <div className=\"flex flex-wrap gap-1\">\n                      {previewData.colors.slice(0, 16).map((color, index) => (\n                        <Tooltip key={index}>\n                          <TooltipTrigger asChild>\n                            <div\n                              className=\"w-6 h-6 rounded border border-border\"\n                              style={{ backgroundColor: color }}\n                            />\n                          </TooltipTrigger>\n                          <TooltipContent>\n                            <p>{color}</p>\n                          </TooltipContent>\n                        </Tooltip>\n                      ))}\n                      {previewData.colors.length > 16 && (\n                        <div className=\"flex items-center justify-center w-6 h-6 text-xs text-muted-foreground border border-border rounded\">\n                          +{previewData.colors.length - 16}\n                        </div>\n                      )}\n                    </div>\n                  </TooltipProvider>\n                </div>\n              </div>\n            </div>\n          )}\n\n          {/* Success message */}\n          {importSuccess && (\n            <Alert className=\"border-green-200\">\n              <CheckCircle className=\"h-4 w-4 text-green-600\" />\n              <AlertDescription className=\"text-green-700\">\n                {importSuccess}\n              </AlertDescription>\n            </Alert>\n          )}\n        </div>\n\n        <DialogFooter>\n          <div className=\"flex gap-2 w-full justify-between\">\n            <Button\n              variant=\"outline\"\n              onClick={handleReset}\n              disabled={isImporting || importSuccess !== null}\n            >\n              Reset\n            </Button>\n            \n            <div className=\"flex gap-2\">\n              <Button\n                variant=\"outline\"\n                onClick={handleClose}\n                disabled={isImporting}\n                className=\"gap-2\"\n              >\n                <X className=\"h-4 w-4\" />\n                Cancel\n              </Button>\n              \n              <Button\n                onClick={handleImport}\n                disabled={!validationResult?.isValid || isImporting || importSuccess !== null}\n                className=\"gap-2\"\n              >\n                {isImporting ? (\n                  <>\n                    <div className=\"animate-spin h-4 w-4 border-2 border-current border-t-transparent rounded-full\" />\n                    Importing...\n                  </>\n                ) : (\n                  <>\n                    <Upload className=\"h-4 w-4\" />\n                    Import Palette\n                  </>\n                )}\n              </Button>\n            </div>\n          </div>\n        </DialogFooter>\n      </DialogContent>\n    </Dialog>\n  );\n};\n","usedDeprecatedRules":[]},{"filePath":"/Users/cameronfoxly/GitHubRepos/Ascii-Motion/src/components/features/InteractiveGradientOverlay.tsx","messages":[{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useCallback has missing dependencies: 'displayEndPoint' and 'stopHitRadius'. Either include them or remove the dependency array.","line":118,"column":6,"nodeType":"ArrayExpression","endLine":118,"endColumn":121,"suggestions":[{"desc":"Update the dependencies array to be: [startPoint, effectiveCellWidth, panOffset.x, panOffset.y, effectiveCellHeight, displayEndPoint, definition, endPoint, ellipsePoint, stopHitRadius]","fix":{"range":[4586,4701],"text":"[startPoint, effectiveCellWidth, panOffset.x, panOffset.y, effectiveCellHeight, displayEndPoint, definition, endPoint, ellipsePoint, stopHitRadius]"}}]},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useCallback has an unnecessary dependency: 'altKeyDown'. Either exclude it or remove the dependency array.","line":158,"column":6,"nodeType":"ArrayExpression","endLine":158,"endColumn":53,"suggestions":[{"desc":"Update the dependencies array to be: [hitTest, startDrag, duplicateStop]","fix":{"range":[6005,6052],"text":"[hitTest, startDrag, duplicateStop]"}}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useCallback, useRef, useEffect } from 'react';\nimport { useGradientStore } from '../../stores/gradientStore';\nimport { useCanvasContext } from '../../contexts/CanvasContext';\nimport { useToolStore } from '../../stores/toolStore';\nimport { GradientStopPicker } from './GradientStopPicker';\n\nexport const InteractiveGradientOverlay: React.FC = () => {\n  const overlayRef = useRef<HTMLDivElement>(null);\n  const { activeTool } = useToolStore();\n  const { cellWidth, cellHeight, zoom, panOffset, altKeyDown } = useCanvasContext();\n  const { \n    isApplying, \n    startPoint, \n    endPoint, \n    ellipsePoint,\n    hoverEndPoint,\n    definition,\n    dragState,\n    editingStop,\n    startDrag,\n    updateDrag,\n    endDrag,\n    startEditingStop,\n    updateEditingStopValue,\n    closeStopEditor,\n    cancelStopEdit,\n    duplicateStop\n  } = useGradientStore();\n\n  const stopOffsetBase = 24;\n  const stopSize = 18;\n  const stopHitRadius = stopSize / 2 + 2;\n  const controlBorderColor = '#1f2937';\n  const controlOuterStrokeColor = '#ffffff';\n  const displayEndPoint = endPoint ?? hoverEndPoint;\n\n  const effectiveCellWidth = cellWidth * zoom;\n  const effectiveCellHeight = cellHeight * zoom;\n\n  // Hit testing function to determine what element is clicked\n  const hitTest = useCallback((mouseX: number, mouseY: number) => {\n    if (!startPoint) return null;\n\n    const startPixelX = startPoint.x * effectiveCellWidth + panOffset.x + effectiveCellWidth / 2;\n    const startPixelY = startPoint.y * effectiveCellHeight + panOffset.y + effectiveCellHeight / 2;\n\n    // Test start point (6px radius)\n    const startDist = Math.sqrt(Math.pow(mouseX - startPixelX, 2) + Math.pow(mouseY - startPixelY, 2));\n    \n    if (displayEndPoint) {\n      const endPixelX = displayEndPoint.x * effectiveCellWidth + panOffset.x + effectiveCellWidth / 2;\n      const endPixelY = displayEndPoint.y * effectiveCellHeight + panOffset.y + effectiveCellHeight / 2;\n\n      // Test end point (6px radius)\n      const endDist = Math.sqrt(Math.pow(mouseX - endPixelX, 2) + Math.pow(mouseY - endPixelY, 2));\n\n      // Check stops first (they take precedence)\n      const enabledProperties: Array<'character' | 'textColor' | 'backgroundColor'> = [];\n      if (definition.character.enabled) enabledProperties.push('character');\n      if (definition.textColor.enabled) enabledProperties.push('textColor');\n      if (definition.backgroundColor.enabled) enabledProperties.push('backgroundColor');\n\n      for (let propIndex = 0; propIndex < enabledProperties.length; propIndex++) {\n        const property = enabledProperties[propIndex];\n        const stops = definition[property].stops;\n\n        for (let stopIndex = 0; stopIndex < stops.length; stopIndex++) {\n          const stop = stops[stopIndex];\n          if (stop.position < 0 || stop.position > 1) continue;\n\n          // Calculate stop position\n          const lineX = startPixelX + (endPixelX - startPixelX) * stop.position;\n          const lineY = startPixelY + (endPixelY - startPixelY) * stop.position;\n\n          // Apply perpendicular offset\n          const lineAngle = Math.atan2(endPixelY - startPixelY, endPixelX - startPixelX);\n          const perpAngle = lineAngle + Math.PI / 2;\n          const offsetDistance = (propIndex + 1) * stopOffsetBase;\n\n          const stopX = lineX + Math.cos(perpAngle) * offsetDistance;\n          const stopY = lineY + Math.sin(perpAngle) * offsetDistance;\n\n          // Test stop hit (6px radius)\n          const stopDist = Math.sqrt(Math.pow(mouseX - stopX, 2) + Math.pow(mouseY - stopY, 2));\n          if (stopDist <= stopHitRadius) {\n            return {\n              type: 'stop' as const,\n              property,\n              stopIndex\n            };\n          }\n        }\n      }\n\n      // Test end point after stops (stops have precedence)\n      if (endDist <= 8 && endPoint) {\n        return { type: 'end' as const };\n      }\n      \n      // Test ellipse point for radial gradients\n      if (definition.type === 'radial' && ellipsePoint) {\n        const ellipsePixelX = ellipsePoint.x * effectiveCellWidth + panOffset.x + effectiveCellWidth / 2;\n        const ellipsePixelY = ellipsePoint.y * effectiveCellHeight + panOffset.y + effectiveCellHeight / 2;\n        const ellipseDist = Math.sqrt(Math.pow(mouseX - ellipsePixelX, 2) + Math.pow(mouseY - ellipsePixelY, 2));\n        \n        if (ellipseDist <= 8) {\n          return { type: 'ellipse' as const };\n        }\n      }\n    }\n\n    // Test start point last\n    if (startDist <= 8) {\n      return { type: 'start' as const };\n    }\n\n    return null;\n  }, [startPoint, endPoint, ellipsePoint, hoverEndPoint, definition, effectiveCellWidth, effectiveCellHeight, panOffset]);\n\n  // Mouse event handlers\n  const handleMouseDown = useCallback((event: React.MouseEvent) => {\n    const rect = overlayRef.current?.getBoundingClientRect();\n    if (!rect) return;\n\n    const mouseX = event.clientX - rect.left;\n    const mouseY = event.clientY - rect.top;\n\n    const hit = hitTest(mouseX, mouseY);\n    \n    if (!hit) {\n      // No control hit - let the event bubble to canvas for end point placement\n      return;\n    }\n\n    // We hit a control - prevent default and handle drag\n    event.preventDefault();\n    event.stopPropagation();\n\n    if (hit.type === 'start' || hit.type === 'end' || hit.type === 'ellipse') {\n      startDrag(hit.type, { x: mouseX, y: mouseY });\n    } else if (hit.type === 'stop') {\n      // Check for alt+click to duplicate stop (use event.altKey for immediate detection)\n      if (event.altKey) {\n        // Duplicate the stop and start dragging the new one\n        const newStopIndex = duplicateStop(hit.property, hit.stopIndex);\n        startDrag('stop', { x: mouseX, y: mouseY }, {\n          property: hit.property,\n          stopIndex: newStopIndex\n        });\n      } else {\n        // Normal drag\n        startDrag('stop', { x: mouseX, y: mouseY }, {\n          property: hit.property,\n          stopIndex: hit.stopIndex\n        });\n      }\n    }\n  }, [hitTest, startDrag, altKeyDown, duplicateStop]);\n  \n  // Handle double-click on overlay to detect stop clicks\n  const handleOverlayDoubleClick = useCallback((event: React.MouseEvent) => {\n    const rect = overlayRef.current?.getBoundingClientRect();\n    if (!rect) return;\n\n    const mouseX = event.clientX - rect.left;\n    const mouseY = event.clientY - rect.top;\n\n    const hit = hitTest(mouseX, mouseY);\n    \n    if (hit && hit.type === 'stop') {\n      event.preventDefault();\n      event.stopPropagation();\n      startEditingStop(hit.property, hit.stopIndex);\n    }\n  }, [hitTest, startEditingStop]);\n\n  const handleMouseMove = useCallback((event: React.MouseEvent) => {\n    if (!dragState?.isDragging) return;\n\n    const rect = overlayRef.current?.getBoundingClientRect();\n    if (!rect) return;\n\n    const mouseX = event.clientX - rect.left;\n    const mouseY = event.clientY - rect.top;\n\n    // Pass canvas context for accurate coordinate conversion\n    updateDrag({ x: mouseX, y: mouseY }, {\n      cellWidth,\n      cellHeight,\n      zoom,\n      panOffset\n    });\n  }, [dragState?.isDragging, updateDrag, cellWidth, cellHeight, zoom, panOffset]);\n\n  const handleMouseUp = useCallback((event: React.MouseEvent) => {\n    event.preventDefault();\n    event.stopPropagation();\n\n    if (dragState?.isDragging) {\n      endDrag();\n    }\n  }, [dragState?.isDragging, endDrag]);\n\n  // Global mouse up handler for when mouse leaves the overlay\n  useEffect(() => {\n    const handleGlobalMouseUp = () => {\n      if (dragState?.isDragging) {\n        endDrag();\n      }\n    };\n\n    if (dragState?.isDragging) {\n      window.addEventListener('mouseup', handleGlobalMouseUp);\n      return () => window.removeEventListener('mouseup', handleGlobalMouseUp);\n    }\n  }, [dragState?.isDragging, endDrag]);\n\n  // Don't render if not in gradient tool mode or not applying\n  if (activeTool !== 'gradientfill' || !isApplying) return null;\n\n  // Render interactive controls\n  const renderControls = () => {\n    if (!startPoint) return null;\n\n    const startPixelX = startPoint.x * effectiveCellWidth + panOffset.x + effectiveCellWidth / 2;\n    const startPixelY = startPoint.y * effectiveCellHeight + panOffset.y + effectiveCellHeight / 2;\n\n    const elements: React.ReactNode[] = [];\n\n    // Start point\n    elements.push(\n      <div\n        key=\"start-point\"\n        className=\"absolute w-3 h-3 -translate-x-1/2 -translate-y-1/2 rounded-full border-2 cursor-move\"\n        style={{\n          left: startPixelX,\n          top: startPixelY,\n          backgroundColor: '#ffffff',\n          borderColor: controlBorderColor,\n          boxShadow: `0 0 0 1px ${controlOuterStrokeColor}`,\n          pointerEvents: dragState?.isDragging ? 'none' : 'auto'\n        }}\n        onMouseDown={(e) => {\n          // Handle start point dragging even when container has pointer-events: none\n          e.preventDefault();\n          e.stopPropagation();\n          startDrag('start', {\n            x: e.clientX - (overlayRef.current?.getBoundingClientRect()?.left || 0),\n            y: e.clientY - (overlayRef.current?.getBoundingClientRect()?.top || 0)\n          });\n        }}\n      />\n    );\n\n    const enabledProperties: Array<'character' | 'textColor' | 'backgroundColor'> = [];\n    if (definition.character.enabled) enabledProperties.push('character');\n    if (definition.textColor.enabled) enabledProperties.push('textColor');\n    if (definition.backgroundColor.enabled) enabledProperties.push('backgroundColor');\n\n    const hasDisplayEndPoint = Boolean(displayEndPoint);\n    let endPixelX = 0;\n    let endPixelY = 0;\n\n    if (hasDisplayEndPoint) {\n      endPixelX = displayEndPoint!.x * effectiveCellWidth + panOffset.x + effectiveCellWidth / 2;\n      endPixelY = displayEndPoint!.y * effectiveCellHeight + panOffset.y + effectiveCellHeight / 2;\n\n      elements.push(\n        <svg\n          key=\"gradient-line\"\n          className=\"absolute inset-0 pointer-events-none\"\n          style={{ overflow: 'visible' }}\n        >\n          <line\n            x1={startPixelX}\n            y1={startPixelY}\n            x2={endPixelX}\n            y2={endPixelY}\n            stroke=\"#6b7280\"\n            strokeWidth={2}\n            strokeDasharray=\"5,5\"\n          />\n        </svg>\n      );\n\n      elements.push(\n        <div\n          key=\"end-point\"\n          className=\"absolute w-3 h-3 -translate-x-1/2 -translate-y-1/2 rounded-full border-2 cursor-move\"\n          style={{\n            left: endPixelX,\n            top: endPixelY,\n            backgroundColor: '#ffffff',\n            borderColor: controlBorderColor,\n            boxShadow: `0 0 0 1px ${controlOuterStrokeColor}`,\n            pointerEvents: dragState?.isDragging || !endPoint ? 'none' : 'auto'\n          }}\n        />\n      );\n    }\n\n    // Ellipse point for radial gradients\n    if (definition.type === 'radial' && ellipsePoint) {\n      const ellipsePixelX = ellipsePoint.x * effectiveCellWidth + panOffset.x + effectiveCellWidth / 2;\n      const ellipsePixelY = ellipsePoint.y * effectiveCellHeight + panOffset.y + effectiveCellHeight / 2;\n\n      elements.push(\n        <div\n          key=\"ellipse-point\"\n          className=\"absolute w-3 h-3 -translate-x-1/2 -translate-y-1/2 rounded-full border-2 cursor-move\"\n          style={{\n            left: ellipsePixelX,\n            top: ellipsePixelY,\n            backgroundColor: '#ffffff',\n            borderColor: '#dc2626', // Different color to distinguish from end point\n            boxShadow: `0 0 0 1px ${controlOuterStrokeColor}`,\n            pointerEvents: dragState?.isDragging ? 'none' : 'auto'\n          }}\n          onMouseDown={(e) => {\n            e.preventDefault();\n            e.stopPropagation();\n            startDrag('ellipse', {\n              x: e.clientX - (overlayRef.current?.getBoundingClientRect()?.left || 0),\n              y: e.clientY - (overlayRef.current?.getBoundingClientRect()?.top || 0)\n            });\n          }}\n        />\n      );\n    }\n\n    enabledProperties.forEach((property, propIndex) => {\n      const stops = definition[property].stops;\n\n      stops.forEach((stop, stopIndex) => {\n        if (stop.position < 0 || stop.position > 1) return;\n\n        let stopX: number;\n        let stopY: number;\n\n        if (hasDisplayEndPoint) {\n          const lineX = startPixelX + (endPixelX - startPixelX) * stop.position;\n          const lineY = startPixelY + (endPixelY - startPixelY) * stop.position;\n\n          const lineAngle = Math.atan2(endPixelY - startPixelY, endPixelX - startPixelX);\n          const perpAngle = lineAngle + Math.PI / 2;\n          const offsetDistance = (propIndex + 1) * stopOffsetBase;\n\n          stopX = lineX + Math.cos(perpAngle) * offsetDistance;\n          stopY = lineY + Math.sin(perpAngle) * offsetDistance;\n\n          if (offsetDistance > 0) {\n            elements.push(\n              <svg\n                key={`connection-${property}-${stopIndex}`}\n                className=\"absolute inset-0 pointer-events-none\"\n                style={{ overflow: 'visible' }}\n              >\n                <line\n                  x1={lineX}\n                  y1={lineY}\n                  x2={stopX}\n                  y2={stopY}\n                  stroke=\"#9ca3af\"\n                  strokeWidth={1}\n                  strokeDasharray=\"2,2\"\n                />\n              </svg>\n            );\n          }\n        } else {\n          stopX = startPixelX + propIndex * 25 - (enabledProperties.length - 1) * 12.5;\n          stopY = startPixelY + 40 + stopIndex * 25;\n        }\n\n        const isColorStop = property === 'textColor' || property === 'backgroundColor';\n        const markerBackground = isColorStop ? stop.value : '#111827';\n        \n        // Check if this stop is being edited\n        const isEditing = editingStop?.property === property && editingStop?.stopIndex === stopIndex;\n\n        elements.push(\n          <div\n            key={`stop-${property}-${stopIndex}`}\n            className=\"absolute -translate-x-1/2 -translate-y-1/2 border cursor-move\"\n            style={{\n              left: stopX,\n              top: stopY,\n              width: stopSize,\n              height: stopSize,\n              backgroundColor: markerBackground,\n              borderColor: isEditing ? '#3b82f6' : controlBorderColor, // Blue border when editing\n              borderRadius: 4,\n              borderWidth: isEditing ? 3 : 2, // Thicker border when editing\n              boxShadow: isEditing \n                ? `0 0 0 2px #3b82f6, 0 0 12px rgba(59, 130, 246, 0.5)` // Blue glow when editing\n                : `0 0 0 1px ${controlOuterStrokeColor}`,\n              pointerEvents: dragState?.isDragging || editingStop ? 'none' : 'auto',\n              transition: 'border-color 0.2s ease, border-width 0.2s ease, box-shadow 0.2s ease' // Only transition visual properties, not position\n            }}\n          />\n        );\n\n        if (property === 'character') {\n          elements.push(\n            <div\n              key={`stop-value-${property}-${stopIndex}`}\n              className=\"absolute font-mono text-sm -translate-x-1/2 -translate-y-1/2 pointer-events-none select-none\"\n              style={{\n                left: stopX,\n                top: stopY,\n                color: '#f9fafb'\n              }}\n            >\n              {stop.value}\n            </div>\n          );\n        }\n      });\n    });\n\n    return elements;\n  };\n\n  return (\n    <div\n      ref={overlayRef}\n      className=\"absolute inset-0\"\n      style={{ \n        zIndex: 10,\n        cursor: dragState?.isDragging ? 'grabbing' : 'auto',\n        // Disable pointer events when:\n        // 1. Only have start point (no end point yet)\n        // 2. Stop editor is open (picker is showing)\n        pointerEvents: (startPoint && endPoint && !editingStop) ? 'auto' : 'none'\n      }}\n      onMouseDown={!editingStop ? handleMouseDown : undefined}\n      onMouseMove={!editingStop ? handleMouseMove : undefined}\n      onMouseUp={!editingStop ? handleMouseUp : undefined}\n      onDoubleClick={!editingStop ? handleOverlayDoubleClick : undefined}\n    >\n      {renderControls()}\n      \n      {/* Gradient Stop Picker */}\n      {editingStop && (\n        <GradientStopPicker\n          isOpen={true}\n          onOpenChange={(open) => {\n            if (!open) {\n              // User closed picker without selecting - revert changes\n              cancelStopEdit();\n            }\n          }}\n          onValueSelect={(value) => {\n            // User confirmed selection - keep changes and close\n            updateEditingStopValue(value);\n            closeStopEditor();\n          }}\n          onValueChange={(value) => {\n            // Live preview - temporarily update stop value\n            updateEditingStopValue(value);\n          }}\n          initialValue={editingStop.originalValue}\n          type={editingStop.property}\n        />\n      )}\n    </div>\n  );\n};","usedDeprecatedRules":[]},{"filePath":"/Users/cameronfoxly/GitHubRepos/Ascii-Motion/src/components/features/JsonExportDialog.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/cameronfoxly/GitHubRepos/Ascii-Motion/src/components/features/JsonImportDialog.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/cameronfoxly/GitHubRepos/Ascii-Motion/src/components/features/KeyboardShortcutsDialog.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/cameronfoxly/GitHubRepos/Ascii-Motion/src/components/features/MainCharacterPaletteSection.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/cameronfoxly/GitHubRepos/Ascii-Motion/src/components/features/ManageCharacterPalettesDialog.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/cameronfoxly/GitHubRepos/Ascii-Motion/src/components/features/ManagePalettesDialog.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/cameronfoxly/GitHubRepos/Ascii-Motion/src/components/features/MediaImportPanel.tsx","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":189,"column":65,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":189,"endColumn":68,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7810,7813],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7810,7813],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":291,"column":30,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":291,"endColumn":33,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[11503,11506],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[11503,11506],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":291,"column":92,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":291,"endColumn":95,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[11565,11568],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[11565,11568],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":294,"column":30,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":294,"endColumn":33,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[11740,11743],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[11740,11743],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":294,"column":98,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":294,"endColumn":101,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[11808,11811],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[11808,11811],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useEffect has missing dependencies: 'createConversionSettings' and 'setPreviewData'. Either include them or remove the dependency array.","line":440,"column":6,"nodeType":"ArrayExpression","endLine":480,"endColumn":4,"suggestions":[{"desc":"Update the dependencies array to be: [livePreviewEnabled, previewFrames, frameIndex, settings.characterWidth, settings.characterHeight, settings.cropMode, settings.nudgeX, settings.nudgeY, settings.useOriginalColors, settings.colorQuantization, settings.paletteSize, settings.colorMappingMode, settings.brightness, settings.contrast, settings.saturation, settings.highlights, settings.shadows, settings.midtones, settings.blur, settings.sharpen, settings.enableCharacterMapping, activePalette, mappingMethod, invertDensity, characterSpacing, settings.enableTextColorMapping, settings.textColorPaletteId, settings.textColorMappingMode, settings.enableBackgroundColorMapping, settings.backgroundColorPaletteId, settings.backgroundColorMappingMode, selectedColor, palettes, customPalettes, setCanvasData, positionCellsOnCanvas, startPreview, createConversionSettings, setPreviewData]","fix":{"range":[16667,17843],"text":"[livePreviewEnabled, previewFrames, frameIndex, settings.characterWidth, settings.characterHeight, settings.cropMode, settings.nudgeX, settings.nudgeY, settings.useOriginalColors, settings.colorQuantization, settings.paletteSize, settings.colorMappingMode, settings.brightness, settings.contrast, settings.saturation, settings.highlights, settings.shadows, settings.midtones, settings.blur, settings.sharpen, settings.enableCharacterMapping, activePalette, mappingMethod, invertDensity, characterSpacing, settings.enableTextColorMapping, settings.textColorPaletteId, settings.textColorMappingMode, settings.enableBackgroundColorMapping, settings.backgroundColorPaletteId, settings.backgroundColorMappingMode, selectedColor, palettes, customPalettes, setCanvasData, positionCellsOnCanvas, startPreview, createConversionSettings, setPreviewData]"}}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'error' is defined but never used.","line":589,"column":14,"nodeType":null,"messageId":"unusedVar","endLine":589,"endColumn":19},{"ruleId":"no-empty","severity":2,"message":"Empty block statement.","line":589,"column":21,"nodeType":"BlockStatement","messageId":"unexpected","endLine":591,"endColumn":6,"suggestions":[{"messageId":"suggestComment","data":{"type":"block"},"fix":{"range":[21523,21529],"text":" /* empty */ "},"desc":"Add comment inside empty block statement."}]},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useCallback has a missing dependency: 'hasSessionSettings'. Either include it or remove the dependency array.","line":596,"column":6,"nodeType":"ArrayExpression","endLine":596,"endColumn":105,"suggestions":[{"desc":"Update the dependencies array to be: [setSelectedFile, setError, canvasWidth, canvasHeight, hasSessionSettings, updateSettings]","fix":{"range":[21661,21760],"text":"[setSelectedFile, setError, canvasWidth, canvasHeight, hasSessionSettings, updateSettings]"}}]},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useCallback has missing dependencies: 'createConversionSettings' and 'setLivePreviewEnabled'. Either include them or remove the dependency array.","line":684,"column":6,"nodeType":"ArrayExpression","endLine":684,"endColumn":238,"suggestions":[{"desc":"Update the dependencies array to be: [previewFrames, endPreview, createConversionSettings, closeModal, positionCellsOnCanvas, settings.characterWidth, settings.characterHeight, clearCanvas, setCanvasData, setLivePreviewEnabled, importMode, importFramesOverwrite, currentFrameIndex, importFramesAppend, setError]","fix":{"range":[24868,25100],"text":"[previewFrames, endPreview, createConversionSettings, closeModal, positionCellsOnCanvas, settings.characterWidth, settings.characterHeight, clearCanvas, setCanvasData, setLivePreviewEnabled, importMode, importFramesOverwrite, currentFrameIndex, importFramesAppend, setError]"}}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":1100,"column":89,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":1100,"endColumn":92,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[45443,45446],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[45443,45446],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":8,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * MediaImportPanel - Side panel overlay for importing images and videos to ASCII art\n * \n * Features:\n * - Overlays existing side panel while keeping canvas visible\n * - Live preview on canvas as settings change\n * - File drop zone with format detection\n * - Size controls with real-time feedback\n * - Processing progress display\n */\n\nimport React, { useCallback, useState, useEffect } from 'react';\nimport { Button } from '../ui/button';\nimport { Input } from '../ui/input';\nimport { Label } from '../ui/label';\nimport { Progress } from '../ui/progress';\nimport { Checkbox } from '../ui/checkbox';\nimport { Alert, AlertDescription } from '../ui/alert';\nimport { ScrollArea } from '../ui/scroll-area';\nimport { Slider } from '../ui/slider';\nimport { Tooltip, TooltipContent, TooltipProvider, TooltipTrigger } from '../ui/tooltip';\nimport { \n  Collapsible,\n  CollapsibleContent,\n} from '../ui/collapsible';\nimport { CollapsibleHeader } from '../common/CollapsibleHeader';\nimport { PanelSeparator } from '../common/PanelSeparator';\nimport { \n  Upload, \n  Image as ImageIcon, \n  Video, \n  FileX, \n  Download,\n  X,\n  ChevronLeft,\n  ChevronRight,\n  ChevronsLeft,\n  ChevronsRight,\n  Link,\n  Eye,\n  Move3D,\n  ArrowUp,\n  ArrowDown,\n  ArrowLeft,\n  ArrowRight,\n  RotateCcw\n} from 'lucide-react';\nimport { cn } from '../../lib/utils';\nimport { PANEL_ANIMATION } from '../../constants';\nimport { Spinner } from '../common/Spinner';\nimport { \n  useImportModal, \n  useImportFile, \n  useImportProcessing, \n  useImportSettings,\n  useImportPreview,\n  useImportUIState,\n  useImportSessionState\n} from '../../stores/importStore';\nimport { mediaProcessor, SUPPORTED_IMAGE_FORMATS, SUPPORTED_VIDEO_FORMATS } from '../../utils/mediaProcessor';\nimport { asciiConverter } from '../../utils/asciiConverter';\nimport { useCanvasStore } from '../../stores/canvasStore';\nimport { useAnimationStore } from '../../stores/animationStore';\nimport { usePreviewStore } from '../../stores/previewStore';\nimport { useCharacterPaletteStore } from '../../stores/characterPaletteStore';\nimport { usePaletteStore } from '../../stores/paletteStore';\nimport { useToolStore } from '../../stores/toolStore';\nimport { CharacterMappingSection } from './CharacterMappingSection';\nimport { TextColorMappingSection } from './TextColorMappingSection';\nimport { BackgroundColorMappingSection } from './BackgroundColorMappingSection';\nimport { PreprocessingSection } from './PreprocessingSection';\nimport type { MediaFile } from '../../utils/mediaProcessor';\nimport type { Cell } from '../../types';\n\nexport function MediaImportPanel() {\n  const { isOpen, closeModal } = useImportModal();\n  const { selectedFile, setSelectedFile, setProcessedFrames } = useImportFile();\n  const { isProcessing, progress, error, setProcessing, setProgress, setError } = useImportProcessing();\n  const { settings, updateSettings } = useImportSettings();\n  const { frameIndex, setFrameIndex, frames: previewFrames } = useImportPreview();\n  const { uiState, updateUIState } = useImportUIState();\n  const { hasSessionSettings } = useImportSessionState();\n  \n  // Character palette integration\n  const activePalette = useCharacterPaletteStore(state => state.activePalette);\n  const mappingMethod = useCharacterPaletteStore(state => state.mappingMethod);\n  const invertDensity = useCharacterPaletteStore(state => state.invertDensity);\n  const characterSpacing = useCharacterPaletteStore(state => state.characterSpacing);\n  \n  // Tool store integration for default colors\n  const selectedColor = useToolStore(state => state.selectedColor);\n  \n  // Canvas and animation stores\n  const canvasWidth = useCanvasStore(state => state.width);\n  const canvasHeight = useCanvasStore(state => state.height);\n  const setCanvasData = useCanvasStore(state => state.setCanvasData);\n  const clearCanvas = useCanvasStore(state => state.clearCanvas);\n  const addFrame = useAnimationStore(state => state.addFrame);\n  const setCurrentFrame = useAnimationStore(state => state.setCurrentFrame);\n  const updateFrameDuration = useAnimationStore(state => state.updateFrameDuration);\n  const importFramesOverwrite = useAnimationStore(state => state.importFramesOverwrite);\n  const importFramesAppend = useAnimationStore(state => state.importFramesAppend);\n  const currentFrameIndex = useAnimationStore(state => state.currentFrameIndex);\n  \n  // Preview store for independent preview overlay\n  const { setPreviewData, clearPreview, setPreviewActive } = usePreviewStore();\n  \n  const [dragActive, setDragActive] = useState(false);\n  const [isImporting, setIsImporting] = useState(false);\n  const [originalImageAspectRatio, setOriginalImageAspectRatio] = useState<number | null>(null);\n  \n  // Use persistent UI state from store\n  const { \n    importMode, \n    livePreviewEnabled, \n    previewSectionOpen, \n    positionSectionOpen \n  } = uiState;\n  \n  const setImportMode = (mode: 'overwrite' | 'append') => \n    updateUIState({ importMode: mode });\n  const setLivePreviewEnabled = (enabled: boolean) => \n    updateUIState({ livePreviewEnabled: enabled });\n  const setPreviewSectionOpen = (open: boolean) => \n    updateUIState({ previewSectionOpen: open });\n  const setPositionSectionOpen = (open: boolean) => \n    updateUIState({ positionSectionOpen: open });\n  \n  // Preview state management\n  const [isPreviewActive, setIsPreviewActive] = useState(false);\n\n  // Handle linked sizing when maintain aspect ratio is enabled\n  const handleWidthChange = useCallback((value: number) => {\n    if (settings.maintainAspectRatio && originalImageAspectRatio) {\n      // Apply character aspect ratio compensation (characters are 0.6x as wide as tall)\n      // To make image appear with correct aspect ratio, we need MORE width in character count\n      const CHARACTER_ASPECT_RATIO = 0.6;\n      const characterCompensatedAspectRatio = originalImageAspectRatio / CHARACTER_ASPECT_RATIO;\n      \n      const newHeight = Math.ceil(value / characterCompensatedAspectRatio);\n      // Don't constrain to canvas - allow larger dimensions for proper aspect ratio\n      updateSettings({ \n        characterWidth: value,\n        characterHeight: newHeight\n      });\n    } else {\n      updateSettings({ characterWidth: value });\n    }\n  }, [settings.maintainAspectRatio, originalImageAspectRatio, updateSettings]);\n\n  const handleHeightChange = useCallback((value: number) => {\n    if (settings.maintainAspectRatio && originalImageAspectRatio) {\n      // Apply character aspect ratio compensation (characters are 0.6x as wide as tall)\n      // To make image appear with correct aspect ratio, we need MORE width in character count\n      const CHARACTER_ASPECT_RATIO = 0.6;\n      const characterCompensatedAspectRatio = originalImageAspectRatio / CHARACTER_ASPECT_RATIO;\n      \n      const newWidth = Math.ceil(value * characterCompensatedAspectRatio);\n      // Don't constrain to canvas - allow larger dimensions for proper aspect ratio\n      updateSettings({ \n        characterWidth: newWidth,\n        characterHeight: value\n      });\n    } else {\n      updateSettings({ characterHeight: value });\n    }\n  }, [settings.maintainAspectRatio, originalImageAspectRatio, updateSettings]);\n\n  // Preview management functions\n  const startPreview = useCallback(() => {\n    if (!isPreviewActive) {\n      setIsPreviewActive(true);\n      // Activate preview overlay\n      setPreviewActive(true);\n    }\n  }, [isPreviewActive, setPreviewActive]);\n\n  const endPreview = useCallback(() => {\n    if (isPreviewActive) {\n      // Clear preview overlay\n      clearPreview();\n      setPreviewActive(false);\n      // Clear local state\n      setIsPreviewActive(false);\n    }\n  }, [isPreviewActive, clearPreview, setPreviewActive]);\n\n  // Position cells on canvas based on alignment settings\n  const positionCellsOnCanvas = useCallback((cells: Map<string, any>, imageWidth: number, imageHeight: number) => {\n\n    \n    // Calculate offset based on alignment\n    let offsetX = 0;\n    let offsetY = 0;\n    \n    switch (settings.cropMode) {\n      case 'top-left':\n        offsetX = 0;\n        offsetY = 0;\n        break;\n      case 'top':\n        offsetX = Math.floor((canvasWidth - imageWidth) / 2);\n        offsetY = 0;\n        break;\n      case 'top-right':\n        offsetX = canvasWidth - imageWidth;\n        offsetY = 0;\n        break;\n      case 'left':\n        offsetX = 0;\n        offsetY = Math.floor((canvasHeight - imageHeight) / 2);\n        break;\n      case 'center':\n        offsetX = Math.floor((canvasWidth - imageWidth) / 2);\n        offsetY = Math.floor((canvasHeight - imageHeight) / 2);\n        break;\n      case 'right':\n        offsetX = canvasWidth - imageWidth;\n        offsetY = Math.floor((canvasHeight - imageHeight) / 2);\n        break;\n      case 'bottom-left':\n        offsetX = 0;\n        offsetY = canvasHeight - imageHeight;\n        break;\n      case 'bottom':\n        offsetX = Math.floor((canvasWidth - imageWidth) / 2);\n        offsetY = canvasHeight - imageHeight;\n        break;\n      case 'bottom-right':\n        offsetX = canvasWidth - imageWidth;\n        offsetY = canvasHeight - imageHeight;\n        break;\n    }\n    \n    // Apply nudge adjustments\n    offsetX += settings.nudgeX;\n    offsetY += settings.nudgeY;\n    \n\n    \n    // For images larger than canvas, we need different logic\n    // Don't constrain offset to positive values - allow negative offsets to show center portions\n    if (imageWidth > canvasWidth || imageHeight > canvasHeight) {\n      // For oversized images, positioning shows different parts of the image\n      // No additional constraints needed - let the cell bounds check below handle visibility\n    } else {\n      // For images smaller than canvas, allow some nudging beyond bounds but keep at least part visible\n      // Allow image to be nudged up to 50% off-screen while keeping some portion visible\n      const maxNegativeX = Math.floor(imageWidth * -0.5);\n      const maxPositiveX = canvasWidth - Math.floor(imageWidth * 0.5);\n      const maxNegativeY = Math.floor(imageHeight * -0.5);\n      const maxPositiveY = canvasHeight - Math.floor(imageHeight * 0.5);\n      \n      offsetX = Math.max(maxNegativeX, Math.min(offsetX, maxPositiveX));\n      offsetY = Math.max(maxNegativeY, Math.min(offsetY, maxPositiveY));\n    }\n    \n\n    \n    const positionedCells = new Map();\n    cells.forEach((cell, originalKey) => {\n      // Parse original coordinates from the key (format: \"x,y\")\n      const [origX, origY] = originalKey.split(',').map(Number);\n      \n      const newCell = {\n        ...cell,\n        x: origX + offsetX,\n        y: origY + offsetY\n      };\n      \n      // Only add cell if it's within canvas bounds\n      if (newCell.x >= 0 && newCell.x < canvasWidth && newCell.y >= 0 && newCell.y < canvasHeight) {\n        const newKey = `${newCell.x},${newCell.y}`;\n        positionedCells.set(newKey, newCell);\n      }\n    });\n    \n\n    \n    return positionedCells;\n  }, [canvasWidth, canvasHeight, settings.cropMode, settings.nudgeX, settings.nudgeY]);\n\n  // Get palette data for dependencies (use individual arrays to avoid getAllPalettes() caching issues)\n  const palettes = usePaletteStore(state => state.palettes);\n  const customPalettes = usePaletteStore(state => state.customPalettes);\n  \n  // Create conversion settings helper function\n  const createConversionSettings = useCallback(() => {\n    const allPalettes = [...palettes, ...customPalettes];\n    const textColorPalette = settings.enableTextColorMapping && settings.textColorPaletteId \n      ? allPalettes.find((p: any) => p.id === settings.textColorPaletteId)?.colors.map((c: any) => c.value) || []\n      : [];\n    const backgroundColorPalette = settings.enableBackgroundColorMapping && settings.backgroundColorPaletteId \n      ? allPalettes.find((p: any) => p.id === settings.backgroundColorPaletteId)?.colors.map((c: any) => c.value) || []\n      : [];\n\n    return {\n      // Character mapping\n      enableCharacterMapping: settings.enableCharacterMapping,\n      characterPalette: activePalette,\n      mappingMethod: mappingMethod,\n      invertDensity: invertDensity,\n      \n      // Text color mapping \n      enableTextColorMapping: settings.enableTextColorMapping,\n      textColorPalette: textColorPalette,\n      textColorMappingMode: settings.textColorMappingMode,\n      defaultTextColor: selectedColor,\n      \n      // Background color mapping\n      enableBackgroundColorMapping: settings.enableBackgroundColorMapping,\n      backgroundColorPalette: backgroundColorPalette,\n      backgroundColorMappingMode: settings.backgroundColorMappingMode,\n      \n      // Legacy settings\n      useOriginalColors: settings.useOriginalColors,\n      colorQuantization: settings.colorQuantization,\n      paletteSize: settings.paletteSize,\n      colorMappingMode: settings.colorMappingMode,\n      \n      // Preprocessing settings\n      contrastEnhancement: 1 + (settings.contrast / 100), // Convert -100-100 to 0-2\n      brightnessAdjustment: settings.brightness,\n      saturationAdjustment: settings.saturation,\n      highlightsAdjustment: settings.highlights,\n      shadowsAdjustment: settings.shadows,\n      midtonesAdjustment: settings.midtones,\n      blurAmount: settings.blur,\n      sharpenAmount: settings.sharpen,\n      ditherStrength: 0.5\n    };\n  }, [\n    settings.enableCharacterMapping,\n    settings.enableTextColorMapping, \n    settings.textColorPaletteId,\n    settings.textColorMappingMode,\n    settings.enableBackgroundColorMapping,\n    settings.backgroundColorPaletteId,\n    settings.backgroundColorMappingMode,\n    settings.useOriginalColors,\n    settings.colorQuantization,\n    settings.paletteSize,\n    settings.colorMappingMode,\n    settings.brightness,\n    settings.contrast,\n    settings.saturation,\n    settings.highlights,\n    settings.shadows,\n    settings.midtones,\n    settings.blur,\n    settings.sharpen,\n    activePalette,\n    mappingMethod,\n    invertDensity,\n    selectedColor,\n    palettes,\n    customPalettes\n  ]);\n\n  // Auto-process file when settings change\n  useEffect(() => {\n    if (!selectedFile || !livePreviewEnabled) return;\n    \n    const processFileAutomatically = async () => {\n      setProcessing(true);\n      setProgress(0);\n      \n      try {\n        const options = {\n          targetWidth: settings.characterWidth,\n          targetHeight: settings.characterHeight,\n          maintainAspectRatio: false, // Never crop - just resize to exact dimensions\n          cropMode: 'center' as const, // Not used since maintainAspectRatio is false\n          quality: 'medium' as const\n        };\n        \n        let result;\n        if (selectedFile.type === 'image') {\n          setProgress(25);\n          result = await mediaProcessor.processImage(selectedFile, options);\n          setProgress(100);\n        } else {\n          setProgress(10);\n          result = await mediaProcessor.processVideo(selectedFile, options);\n          setProgress(100);\n        }\n        \n        if (result.success) {\n          setProcessedFrames(result.frames);\n          setError(null);\n        } else {\n          setError(result.error || 'Unknown processing error');\n        }\n      } catch (err) {\n        setError(err instanceof Error ? err.message : 'Failed to process file');\n      } finally {\n        setProcessing(false);\n      }\n    };\n    \n    // Debounce the processing to avoid excessive calls\n    const timeoutId = setTimeout(processFileAutomatically, 500);\n    return () => clearTimeout(timeoutId);\n  }, [\n    selectedFile,\n    livePreviewEnabled,\n    settings.characterWidth,\n    settings.characterHeight,\n    // Removed maintainAspectRatio and cropMode since they don't affect processing anymore\n    setProcessing,\n    setProgress,\n    setProcessedFrames,\n    setError\n  ]);\n\n  // Live preview effect - update canvas when settings change\n  useEffect(() => {\n    if (!livePreviewEnabled || previewFrames.length === 0) return;\n    \n    const updateLivePreview = async () => {\n      try {\n        // Start preview mode (stores original data if not already started)\n        startPreview();\n        \n        const conversionSettings = createConversionSettings();\n\n        const result = asciiConverter.convertFrame(previewFrames[frameIndex], conversionSettings);\n        \n        // Show preview on canvas overlay (positioned based on alignment)\n        const positionedCells = positionCellsOnCanvas(result.cells, settings.characterWidth, settings.characterHeight);\n        setPreviewData(positionedCells);\n      } catch (err) {\n        console.error('Live preview error:', err);\n      }\n    };\n    \n    // Debounce the update to avoid excessive calls\n    const timeoutId = setTimeout(updateLivePreview, 300);\n    return () => clearTimeout(timeoutId);\n  }, [\n    livePreviewEnabled, \n    previewFrames, \n    frameIndex, \n    settings.characterWidth, \n    settings.characterHeight,\n    settings.cropMode, // Added back since it affects positioning\n    settings.nudgeX, // FIXED: Added nudge dependencies for position updates\n    settings.nudgeY, // FIXED: Added nudge dependencies for position updates\n    settings.useOriginalColors,\n    settings.colorQuantization,\n    settings.paletteSize,\n    settings.colorMappingMode,\n    settings.brightness,\n    settings.contrast,\n    settings.saturation,\n    settings.highlights,\n    settings.shadows,\n    settings.midtones,\n    settings.blur,\n    settings.sharpen,\n    // Character mapping settings\n    settings.enableCharacterMapping,\n    activePalette,\n    mappingMethod,\n    invertDensity,\n    characterSpacing,\n    // Color mapping settings\n    settings.enableTextColorMapping,\n    settings.textColorPaletteId,\n    settings.textColorMappingMode,\n    settings.enableBackgroundColorMapping,\n    settings.backgroundColorPaletteId,\n    settings.backgroundColorMappingMode,\n    selectedColor,\n    palettes,\n    customPalettes,\n    setCanvasData,\n    positionCellsOnCanvas,\n    startPreview\n  ]);\n\n  // End preview when live preview is disabled or component unmounts\n  useEffect(() => {\n    if (!livePreviewEnabled && isPreviewActive) {\n      endPreview();\n    }\n  }, [livePreviewEnabled, isPreviewActive, endPreview]);\n\n  // End preview when modal is closed\n  useEffect(() => {\n    if (!isOpen && isPreviewActive) {\n      endPreview();\n    }\n  }, [isOpen, isPreviewActive, endPreview]);\n\n  // End preview when modal closes\n  useEffect(() => {\n    if (!isOpen && isPreviewActive) {\n      endPreview();\n    }\n  }, [isOpen, isPreviewActive, endPreview]);\n\n  // File drop handlers\n  const handleFileSelect = useCallback(async (file: File) => {\n    const mediaFile = mediaProcessor.validateFile(file);\n    \n    if (!mediaFile) {\n      setError(`Unsupported file format: ${file.type}`);\n      return;\n    }\n    \n    // Calculate optimal image size based on canvas dimensions and file dimensions\n    try {\n      let imageWidth = 0;\n      let imageHeight = 0;\n      \n      if (mediaFile.type === 'image') {\n        // Get image dimensions\n        const img = new Image();\n        img.src = URL.createObjectURL(file);\n        await new Promise((resolve, reject) => {\n          img.onload = () => {\n            imageWidth = img.width;\n            imageHeight = img.height;\n            resolve(void 0);\n          };\n          img.onerror = reject;\n        });\n        URL.revokeObjectURL(img.src);\n      } else {\n        // Get video dimensions from metadata\n        const video = document.createElement('video');\n        video.preload = 'metadata';\n        video.src = URL.createObjectURL(file);\n        \n        await new Promise((resolve) => {\n          video.onloadedmetadata = () => {\n            imageWidth = video.videoWidth;\n            imageHeight = video.videoHeight;\n            resolve(void 0);\n          };\n          video.onerror = () => {\n            // Fallback to default dimensions if video loading fails\n            imageWidth = 1920;\n            imageHeight = 1080;\n            resolve(void 0);\n          };\n        });\n        \n        URL.revokeObjectURL(video.src);\n      }\n      \n      // Calculate optimal character dimensions\n      const imageAspectRatio = imageWidth / imageHeight;\n      setOriginalImageAspectRatio(imageAspectRatio);\n      \n      // Apply character aspect ratio compensation for initial sizing\n      // Characters are 0.6x as wide as tall, so we need MORE width to maintain visual aspect ratio\n      const CHARACTER_ASPECT_RATIO = 0.6;\n      const characterCompensatedAspectRatio = imageAspectRatio / CHARACTER_ASPECT_RATIO;\n      const canvasAspectRatio = canvasWidth / canvasHeight;\n      \n      let targetWidth: number;\n      let targetHeight: number;\n      \n      if (characterCompensatedAspectRatio > canvasAspectRatio) {\n        // Image is wider than canvas - fit to canvas width\n        targetWidth = canvasWidth;\n        targetHeight = Math.round(canvasWidth / characterCompensatedAspectRatio);\n      } else {\n        // Image is taller than canvas - fit to canvas height  \n        targetHeight = canvasHeight;\n        targetWidth = Math.round(canvasHeight * characterCompensatedAspectRatio);\n      }\n      \n      // Ensure we don't exceed canvas bounds\n      targetWidth = Math.min(targetWidth, canvasWidth);\n      targetHeight = Math.min(targetHeight, canvasHeight);\n      \n      // Only auto-calculate dimensions if user hasn't saved preferences from previous session\n      if (!hasSessionSettings) {\n        updateSettings({\n          characterWidth: targetWidth,\n          characterHeight: targetHeight,\n          maintainAspectRatio: true // Ensure aspect ratio is maintained\n        });\n      }\n      \n    } catch (error) {\n\n    }\n    \n    setSelectedFile(mediaFile);\n    setError(null);\n    // Live preview enabled by default will trigger auto-processing\n  }, [setSelectedFile, setError, canvasWidth, canvasHeight, updateSettings, setOriginalImageAspectRatio]);\n\n  const handleDrag = useCallback((e: React.DragEvent) => {\n    e.preventDefault();\n    e.stopPropagation();\n    if (e.type === \"dragenter\" || e.type === \"dragover\") {\n      setDragActive(true);\n    } else if (e.type === \"dragleave\") {\n      setDragActive(false);\n    }\n  }, []);\n\n  const handleDrop = useCallback((e: React.DragEvent) => {\n    e.preventDefault();\n    setDragActive(false);\n    \n    const files = e.dataTransfer.files;\n    if (files && files[0]) {\n      handleFileSelect(files[0]);\n    }\n  }, [handleFileSelect]);\n\n  const handleFileInput = useCallback((e: React.ChangeEvent<HTMLInputElement>) => {\n    const files = e.target.files;\n    if (files && files[0]) {\n      handleFileSelect(files[0]);\n    }\n  }, [handleFileSelect]);\n\n  // Import frames to canvas\n  const handleImportToCanvas = useCallback(async () => {\n    if (previewFrames.length === 0) return;\n    \n    // End preview mode before importing (restores original canvas data)\n    endPreview();\n    \n    setIsImporting(true);\n    try {\n      const conversionSettings = createConversionSettings();\n\n      if (previewFrames.length === 1) {\n        // Single image - always replace current frame\n        const result = asciiConverter.convertFrame(previewFrames[0], conversionSettings);\n        const positionedCells = positionCellsOnCanvas(result.cells, settings.characterWidth, settings.characterHeight);\n        clearCanvas();\n        setCanvasData(positionedCells);\n        setLivePreviewEnabled(false);\n      } else {\n        // Multiple frames - use import mode\n        \n        // Convert all frames first\n        const frameData: Array<{ data: Map<string, Cell>, duration: number }> = [];\n        for (let i = 0; i < previewFrames.length; i++) {\n          const result = asciiConverter.convertFrame(previewFrames[i], conversionSettings);\n          const positionedCells = positionCellsOnCanvas(result.cells, settings.characterWidth, settings.characterHeight);\n          const frameDuration = previewFrames[i].frameDuration || 100; // Default duration if not available\n          \n          frameData.push({\n            data: positionedCells,\n            duration: frameDuration\n          });\n        }\n        \n        // Apply import mode\n        if (importMode === 'overwrite') {\n          // Overwrite mode - replace frames starting from current position\n          importFramesOverwrite(frameData, currentFrameIndex);\n          // Manually update canvas with first imported frame data after store update\n          setTimeout(() => {\n            setCanvasData(frameData[0].data);\n          }, 0);\n        } else {\n          // Append mode - clear canvas and add frames to end\n          clearCanvas();\n          importFramesAppend(frameData);\n          // Canvas will be updated by the animation store when it changes current frame\n        }\n        \n        setLivePreviewEnabled(false);\n      }\n      \n      // Close panel on successful import\n      closeModal();\n    } catch (err) {\n      setError(err instanceof Error ? err.message : 'Failed to import to canvas');\n    } finally {\n      setIsImporting(false);\n    }\n  }, [previewFrames, settings, clearCanvas, setCanvasData, addFrame, setCurrentFrame, updateFrameDuration, closeModal, setError, positionCellsOnCanvas, importMode, importFramesOverwrite, importFramesAppend, currentFrameIndex, endPreview]);\n\n  // Get file icon based on type\n  const getFileIcon = (mediaFile: MediaFile) => {\n    if (mediaFile.type === 'image') {\n      return <ImageIcon className=\"w-6 h-6 text-blue-500\" />;\n    } else {\n      return <Video className=\"w-6 h-6 text-purple-500\" />;\n    }\n  };\n\n  // Format file size\n  const formatFileSize = (bytes: number) => {\n    const units = ['B', 'KB', 'MB', 'GB'];\n    let size = bytes;\n    let unitIndex = 0;\n    \n    while (size >= 1024 && unitIndex < units.length - 1) {\n      size /= 1024;\n      unitIndex++;\n    }\n    \n    return `${size.toFixed(1)} ${units[unitIndex]}`;\n  };\n\n  return (\n    <div className={cn(\n      \"fixed inset-y-0 right-0 w-80 bg-background border-l border-border shadow-lg z-50 flex flex-col overflow-hidden\",\n      PANEL_ANIMATION.TRANSITION,\n      isOpen ? \"translate-x-0\" : \"translate-x-full\"\n    )}>\n      {/* Header */}\n      <div className=\"flex items-center justify-between p-3 border-b border-border\">\n        <h2 className=\"text-sm font-medium flex items-center gap-2\">\n          <Upload className=\"w-3 h-3\" />\n          Import Media\n        </h2>\n        <Button\n          variant=\"ghost\"\n          size=\"sm\"\n          onClick={closeModal}\n          className=\"h-6 w-6 p-0\"\n        >\n          <X className=\"w-3 h-3\" />\n        </Button>\n      </div>\n\n      <ScrollArea className=\"flex-1 overflow-x-hidden\">\n        <div className=\"p-3 space-y-3\">\n          {/* File Upload Section */}\n          {!selectedFile && (\n            <div className=\"min-h-[calc(100vh-120px)] flex items-center justify-center\">\n              <div className=\"w-full\">\n                <div\n                  className={`relative border-2 border-dashed rounded-lg p-4 text-center transition-colors ${\n                    dragActive \n                      ? 'border-primary bg-primary/10' \n                      : 'border-muted-foreground/25 hover:border-primary/50'\n                  }`}\n                  onDragEnter={handleDrag}\n                onDragLeave={handleDrag}\n                onDragOver={handleDrag}\n                onDrop={handleDrop}\n              >\n              <Upload className=\"w-6 h-6 mx-auto mb-2 text-muted-foreground\" />\n              <h3 className=\"text-sm font-medium mb-1\">\n                {dragActive ? 'Drop file here' : 'Upload Media'}\n              </h3>\n              <p className=\"text-xs text-muted-foreground mb-2\">\n                Drag and drop or click to browse\n              </p>\n              \n              <Button variant=\"outline\" size=\"sm\" className=\"h-8 mb-2\">\n                <label htmlFor=\"media-file-input\" className=\"cursor-pointer text-xs\">\n                  Choose File\n                </label>\n              </Button>\n              \n              <input\n                id=\"media-file-input\"\n                type=\"file\"\n                className=\"hidden\"\n                accept={[...SUPPORTED_IMAGE_FORMATS, ...SUPPORTED_VIDEO_FORMATS].join(',')}\n                onChange={handleFileInput}\n              />\n              \n              <div className=\"text-xs text-muted-foreground space-y-0\">\n                <p>Images: JPG, PNG, GIF, BMP, WebP, SVG</p>\n                <p>Videos: MP4, WebM, OGG, AVI, MOV, WMV</p>\n              </div>\n                </div>\n              </div>\n            </div>\n          )}\n\n          {/* Selected File Info */}\n          {selectedFile && (\n            <>\n              <div className=\"flex items-center gap-2 p-2 border rounded-lg\">\n                {getFileIcon(selectedFile)}\n                <div className=\"flex-1 min-w-0\">\n                  <h3 className=\"text-xs font-medium truncate\">{selectedFile.name}</h3>\n                  <p className=\"text-xs text-muted-foreground\">\n                    {selectedFile.type} • {formatFileSize(selectedFile.size)}\n                  </p>\n                </div>\n                <Button\n                  variant=\"ghost\"\n                  size=\"sm\"\n                  onClick={() => {\n                    setSelectedFile(null);\n                    setLivePreviewEnabled(true); // Reset to default\n                  }}\n                  className=\"h-6 w-6 p-0\"\n                >\n                  <FileX className=\"w-3 h-3\" />\n                </Button>\n              </div>\n              \n              {/* Preview Section */}\n              <Collapsible open={previewSectionOpen} onOpenChange={setPreviewSectionOpen}>\n                <CollapsibleHeader isOpen={previewSectionOpen}>\n                  <div className=\"flex items-center gap-2\">\n                    <Eye className=\"w-4 h-4 text-muted-foreground\" />\n                    <span>Preview</span>\n                  </div>\n                </CollapsibleHeader>\n                \n                <CollapsibleContent className=\"collapsible-content\">\n                  <div className=\"space-y-3\">\n                    <div className=\"flex items-center justify-between p-2 bg-muted/50 rounded-lg\">\n                      <div className=\"flex items-center space-x-2\">\n                        <Checkbox\n                          id=\"live-preview-main\"\n                          checked={livePreviewEnabled}\n                          onCheckedChange={(checked) => setLivePreviewEnabled(!!checked)}\n                        />\n                        <Label htmlFor=\"live-preview-main\" className=\"text-xs\">\n                          Auto-process & Preview\n                        </Label>\n                      </div>\n                      {livePreviewEnabled && (\n                        <div className=\"flex items-center gap-1\">\n                          {isProcessing ? (\n                            <Spinner size=\"xs\" variant=\"primary\" />\n                          ) : (\n                            <span className=\"text-xs text-green-500 font-medium\">\n                              Live\n                            </span>\n                          )}\n                        </div>\n                      )}\n                    </div>\n\n                    {/* Frame Navigation */}\n                    {previewFrames.length > 0 && (\n                      <div className=\"p-2 bg-muted/30 rounded-lg\">\n                        {previewFrames.length === 1 && (\n                          <div className=\"flex items-center justify-center\">\n                            <span className=\"text-xs\">\n                              Preview frame 1 of 1\n                            </span>\n                          </div>\n                        )}\n                        \n                        {previewFrames.length > 1 && (\n                          <TooltipProvider>\n                            <div className=\"flex items-center justify-between gap-1\">\n                              <Tooltip>\n                                <TooltipTrigger asChild>\n                                  <Button\n                                    variant=\"outline\"\n                                    size=\"sm\"\n                                    onClick={() => setFrameIndex(0)}\n                                    disabled={frameIndex === 0}\n                                    className=\"h-6 w-6 p-0\"\n                                  >\n                                    <ChevronsLeft className=\"w-3 h-3\" />\n                                  </Button>\n                                </TooltipTrigger>\n                                <TooltipContent>\n                                  <p>First frame</p>\n                                </TooltipContent>\n                              </Tooltip>\n                              <Tooltip>\n                                <TooltipTrigger asChild>\n                                  <Button\n                                    variant=\"outline\"\n                                    size=\"sm\"\n                                    onClick={() => setFrameIndex(Math.max(0, frameIndex - 1))}\n                                    disabled={frameIndex === 0}\n                                    className=\"h-6 w-6 p-0\"\n                                  >\n                                    <ChevronLeft className=\"w-3 h-3\" />\n                                  </Button>\n                                </TooltipTrigger>\n                                <TooltipContent>\n                                  <p>Previous frame</p>\n                                </TooltipContent>\n                              </Tooltip>\n                              <span className=\"text-xs flex-1 text-center\">\n                                Preview Frame {frameIndex + 1} of {previewFrames.length}\n                              </span>\n                              <Tooltip>\n                                <TooltipTrigger asChild>\n                                  <Button\n                                    variant=\"outline\"\n                                    size=\"sm\"\n                                    onClick={() => setFrameIndex(Math.min(previewFrames.length - 1, frameIndex + 1))}\n                                    disabled={frameIndex === previewFrames.length - 1}\n                                    className=\"h-6 w-6 p-0\"\n                                  >\n                                    <ChevronRight className=\"w-3 h-3\" />\n                                  </Button>\n                                </TooltipTrigger>\n                                <TooltipContent>\n                                  <p>Next frame</p>\n                                </TooltipContent>\n                              </Tooltip>\n                              <Tooltip>\n                                <TooltipTrigger asChild>\n                                  <Button\n                                    variant=\"outline\"\n                                    size=\"sm\"\n                                    onClick={() => setFrameIndex(previewFrames.length - 1)}\n                                    disabled={frameIndex === previewFrames.length - 1}\n                                    className=\"h-6 w-6 p-0\"\n                                  >\n                                    <ChevronsRight className=\"w-3 h-3\" />\n                                  </Button>\n                                </TooltipTrigger>\n                                <TooltipContent>\n                                  <p>Last frame</p>\n                                </TooltipContent>\n                              </Tooltip>\n                            </div>\n                          </TooltipProvider>\n                        )}\n\n                        {/* Video Scrubbing Slider */}\n                        {previewFrames.length > 1 && (\n                          <div className=\"mt-3 space-y-2\">\n                            <div className=\"relative\">\n                              <Slider\n                                value={frameIndex}\n                                onValueChange={(value) => setFrameIndex(value)}\n                                min={0}\n                                max={previewFrames.length - 1}\n                                step={1}\n                                className=\"w-full\"\n                              />\n                              {/* Tick marks for frames */}\n                              <div className=\"absolute top-6 left-0 right-0 pointer-events-none\">\n                                {Array.from({ length: previewFrames.length }, (_, i) => {\n                                  // Slider thumb is 12px wide (h-3 w-3), so half width is 6px\n                                  const thumbHalfWidth = 6;\n                                  const position = previewFrames.length === 1 ? 0.5 : i / (previewFrames.length - 1);\n                                  \n                                  return (\n                                    <div\n                                      key={i}\n                                      className=\"absolute w-px h-2 bg-muted-foreground/40\"\n                                      style={{ \n                                        left: `calc(${thumbHalfWidth}px + ${position} * (100% - ${thumbHalfWidth * 2}px))`,\n                                        transform: 'translateX(-0.5px)'\n                                      }}\n                                    />\n                                  );\n                                })}\n                              </div>\n                            </div>\n                          </div>\n                        )}\n                      </div>\n                    )}\n                  </div>\n                </CollapsibleContent>\n              </Collapsible>\n              \n              <PanelSeparator marginX=\"3\" className=\"my-4\" />\n              \n              {/* Position & Size Section */}\n              <Collapsible open={positionSectionOpen} onOpenChange={setPositionSectionOpen}>\n                <CollapsibleHeader isOpen={positionSectionOpen}>\n                  <div className=\"flex items-center gap-2\">\n                    <Move3D className=\"w-4 h-4 text-muted-foreground\" />\n                    <span>Position & Size</span>\n                  </div>\n                </CollapsibleHeader>\n                \n                <CollapsibleContent className=\"collapsible-content\">\n                  <div className=\"space-y-3\">\n                    {/* Image Size Controls */}\n                    <div className=\"space-y-2\">\n                      <Label className=\"text-xs font-medium\">Image Size (characters)</Label>\n                      \n                      <div className=\"flex gap-2 items-end\">\n                        <div className=\"flex-1\">\n                          <Label htmlFor=\"char-width\" className=\"text-xs\">Width</Label>\n                          <div className=\"flex\">\n                            <Input\n                              id=\"char-width\"\n                              type=\"number\"\n                              min=\"1\"\n                              value={settings.characterWidth}\n                              onChange={(e) => handleWidthChange(parseInt(e.target.value) || 1)}\n                              className=\"h-8 text-xs rounded-r-none [appearance:textfield] [&::-webkit-outer-spin-button]:appearance-none [&::-webkit-inner-spin-button]:appearance-none\"\n                            />\n                            <div className=\"flex flex-col\">\n                              <Button\n                                type=\"button\"\n                                variant=\"outline\"\n                                size=\"sm\"\n                                onClick={() => handleWidthChange(settings.characterWidth + 1)}\n                                className=\"h-4 w-6 p-0 rounded-l-none rounded-br-none border-l-0 text-xs\"\n                              >\n                                +\n                              </Button>\n                              <Button\n                                type=\"button\"\n                                variant=\"outline\"\n                                size=\"sm\"\n                                onClick={() => handleWidthChange(Math.max(1, settings.characterWidth - 1))}\n                                className=\"h-4 w-6 p-0 rounded-l-none rounded-tr-none border-l-0 border-t-0 text-xs\"\n                              >\n                                −\n                              </Button>\n                            </div>\n                          </div>\n                        </div>\n                        <div className=\"flex-1\">\n                          <Label htmlFor=\"char-height\" className=\"text-xs\">Height</Label>\n                          <div className=\"flex\">\n                            <Input\n                              id=\"char-height\"\n                              type=\"number\"\n                              min=\"1\"\n                              value={settings.characterHeight}\n                              onChange={(e) => handleHeightChange(parseInt(e.target.value) || 1)}\n                              className=\"h-8 text-xs rounded-r-none [appearance:textfield] [&::-webkit-outer-spin-button]:appearance-none [&::-webkit-inner-spin-button]:appearance-none\"\n                            />\n                            <div className=\"flex flex-col\">\n                              <Button\n                                type=\"button\"\n                                variant=\"outline\"\n                                size=\"sm\"\n                                onClick={() => handleHeightChange(settings.characterHeight + 1)}\n                                className=\"h-4 w-6 p-0 rounded-l-none rounded-br-none border-l-0 text-xs\"\n                              >\n                                +\n                              </Button>\n                              <Button\n                                type=\"button\"\n                                variant=\"outline\"\n                                size=\"sm\"\n                                onClick={() => handleHeightChange(Math.max(1, settings.characterHeight - 1))}\n                                className=\"h-4 w-6 p-0 rounded-l-none rounded-tr-none border-l-0 border-t-0 text-xs\"\n                              >\n                                −\n                              </Button>\n                            </div>\n                          </div>\n                        </div>\n                        <div className=\"flex items-end\">\n                          <TooltipProvider>\n                            <Tooltip>\n                              <TooltipTrigger asChild>\n                                <Button\n                                  type=\"button\"\n                                  variant={settings.maintainAspectRatio ? \"default\" : \"outline\"}\n                                  size=\"sm\"\n                                  onClick={() => updateSettings({ maintainAspectRatio: !settings.maintainAspectRatio })}\n                                  disabled={!originalImageAspectRatio}\n                                  className=\"h-8 w-8 p-0\"\n                                >\n                                  <Link className=\"w-3 h-3\" />\n                                </Button>\n                              </TooltipTrigger>\n                              <TooltipContent>\n                                <p>{settings.maintainAspectRatio ? \"Unlink aspect ratio\" : \"Maintain original image aspect ratio\"}</p>\n                              </TooltipContent>\n                            </Tooltip>\n                          </TooltipProvider>\n                        </div>\n                      </div>\n                      \n                      <div className=\"text-xs text-muted-foreground\">\n                        Canvas: {canvasWidth} × {canvasHeight} characters\n                      </div>\n                    </div>\n                    \n                    {/* Alignment & Nudge Controls - Two Equal Columns */}\n                    <div className=\"grid grid-cols-2 gap-2\">\n                      {/* Alignment Section */}\n                      <div className=\"flex flex-col items-center space-y-2\">\n                        <Label className=\"text-xs font-medium\">Alignment</Label>\n                        <TooltipProvider>\n                          <div className=\"grid grid-cols-3 gap-[3px]\">\n                            {[\n                              { mode: 'top-left', tooltip: 'Top Left' },\n                              { mode: 'top', tooltip: 'Top Center' },\n                              { mode: 'top-right', tooltip: 'Top Right' },\n                              { mode: 'left', tooltip: 'Center Left' },\n                              { mode: 'center', tooltip: 'Center' },\n                              { mode: 'right', tooltip: 'Center Right' },\n                              { mode: 'bottom-left', tooltip: 'Bottom Left' },\n                              { mode: 'bottom', tooltip: 'Bottom Center' },\n                              { mode: 'bottom-right', tooltip: 'Bottom Right' }\n                            ].map(({ mode, tooltip }) => {\n                              const isActive = settings.cropMode === mode;\n                              return (\n                                <Tooltip key={mode}>\n                                  <TooltipTrigger asChild>\n                                    <Button\n                                      variant=\"ghost\"\n                                      size=\"sm\"\n                                      onClick={() => updateSettings({ cropMode: mode as any })}\n                                      className={`h-6 w-6 p-0 transition-colors ${\n                                        isActive \n                                          ? 'bg-purple-500 text-white hover:bg-purple-600' \n                                          : 'bg-background hover:bg-muted border border-border'\n                                      }`}\n                                    >\n                                      {isActive ? (\n                                        <svg className=\"w-2 h-2\" fill=\"currentColor\" viewBox=\"0 0 20 20\">\n                                          <path fillRule=\"evenodd\" d=\"M16.707 5.293a1 1 0 010 1.414l-8 8a1 1 0 01-1.414 0l-4-4a1 1 0 011.414-1.414L8 12.586l7.293-7.293a1 1 0 011.414 0z\" clipRule=\"evenodd\" />\n                                        </svg>\n                                      ) : (\n                                        <svg className=\"w-2 h-2\" fill=\"currentColor\" viewBox=\"0 0 20 20\">\n                                          <path fillRule=\"evenodd\" d=\"M3 10a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1z\" clipRule=\"evenodd\" />\n                                        </svg>\n                                      )}\n                                    </Button>\n                                  </TooltipTrigger>\n                                  <TooltipContent>\n                                    <p>{tooltip}</p>\n                                  </TooltipContent>\n                                </Tooltip>\n                              );\n                            })}\n                          </div>\n                        </TooltipProvider>\n                        {/* Show current alignment mode */}\n                        <div className=\"text-xs text-muted-foreground\">\n                          {(() => {\n                            const alignmentMap = {\n                              'top-left': 'Top Left',\n                              'top': 'Top Center', \n                              'top-right': 'Top Right',\n                              'left': 'Center Left',\n                              'center': 'Center',\n                              'right': 'Center Right',\n                              'bottom-left': 'Bottom Left',\n                              'bottom': 'Bottom Center',\n                              'bottom-right': 'Bottom Right'\n                            };\n                            return alignmentMap[settings.cropMode] || settings.cropMode;\n                          })()}\n                        </div>\n                      </div>\n                      \n                      {/* Nudge Section */}\n                      <div className=\"flex flex-col items-center space-y-2\">\n                        <Label className=\"text-xs font-medium\">Nudge</Label>\n                        <TooltipProvider>\n                          <div className=\"grid grid-cols-3 gap-[3px]\">\n                            {/* Top row */}\n                            <div></div>\n                            <Tooltip>\n                              <TooltipTrigger asChild>\n                                <Button\n                                  variant=\"outline\"\n                                  size=\"sm\"\n                                  onClick={() => updateSettings({ nudgeY: settings.nudgeY - 1 })}\n                                  className=\"h-6 w-6 p-0\"\n                                >\n                                  <ArrowUp className=\"w-3 h-3\" />\n                                </Button>\n                              </TooltipTrigger>\n                              <TooltipContent>\n                                <p>Nudge up</p>\n                              </TooltipContent>\n                            </Tooltip>\n                            <div></div>\n                            \n                            {/* Middle row */}\n                            <Tooltip>\n                              <TooltipTrigger asChild>\n                                <Button\n                                  variant=\"outline\"\n                                  size=\"sm\"\n                                  onClick={() => updateSettings({ nudgeX: settings.nudgeX - 1 })}\n                                  className=\"h-6 w-6 p-0\"\n                                >\n                                  <ArrowLeft className=\"w-3 h-3\" />\n                                </Button>\n                              </TooltipTrigger>\n                              <TooltipContent>\n                                <p>Nudge left</p>\n                              </TooltipContent>\n                            </Tooltip>\n                            <Tooltip>\n                              <TooltipTrigger asChild>\n                                <Button\n                                  variant=\"outline\"\n                                  size=\"sm\"\n                                  onClick={() => updateSettings({ nudgeX: 0, nudgeY: 0 })}\n                                  className=\"h-6 w-6 p-0\"\n                                  disabled={settings.nudgeX === 0 && settings.nudgeY === 0}\n                                >\n                                  <RotateCcw className=\"w-3 h-3\" />\n                                </Button>\n                              </TooltipTrigger>\n                              <TooltipContent>\n                                <p>Reset nudge</p>\n                              </TooltipContent>\n                            </Tooltip>\n                            <Tooltip>\n                              <TooltipTrigger asChild>\n                                <Button\n                                  variant=\"outline\"\n                                  size=\"sm\"\n                                  onClick={() => updateSettings({ nudgeX: settings.nudgeX + 1 })}\n                                  className=\"h-6 w-6 p-0\"\n                                >\n                                  <ArrowRight className=\"w-3 h-3\" />\n                                </Button>\n                              </TooltipTrigger>\n                              <TooltipContent>\n                                <p>Nudge right</p>\n                              </TooltipContent>\n                            </Tooltip>\n                            \n                            {/* Bottom row */}\n                            <div></div>\n                            <Tooltip>\n                              <TooltipTrigger asChild>\n                                <Button\n                                  variant=\"outline\"\n                                  size=\"sm\"\n                                  onClick={() => updateSettings({ nudgeY: settings.nudgeY + 1 })}\n                                  className=\"h-6 w-6 p-0\"\n                                >\n                                  <ArrowDown className=\"w-3 h-3\" />\n                                </Button>\n                              </TooltipTrigger>\n                              <TooltipContent>\n                                <p>Nudge down</p>\n                              </TooltipContent>\n                            </Tooltip>\n                            <div></div>\n                          </div>\n                        </TooltipProvider>\n                        {/* Show current nudge values */}\n                        <div className=\"text-xs text-muted-foreground\">\n                          ({settings.nudgeX}, {settings.nudgeY})\n                        </div>\n                      </div>\n                    </div>\n                  </div>\n                </CollapsibleContent>\n              </Collapsible>\n\n              {/* Pre-processing Section */}\n              <PanelSeparator marginX=\"3\" />\n              <PreprocessingSection onSettingsChange={() => setLivePreviewEnabled(true)} />\n\n              {/* Character Mapping Section */}\n              <PanelSeparator marginX=\"3\" />\n              <CharacterMappingSection onSettingsChange={() => setLivePreviewEnabled(true)} />\n\n              {/* Text Color Mapping Section */}\n              <PanelSeparator marginX=\"3\" />\n              <TextColorMappingSection onSettingsChange={() => setLivePreviewEnabled(true)} />\n\n              {/* Background Color Mapping Section */}\n              <PanelSeparator marginX=\"3\" />\n              <BackgroundColorMappingSection onSettingsChange={() => setLivePreviewEnabled(true)} />\n              \n              <PanelSeparator marginX=\"3\" />\n              \n              {/* Processing Progress */}\n              {isProcessing && (\n                <div>\n                  <div className=\"flex justify-between text-xs mb-1\">\n                    <span>Processing...</span>\n                    <span>{progress}%</span>\n                  </div>\n                  <Progress value={progress} className=\"h-1\" />\n                </div>\n              )}\n            </>\n          )}\n\n          {/* Error Display */}\n          {error && (\n            <Alert variant=\"destructive\">\n              <AlertDescription className=\"text-xs\">{error}</AlertDescription>\n            </Alert>\n          )}\n\n\n        </div>\n      </ScrollArea>\n\n      {/* Footer with Import Mode and Button */}\n      {previewFrames.length > 0 && (\n        <div className=\"p-3 border-t border-border space-y-3\">\n          {/* Import Mode Selection */}\n          <div className=\"space-y-2\">\n            <Label className=\"text-xs font-medium\">Import Mode</Label>\n            <div className=\"grid grid-cols-2 gap-2\">\n              <Button\n                variant={importMode === 'overwrite' ? 'default' : 'outline'}\n                size=\"sm\"\n                onClick={() => setImportMode('overwrite')}\n                className=\"h-8 text-xs\"\n              >\n                Overwrite\n              </Button>\n              <Button\n                variant={importMode === 'append' ? 'default' : 'outline'}\n                size=\"sm\"\n                onClick={() => setImportMode('append')}\n                className=\"h-8 text-xs\"\n              >\n                Append\n              </Button>\n            </div>\n            <div className=\"text-xs text-muted-foreground\">\n              {importMode === 'overwrite' \n                ? 'Replace frames starting from current frame'\n                : 'Add frames after the last existing frame'\n              }\n            </div>\n          </div>\n          \n          <Button \n            onClick={handleImportToCanvas}\n            disabled={isImporting}\n            className=\"w-full h-8\"\n            size=\"sm\"\n          >\n            <Download className=\"w-3 h-3 mr-2\" />\n            {isImporting ? 'Importing...' : 'Import to Canvas'}\n          </Button>\n        </div>\n      )}\n    </div>\n  );\n}","usedDeprecatedRules":[]},{"filePath":"/Users/cameronfoxly/GitHubRepos/Ascii-Motion/src/components/features/OnionSkinControls.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/cameronfoxly/GitHubRepos/Ascii-Motion/src/components/features/PastePreviewOverlay.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/cameronfoxly/GitHubRepos/Ascii-Motion/src/components/features/PlaybackControls.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/cameronfoxly/GitHubRepos/Ascii-Motion/src/components/features/PlaybackOverlay.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/cameronfoxly/GitHubRepos/Ascii-Motion/src/components/features/PreprocessingSection.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/cameronfoxly/GitHubRepos/Ascii-Motion/src/components/features/ReactExportDialog.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/cameronfoxly/GitHubRepos/Ascii-Motion/src/components/features/SessionExportDialog.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/cameronfoxly/GitHubRepos/Ascii-Motion/src/components/features/TextColorMappingSection.tsx","messages":[{"ruleId":"prefer-const","severity":2,"message":"'currentIndex' is never reassigned. Use 'const' instead.","line":344,"column":9,"nodeType":"Identifier","messageId":"useConst","endLine":344,"endColumn":21,"fix":{"range":[10924,10955],"text":"const currentIndex = sourceIndex;"}},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":469,"column":57,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":469,"endColumn":60,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[16096,16099],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[16096,16099],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":487,"column":51,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":487,"endColumn":54,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[17102,17105],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[17102,17105],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":1,"fixableWarningCount":0,"source":"/**\n * TextColorMappingSection - Collapsible section for text color palette mapping controls\n * \n * Features:\n * - Collapsible header with enable/disable toggle\n * - Full palette editing: color swatches, inline editing, reordering, reverse button\n * - Palette manager integration for sharing palettes between editors\n * - Consistent UI patterns following main app palette component\n */\n\nimport { useState, useMemo } from 'react';\nimport { Button } from '../ui/button';\nimport { Label } from '../ui/label';\nimport { Card, CardContent } from '../ui/card';\nimport { \n  Select,\n  SelectContent,\n  SelectItem,\n  SelectSeparator,\n  SelectTrigger,\n  SelectValue,\n} from '../ui/select';\nimport { \n  Collapsible,\n  CollapsibleContent,\n  CollapsibleTrigger,\n} from '../ui/collapsible';\n\nimport { Checkbox } from '../ui/checkbox';\nimport { Tooltip, TooltipContent, TooltipProvider, TooltipTrigger } from '../ui/tooltip';\nimport { \n  Type, \n  Plus,\n  Trash2,\n  ChevronLeft,\n  ChevronRight,\n  ArrowUpDown,\n  Settings,\n  Upload,\n  Download,\n  Edit,\n  ChevronDown\n} from 'lucide-react';\nimport { usePaletteStore } from '../../stores/paletteStore';\nimport { useImportSettings } from '../../stores/importStore';\nimport { ColorPickerOverlay } from './ColorPickerOverlay';\nimport { ManagePalettesDialog } from './ManagePalettesDialog';\nimport { ImportPaletteDialog } from './ImportPaletteDialog';\nimport { ExportPaletteDialog } from './ExportPaletteDialog';\n\ninterface TextColorMappingSectionProps {\n  onSettingsChange?: () => void;\n}\n\nexport function TextColorMappingSection({ onSettingsChange }: TextColorMappingSectionProps) {\n  const [isOpen, setIsOpen] = useState(false);\n  const [isColorPickerOpen, setIsColorPickerOpen] = useState(false);\n  const [colorPickerInitialColor, setColorPickerInitialColor] = useState('#000000');\n  const [editingColorId, setEditingColorId] = useState<string | null>(null);\n  const [isManagePalettesOpen, setIsManagePalettesOpen] = useState(false);\n  const [isImportDialogOpen, setIsImportDialogOpen] = useState(false);\n  const [isExportDialogOpen, setIsExportDialogOpen] = useState(false);\n  \n  // Drag and drop state\n  const [draggedColorId, setDraggedColorId] = useState<string | null>(null);\n  const [dropIndicatorIndex, setDropIndicatorIndex] = useState<number | null>(null);\n  \n  // Import settings\n  const { settings, updateSettings } = useImportSettings();\n  const {\n    enableTextColorMapping,\n    textColorPaletteId,\n    textColorMappingMode\n  } = settings;\n  \n  // Color palette store integration\n  const { \n    palettes,\n    customPalettes,\n    selectedColorId,\n    setSelectedColor,\n    addColor,\n    removeColor,\n    updateColor,\n    moveColorLeft,\n    moveColorRight,\n    reversePalette,\n    createCustomCopy,\n  } = usePaletteStore();\n  \n  // Get the currently selected palette for text color mapping\n  const selectedPalette = useMemo(() => {\n    const allPalettes = [...palettes, ...customPalettes];\n    return allPalettes.find(p => p.id === textColorPaletteId);\n  }, [palettes, customPalettes, textColorPaletteId]);\n\n  const handleToggleEnabled = (enabled: boolean) => {\n    updateSettings({ enableTextColorMapping: enabled });\n    onSettingsChange?.();\n  };\n  \n  const handlePaletteChange = (paletteId: string) => {\n    updateSettings({ textColorPaletteId: paletteId });\n    onSettingsChange?.();\n  };\n  \n  const handleMappingModeChange = (mode: 'closest' | 'dithering' | 'by-index') => {\n    updateSettings({ textColorMappingMode: mode });\n    onSettingsChange?.();\n  };\n\n  // Color palette editing handlers\n  const handleColorDoubleClick = (color: string) => {\n    if (!selectedPalette) return;\n    \n    // If it's a preset palette, create a custom copy first\n    if (selectedPalette.isPreset) {\n      const newPaletteId = createCustomCopy(selectedPalette.id);\n      if (newPaletteId) {\n        // Switch to the new custom palette\n        updateSettings({ textColorPaletteId: newPaletteId });\n        // Find the color in the new palette and edit it\n        const newPalette = customPalettes.find(p => p.id === newPaletteId);\n        if (newPalette) {\n          const colorObj = newPalette.colors.find(c => c.value === color);\n          if (colorObj) {\n            setEditingColorId(colorObj.id);\n            setColorPickerInitialColor(color);\n            setIsColorPickerOpen(true);\n          }\n        }\n        onSettingsChange?.();\n      }\n      return;\n    }\n    \n    // For custom palettes, edit directly\n    const colorObj = selectedPalette.colors.find(c => c.value === color);\n    if (colorObj) {\n      setEditingColorId(colorObj.id);\n      setColorPickerInitialColor(color);\n      setIsColorPickerOpen(true);\n    }\n  };\n\n  const handleColorPickerSelect = (newColor: string) => {\n    if (editingColorId && selectedPalette) {\n      updateColor(selectedPalette.id, editingColorId, newColor);\n      setEditingColorId(null);\n      onSettingsChange?.();\n    }\n  };\n\n  const handleEditColor = () => {\n    if (!selectedColorId || !selectedPalette) return;\n    \n    const colorObj = selectedPalette.colors.find(c => c.id === selectedColorId);\n    if (!colorObj) return;\n    \n    // If it's a preset palette, create a custom copy first\n    if (selectedPalette.isPreset) {\n      const newPaletteId = createCustomCopy(selectedPalette.id);\n      if (newPaletteId) {\n        updateSettings({ textColorPaletteId: newPaletteId });\n        // Find the color in the new palette and edit it\n        const newPalette = customPalettes.find(p => p.id === newPaletteId);\n        if (newPalette) {\n          const newColorObj = newPalette.colors.find(c => c.value === colorObj.value);\n          if (newColorObj) {\n            setEditingColorId(newColorObj.id);\n            setColorPickerInitialColor(colorObj.value);\n            setIsColorPickerOpen(true);\n          }\n        }\n        onSettingsChange?.();\n      }\n      return;\n    }\n    \n    // For custom palettes, edit directly\n    setEditingColorId(colorObj.id);\n    setColorPickerInitialColor(colorObj.value);\n    setIsColorPickerOpen(true);\n  };\n\n  const handleAddColor = () => {\n    if (!selectedPalette) return;\n    \n    // If it's a preset palette, create a custom copy first\n    if (selectedPalette.isPreset) {\n      const newPaletteId = createCustomCopy(selectedPalette.id);\n      if (newPaletteId) {\n        updateSettings({ textColorPaletteId: newPaletteId });\n        addColor(newPaletteId, '#ffffff');\n        onSettingsChange?.();\n      }\n      return;\n    }\n    \n    addColor(selectedPalette.id, '#ffffff');\n    onSettingsChange?.();\n  };\n\n  const handleRemoveColor = (colorId: string) => {\n    if (!selectedPalette || selectedPalette.colors.length <= 1) return;\n    \n    // If it's a preset palette, create a custom copy first\n    if (selectedPalette.isPreset) {\n      const newPaletteId = createCustomCopy(selectedPalette.id);\n      if (newPaletteId) {\n        updateSettings({ textColorPaletteId: newPaletteId });\n        removeColor(newPaletteId, colorId);\n        onSettingsChange?.();\n      }\n      return;\n    }\n    \n    removeColor(selectedPalette.id, colorId);\n    onSettingsChange?.();\n  };\n\n  const handleMoveColorLeft = (colorId: string) => {\n    if (!selectedPalette) return;\n    \n    // If it's a preset palette, create a custom copy first\n    if (selectedPalette.isPreset) {\n      const newPaletteId = createCustomCopy(selectedPalette.id);\n      if (newPaletteId) {\n        updateSettings({ textColorPaletteId: newPaletteId });\n        moveColorLeft(newPaletteId, colorId);\n        onSettingsChange?.();\n      }\n      return;\n    }\n    \n    moveColorLeft(selectedPalette.id, colorId);\n    onSettingsChange?.();\n  };\n\n  const handleMoveColorRight = (colorId: string) => {\n    if (!selectedPalette) return;\n    \n    // If it's a preset palette, create a custom copy first\n    if (selectedPalette.isPreset) {\n      const newPaletteId = createCustomCopy(selectedPalette.id);\n      if (newPaletteId) {\n        updateSettings({ textColorPaletteId: newPaletteId });\n        moveColorRight(newPaletteId, colorId);\n        onSettingsChange?.();\n      }\n      return;\n    }\n    \n    moveColorRight(selectedPalette.id, colorId);\n    onSettingsChange?.();\n  };\n\n  const handleReversePalette = () => {\n    if (!selectedPalette) return;\n    \n    // If it's a preset palette, create a custom copy first\n    if (selectedPalette.isPreset) {\n      const newPaletteId = createCustomCopy(selectedPalette.id);\n      if (newPaletteId) {\n        updateSettings({ textColorPaletteId: newPaletteId });\n        reversePalette(newPaletteId);\n        onSettingsChange?.();\n      }\n      return;\n    }\n    \n    reversePalette(selectedPalette.id);\n    onSettingsChange?.();\n  };\n\n  // Handle drag start\n  const handleDragStart = (e: React.DragEvent, colorId: string) => {\n    if (!selectedPalette) {\n      e.preventDefault();\n      return;\n    }\n    setDraggedColorId(colorId);\n    e.dataTransfer.effectAllowed = 'move';\n  };\n\n  // Handle drag over\n  const handleDragOver = (e: React.DragEvent, targetColorId?: string) => {\n    if (!selectedPalette || !draggedColorId) return;\n    e.preventDefault();\n    e.dataTransfer.dropEffect = 'move';\n    \n    if (targetColorId) {\n      const targetIndex = selectedPalette.colors.findIndex(c => c.id === targetColorId);\n      if (targetIndex !== -1) {\n        // Determine if we should show indicator before or after based on mouse position\n        const rect = (e.target as HTMLElement).getBoundingClientRect();\n        const mouseX = e.clientX - rect.left;\n        const isAfter = mouseX > rect.width / 2;\n        setDropIndicatorIndex(isAfter ? targetIndex + 1 : targetIndex);\n      }\n    }\n  };\n\n  // Handle drop\n  const handleDrop = (e: React.DragEvent, targetColorId: string) => {\n    e.preventDefault();\n    if (!selectedPalette || !draggedColorId || draggedColorId === targetColorId) {\n      setDraggedColorId(null);\n      setDropIndicatorIndex(null);\n      return;\n    }\n\n    // Find indices of source and target colors\n    const sourceIndex = selectedPalette.colors.findIndex(c => c.id === draggedColorId);\n    const targetIndex = selectedPalette.colors.findIndex(c => c.id === targetColorId);\n    \n    if (sourceIndex === -1 || targetIndex === -1) {\n      setDraggedColorId(null);\n      setDropIndicatorIndex(null);\n      return;\n    }\n\n    // If it's a preset palette, create a custom copy first\n    let paletteId = selectedPalette.id;\n    if (selectedPalette.isPreset) {\n      const newPaletteId = createCustomCopy(selectedPalette.id);\n      if (newPaletteId) {\n        paletteId = newPaletteId;\n        updateSettings({ textColorPaletteId: newPaletteId });\n      } else {\n        setDraggedColorId(null);\n        setDropIndicatorIndex(null);\n        return;\n      }\n    }\n\n    // Determine final position based on drop indicator\n    let finalTargetIndex = targetIndex;\n    if (dropIndicatorIndex === targetIndex + 1) {\n      finalTargetIndex = targetIndex + 1;\n    }\n\n    // Move the colors\n    let currentIndex = sourceIndex;\n    if (currentIndex < finalTargetIndex) {\n      // Moving right - use moveColorRight\n      for (let i = 0; i < finalTargetIndex - sourceIndex; i++) {\n        moveColorRight(paletteId, draggedColorId);\n      }\n    } else if (currentIndex > finalTargetIndex) {\n      // Moving left - use moveColorLeft\n      for (let i = 0; i < sourceIndex - finalTargetIndex; i++) {\n        moveColorLeft(paletteId, draggedColorId);\n      }\n    }\n\n    setDraggedColorId(null);\n    setDropIndicatorIndex(null);\n    onSettingsChange?.();\n  };\n\n  // Handle drag leave\n  const handleDragLeave = (e: React.DragEvent) => {\n    // Only clear if leaving the grid container\n    if (!e.currentTarget.contains(e.relatedTarget as Node)) {\n      setDropIndicatorIndex(null);\n    }\n  };\n\n  return (\n    <>\n      <Collapsible open={isOpen} onOpenChange={setIsOpen}>\n        <CollapsibleTrigger asChild>\n          <Button \n            variant=\"ghost\" \n            className=\"w-full h-auto text-xs justify-between py-1 px-1 my-1\"\n          >\n            <div className=\"flex items-center gap-2\">\n              <Type className=\"w-4 h-4\" />\n              <span>Text Color Mapping</span>\n              <Checkbox\n                id=\"enable-text-color-mapping\"\n                checked={enableTextColorMapping}\n                onCheckedChange={handleToggleEnabled}\n                className=\"ml-2\"\n                onClick={(e) => e.stopPropagation()}\n              />\n            </div>\n            <ChevronDown \n              className={`h-3 w-3 transition-transform duration-200 ${\n                isOpen ? 'rotate-180' : ''\n              }`}\n            />\n          </Button>\n        </CollapsibleTrigger>\n        \n        <CollapsibleContent className=\"collapsible-content space-y-3 mt-2\">\n          <div className=\"w-full\">\n            {!enableTextColorMapping && (\n              <div className=\"p-3 border border-border/50 rounded-lg bg-muted/20\">\n                <p className=\"text-xs text-muted-foreground text-center\">\n                  Text color mapping is disabled. Characters will use default foreground colors.\n                </p>\n              </div>\n            )}\n            \n            {enableTextColorMapping && (\n              <Card className=\"bg-card/30 border-border/50\">\n                <CardContent className=\"p-3 space-y-3\">\n                {/* Palette Selection */}\n                <div className=\"space-y-2\">\n                  <div className=\"flex items-center justify-between\">\n                    <Label className=\"text-xs font-medium\">Color Palette</Label>\n                    {enableTextColorMapping && (\n                      <div className=\"flex gap-1\">\n                        <TooltipProvider>\n                          <Tooltip>\n                            <TooltipTrigger asChild>\n                              <Button\n                                size=\"sm\"\n                                variant=\"outline\"\n                                className=\"h-6 w-6 p-0\"\n                                onClick={() => setIsManagePalettesOpen(true)}\n                              >\n                                <Plus className=\"h-3 w-3\" />\n                              </Button>\n                            </TooltipTrigger>\n                            <TooltipContent>\n                              <p>Add new palette</p>\n                            </TooltipContent>\n                          </Tooltip>\n                        </TooltipProvider>\n                        <TooltipProvider>\n                          <Tooltip>\n                            <TooltipTrigger asChild>\n                              <Button\n                                size=\"sm\"\n                                variant=\"outline\"\n                                className=\"h-6 w-6 p-0\"\n                                onClick={() => setIsManagePalettesOpen(true)}\n                              >\n                                <Settings className=\"h-3 w-3\" />\n                              </Button>\n                            </TooltipTrigger>\n                            <TooltipContent>\n                              <p>Manage palettes</p>\n                            </TooltipContent>\n                          </Tooltip>\n                        </TooltipProvider>\n                      </div>\n                    )}\n                  </div>\n                  \n                  <Select \n                    value={textColorPaletteId || ''} \n                    onValueChange={handlePaletteChange}\n                    disabled={!enableTextColorMapping}\n                  >\n                    <SelectTrigger className=\"text-xs h-8\">\n                      <SelectValue placeholder=\"Select palette...\" />\n                    </SelectTrigger>\n                    <SelectContent>\n                      {/* Custom Palettes */}\n                      {customPalettes.length > 0 && (\n                        <div>\n                          <div className=\"px-2 py-1.5 text-xs font-medium text-muted-foreground border-b border-border/30\">\n                            Custom\n                          </div>\n                          {customPalettes.map((palette: any) => (\n                            <SelectItem key={palette.id} value={palette.id} className=\"text-xs\">\n                              <div className=\"flex items-center gap-2 min-w-0\">\n                                <span className=\"truncate flex-1\">{palette.name}</span>\n                                <span className=\"text-muted-foreground flex-shrink-0\">({palette.colors.length} colors)</span>\n                              </div>\n                            </SelectItem>\n                          ))}\n                        </div>\n                      )}\n                          \n                      {/* Preset Palettes */}\n                      {palettes.length > 0 && (\n                        <div>\n                          <SelectSeparator />\n                          <div className=\"px-2 py-1.5 text-xs font-medium text-muted-foreground border-b border-border/30\">\n                            Presets\n                          </div>\n                          {palettes.map((palette: any) => (\n                            <SelectItem key={palette.id} value={palette.id} className=\"text-xs\">\n                              <div className=\"flex items-center gap-2 min-w-0\">\n                                <span className=\"truncate flex-1\">{palette.name}</span>\n                                <span className=\"text-muted-foreground flex-shrink-0\">({palette.colors.length} colors)</span>\n                              </div>\n                            </SelectItem>\n                          ))}\n                        </div>\n                      )}\n                    </SelectContent>\n                  </Select>\n                </div>\n\n                {/* Color Palette Editor */}\n                {selectedPalette && enableTextColorMapping && (\n                  <div className=\"space-y-2\">\n                    <div className=\"flex items-center justify-between\">\n                      <Label className=\"text-xs font-medium\">Colors</Label>\n                      <div className=\"flex gap-0.5\">\n                        <TooltipProvider>\n                          <Tooltip>\n                            <TooltipTrigger asChild>\n                              <Button\n                                size=\"sm\"\n                                variant=\"outline\"\n                                className=\"h-6 w-6 p-0\"\n                                onClick={() => setIsImportDialogOpen(true)}\n                              >\n                                <Upload className=\"h-3 w-3\" />\n                              </Button>\n                            </TooltipTrigger>\n                            <TooltipContent>\n                              <p>Import palette</p>\n                            </TooltipContent>\n                          </Tooltip>\n                        </TooltipProvider>\n\n                        <TooltipProvider>\n                          <Tooltip>\n                            <TooltipTrigger asChild>\n                              <Button\n                                size=\"sm\"\n                                variant=\"outline\"\n                                className=\"h-6 w-6 p-0\"\n                                onClick={() => setIsExportDialogOpen(true)}\n                              >\n                                <Download className=\"h-3 w-3\" />\n                              </Button>\n                            </TooltipTrigger>\n                            <TooltipContent>\n                              <p>Export palette</p>\n                            </TooltipContent>\n                          </Tooltip>\n                        </TooltipProvider>\n                      </div>\n                    </div>\n                    \n                    {/* Color swatches grid */}\n                    <Card className=\"bg-card/50 border-border/50\">\n                      <CardContent className=\"p-2\">\n                        <TooltipProvider>\n                          <div className=\"grid grid-cols-8 gap-0.5 mb-2\" onDragLeave={handleDragLeave}>\n                            {selectedPalette.colors.map((color, index) => (\n                            <div key={color.id} className=\"relative flex items-center justify-center\">\n                              {/* Drop indicator line */}\n                              {dropIndicatorIndex === index && (\n                                <div className=\"absolute -left-0.5 top-0 bottom-0 w-0.5 bg-primary z-10 rounded-full\"></div>\n                              )}\n                              \n                              <Tooltip>\n                                <TooltipTrigger asChild>\n                                  <div\n                                    className={`w-6 h-6 rounded border-2 transition-all hover:scale-105 cursor-pointer ${\n                                      draggedColorId === color.id ? 'opacity-50 scale-95' : ''\n                                    } ${\n                                      selectedColorId === color.id\n                                        ? 'border-primary ring-2 ring-primary/20 shadow-lg'\n                                        : 'border-border hover:border-border/80'\n                                    } cursor-move`}\n                                    style={{ backgroundColor: color.value }}\n                                    draggable={!selectedPalette.isPreset}\n                                    onClick={() => setSelectedColor(color.id)}\n                                    onDoubleClick={() => handleColorDoubleClick(color.value)}\n                                    onDragStart={(e) => handleDragStart(e, color.id)}\n                                    onDragOver={(e) => handleDragOver(e, color.id)}\n                                    onDrop={(e) => handleDrop(e, color.id)}\n                                  />\n                                </TooltipTrigger>\n                                <TooltipContent>\n                                  <p>\n                                    {color.name || 'Unnamed'}: {color.value}\n                                    {selectedPalette.isPreset \n                                      ? ' (double-click to edit)' \n                                      : ' (drag to reorder, double-click to edit)'}\n                                  </p>\n                                </TooltipContent>\n                              </Tooltip>\n                              \n                              {/* Drop indicator line after last item */}\n                              {dropIndicatorIndex === index + 1 && (\n                                <div className=\"absolute -right-0.5 top-0 bottom-0 w-0.5 bg-primary z-10 rounded-full\"></div>\n                              )}\n                            </div>\n                            ))}\n                          </div>\n                        </TooltipProvider>\n                        \n                        {/* Palette controls */}\n                        <div className=\"flex items-center justify-between\">\n                          {/* Editing controls */}\n                          <div className=\"flex gap-0.5\">\n                            <TooltipProvider>\n                              <Tooltip>\n                                <TooltipTrigger asChild>\n                                  <Button\n                                    size=\"sm\"\n                                    variant=\"outline\"\n                                    className=\"h-6 w-6 p-0\"\n                                    onClick={() => selectedColorId && handleMoveColorLeft(selectedColorId)}\n                                    disabled={!selectedColorId}\n                                  >\n                                    <ChevronLeft className=\"h-3 w-3\" />\n                                  </Button>\n                                </TooltipTrigger>\n                                <TooltipContent>\n                                  <p>Move color left</p>\n                                </TooltipContent>\n                              </Tooltip>\n                            </TooltipProvider>\n\n                            <TooltipProvider>\n                              <Tooltip>\n                                <TooltipTrigger asChild>\n                                  <Button\n                                    size=\"sm\"\n                                    variant=\"outline\"\n                                    className=\"h-6 w-6 p-0\"\n                                    onClick={() => selectedColorId && handleMoveColorRight(selectedColorId)}\n                                    disabled={!selectedColorId}\n                                  >\n                                    <ChevronRight className=\"h-3 w-3\" />\n                                  </Button>\n                                </TooltipTrigger>\n                                <TooltipContent>\n                                  <p>Move color right</p>\n                                </TooltipContent>\n                              </Tooltip>\n                            </TooltipProvider>\n\n                            <TooltipProvider>\n                              <Tooltip>\n                                <TooltipTrigger asChild>\n                                  <Button\n                                    size=\"sm\"\n                                    variant=\"outline\"\n                                    className=\"h-6 w-6 p-0\"\n                                    onClick={handleAddColor}\n                                  >\n                                    <Plus className=\"h-3 w-3\" />\n                                  </Button>\n                                </TooltipTrigger>\n                                <TooltipContent>\n                                  <p>Add color</p>\n                                </TooltipContent>\n                              </Tooltip>\n                            </TooltipProvider>\n\n                            <TooltipProvider>\n                              <Tooltip>\n                                <TooltipTrigger asChild>\n                                  <Button\n                                    size=\"sm\"\n                                    variant=\"outline\"\n                                    className=\"h-6 w-6 p-0\"\n                                    onClick={handleEditColor}\n                                    disabled={!selectedColorId}\n                                  >\n                                    <Edit className=\"h-3 w-3\" />\n                                  </Button>\n                                </TooltipTrigger>\n                                <TooltipContent>\n                                  <p>Edit color</p>\n                                </TooltipContent>\n                              </Tooltip>\n                            </TooltipProvider>\n\n                            <TooltipProvider>\n                              <Tooltip>\n                                <TooltipTrigger asChild>\n                                  <Button\n                                    size=\"sm\"\n                                    variant=\"outline\"\n                                    className=\"h-6 w-6 p-0\"\n                                    onClick={() => selectedColorId && handleRemoveColor(selectedColorId)}\n                                    disabled={!selectedColorId || selectedPalette.colors.length <= 1}\n                                  >\n                                    <Trash2 className=\"h-3 w-3\" />\n                                  </Button>\n                                </TooltipTrigger>\n                                <TooltipContent>\n                                  <p>Remove color</p>\n                                </TooltipContent>\n                              </Tooltip>\n                            </TooltipProvider>\n\n                          </div>\n                          \n                          {/* Reverse button (right-aligned) */}\n                          <div>\n                            <TooltipProvider>\n                              <Tooltip>\n                                <TooltipTrigger asChild>\n                                  <Button\n                                    size=\"sm\"\n                                    variant=\"outline\"\n                                    className=\"h-6 w-6 p-0\"\n                                    onClick={handleReversePalette}\n                                  >\n                                    <ArrowUpDown className=\"h-3 w-3\" />\n                                  </Button>\n                                </TooltipTrigger>\n                                <TooltipContent>\n                                  <p>Reverse palette order</p>\n                                </TooltipContent>\n                              </Tooltip>\n                            </TooltipProvider>\n                          </div>\n                        </div>\n                      </CardContent>\n                    </Card>\n                  </div>\n                )}\n\n                {/* Mapping Mode */}\n                <div className=\"space-y-2\">\n                  <Label className=\"text-xs font-medium\">Mapping Mode</Label>\n                  <Select \n                    value={textColorMappingMode}\n                    onValueChange={handleMappingModeChange}\n                    disabled={!enableTextColorMapping}\n                  >\n                    <SelectTrigger className=\"text-xs h-8\">\n                      <SelectValue />\n                    </SelectTrigger>\n                    <SelectContent>\n                      <SelectItem value=\"closest\" className=\"text-xs\">\n                        Closest Match\n                      </SelectItem>\n                      <SelectItem value=\"dithering\" className=\"text-xs\">\n                        Dithering\n                      </SelectItem>\n                      <SelectItem value=\"by-index\" className=\"text-xs\">\n                        By Index\n                      </SelectItem>\n                    </SelectContent>\n                  </Select>\n                </div>\n\n                </CardContent>\n              </Card>\n            )}\n          </div>\n        </CollapsibleContent>\n      </Collapsible>\n\n      {/* Color Picker Overlay */}\n      <ColorPickerOverlay\n        isOpen={isColorPickerOpen}\n        onOpenChange={setIsColorPickerOpen}\n        initialColor={colorPickerInitialColor}\n        onColorSelect={handleColorPickerSelect}\n        title=\"Edit Color\"\n        anchorPosition=\"import-media-panel\"\n      />\n\n      {/* Palette Management Dialog */}\n      <ManagePalettesDialog\n        isOpen={isManagePalettesOpen}\n        onOpenChange={setIsManagePalettesOpen}\n      />\n\n      {/* Import/Export Dialogs */}\n      <ImportPaletteDialog\n        isOpen={isImportDialogOpen}\n        onOpenChange={setIsImportDialogOpen}\n      />\n\n      <ExportPaletteDialog\n        isOpen={isExportDialogOpen}\n        onOpenChange={setIsExportDialogOpen}\n      />\n    </>\n  );\n}","usedDeprecatedRules":[]},{"filePath":"/Users/cameronfoxly/GitHubRepos/Ascii-Motion/src/components/features/TextExportDialog.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/cameronfoxly/GitHubRepos/Ascii-Motion/src/components/features/TimelineZoomControl.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/cameronfoxly/GitHubRepos/Ascii-Motion/src/components/features/ToolBehaviorSettings.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/cameronfoxly/GitHubRepos/Ascii-Motion/src/components/features/ToolManager.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/cameronfoxly/GitHubRepos/Ascii-Motion/src/components/features/ToolPalette.tsx","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":93,"column":77,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":93,"endColumn":80,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5001,5004],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5001,5004],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React from 'react';\nimport { useToolStore } from '../../stores/toolStore';\nimport { useGradientStore } from '../../stores/gradientStore';\nimport { useCanvasContext } from '../../contexts/CanvasContext';\nimport { useFlipUtilities } from '../../hooks/useFlipUtilities';\nimport { Button } from '@/components/ui/button';\nimport { Card, CardContent } from '@/components/ui/card';\nimport { Tooltip, TooltipContent, TooltipProvider, TooltipTrigger } from '@/components/ui/tooltip';\nimport { Collapsible, CollapsibleContent } from '@/components/ui/collapsible';\nimport { CollapsibleHeader } from '../common/CollapsibleHeader';\nimport { PanelSeparator } from '../common/PanelSeparator';\nimport { GradientIcon } from '../icons';\nimport { BrushControls } from './BrushControls';\nimport { \n  PenTool, \n  Eraser, \n  PaintBucket, \n  Pipette, \n  Square,\n  Circle,\n  Lasso,\n  Type,\n  Wand2,\n  Palette,\n  Wrench,\n  MoveHorizontal,\n  MoveVertical,\n  TypeOutline,\n} from 'lucide-react';\nimport { Switch } from '@/components/ui/switch';\nimport { Label } from '@/components/ui/label';\nimport type { Tool } from '../../types';\nimport { getToolTooltipText } from '../../constants/hotkeys';\n\ninterface ToolPaletteProps {\n  className?: string;\n}\n\n// Custom dashed rectangle icon for selection tool\nconst DashedRectangleIcon: React.FC<{ className?: string }> = ({ className }) => (\n  <svg \n    className={className}\n    viewBox=\"0 0 24 24\" \n    fill=\"none\" \n    stroke=\"currentColor\" \n    strokeWidth=\"2\"\n  >\n    <rect \n      x=\"3\" \n      y=\"3\" \n      width=\"18\" \n      height=\"18\" \n      strokeDasharray=\"3 3\"\n      fill=\"none\"\n    />\n  </svg>\n);\n\n// Organized tools by category\nconst DRAWING_TOOLS: Array<{ id: Tool; name: string; icon: React.ReactNode; description: string }> = [\n  { id: 'pencil', name: 'Pencil', icon: <PenTool className=\"w-3 h-3\" />, description: 'Draw characters' },\n  { id: 'eraser', name: 'Eraser', icon: <Eraser className=\"w-3 h-3\" />, description: 'Remove characters' },\n  { id: 'paintbucket', name: 'Fill', icon: <PaintBucket className=\"w-3 h-3\" />, description: 'Fill connected areas' },\n  { id: 'gradientfill', name: 'Gradient', icon: <GradientIcon className=\"w-3 h-3\" />, description: 'Apply gradient fills' },\n  { id: 'rectangle', name: 'Rectangle', icon: <Square className=\"w-3 h-3\" />, description: 'Draw rectangles' },\n  { id: 'ellipse', name: 'Ellipse', icon: <Circle className=\"w-3 h-3\" />, description: 'Draw ellipses/circles' },\n  { id: 'text', name: 'Text', icon: <Type className=\"w-3 h-3\" />, description: 'Type text directly' },\n  { id: 'asciitype', name: 'ASCII Type', icon: <TypeOutline className=\"w-3 h-3\" />, description: 'Create Figlet ASCII text' },\n];\n\nconst SELECTION_TOOLS: Array<{ id: Tool; name: string; icon: React.ReactNode; description: string }> = [\n  { id: 'select', name: 'Select', icon: <DashedRectangleIcon className=\"w-3 h-3\" />, description: 'Select rectangular areas' },\n  { id: 'lasso', name: 'Lasso', icon: <Lasso className=\"w-3 h-3\" />, description: 'Freeform selection tool' },\n  { id: 'magicwand', name: 'Magic Wand', icon: <Wand2 className=\"w-3 h-3\" />, description: 'Select matching cells' },\n];\n\nconst UTILITY_TOOLS: Array<{ id: Tool; name: string; icon: React.ReactNode; description: string }> = [\n  { id: 'eyedropper', name: 'Eyedropper', icon: <Pipette className=\"w-3 h-3\" />, description: 'Pick character/color' },\n  { id: 'fliphorizontal', name: 'Flip H', icon: <MoveHorizontal className=\"w-3 h-3\" />, description: 'Flip horizontally (Shift+H)' },\n  { id: 'flipvertical', name: 'Flip V', icon: <MoveVertical className=\"w-3 h-3\" />, description: 'Flip vertically (Shift+V)' },\n];\n\nexport const ToolPalette: React.FC<ToolPaletteProps> = ({ className = '' }) => {\n  const { activeTool, setActiveTool, rectangleFilled, setRectangleFilled, paintBucketContiguous, setPaintBucketContiguous, magicWandContiguous, setMagicWandContiguous, toolAffectsChar, toolAffectsColor, toolAffectsBgColor, eyedropperPicksChar, eyedropperPicksColor, eyedropperPicksBgColor, setToolAffectsChar, setToolAffectsColor, setToolAffectsBgColor, setEyedropperPicksChar, setEyedropperPicksColor, setEyedropperPicksBgColor, fillMatchChar, fillMatchColor, fillMatchBgColor, setFillMatchChar, setFillMatchColor, setFillMatchBgColor, magicMatchChar, magicMatchColor, magicMatchBgColor, setMagicMatchChar, setMagicMatchColor, setMagicMatchBgColor } = useToolStore();\n  const { contiguous, matchChar, matchColor, matchBgColor, setContiguous, setMatchCriteria } = useGradientStore();\n  const { altKeyDown } = useCanvasContext();\n  const { flipHorizontal, flipVertical } = useFlipUtilities();\n  const [showOptions, setShowOptions] = React.useState(true);\n  const [showTools, setShowTools] = React.useState(true);\n\n  // Calculate effective tool (Alt key overrides with eyedropper for drawing tools)\n  const drawingTools = ['pencil', 'eraser', 'paintbucket', 'gradientfill', 'rectangle', 'ellipse'] as const;\n  const shouldAllowEyedropperOverride = drawingTools.includes(activeTool as any);\n  const effectiveTool = (altKeyDown && shouldAllowEyedropperOverride) ? 'eyedropper' : activeTool;\n\n  // Tools that actually have configurable options. (Removed 'eraser' and 'text' per layout bug fix.)\n  const hasOptions = ['rectangle', 'ellipse', 'paintbucket', 'gradientfill', 'magicwand', 'pencil', 'eraser', 'eyedropper'].includes(effectiveTool);\n\n  // Get the current tool's icon\n  const getCurrentToolIcon = () => {\n    const allTools = [...DRAWING_TOOLS, ...SELECTION_TOOLS, ...UTILITY_TOOLS];\n    const currentTool = allTools.find(tool => tool.id === effectiveTool);\n    return currentTool?.icon || null;\n  };\n\n  const handleToolClick = (tool: { id: Tool; name: string; icon: React.ReactNode; description: string }) => {\n    // Handle flip utilities as immediate actions\n    if (tool.id === 'fliphorizontal') {\n      flipHorizontal();\n      return;\n    }\n    if (tool.id === 'flipvertical') {\n      flipVertical();\n      return;\n    }\n    \n    // Default tool switching behavior\n    setActiveTool(tool.id);\n  };\n\n  const ToolButton: React.FC<{ tool: { id: Tool; name: string; icon: React.ReactNode; description: string } }> = ({ tool }) => (\n    <Tooltip key={tool.id}>\n      <TooltipTrigger asChild>\n        <Button\n          variant={effectiveTool === tool.id ? 'default' : 'outline'}\n          size=\"sm\"\n          className=\"h-8 w-8 p-0 touch-manipulation\"\n          onClick={() => handleToolClick(tool)}\n          aria-label={`${tool.name} tool - ${tool.description}`}\n          aria-pressed={effectiveTool === tool.id}\n        >\n          {tool.icon}\n        </Button>\n      </TooltipTrigger>\n      <TooltipContent side=\"right\">\n        <p className=\"text-xs\">{getToolTooltipText(tool.id, tool.description)}</p>\n      </TooltipContent>\n    </Tooltip>\n  );\n\n  return (\n    <TooltipProvider>\n      <div className={`space-y-3 ${className}`}>\n        <Collapsible open={showTools} onOpenChange={setShowTools}>\n          <CollapsibleHeader isOpen={showTools}>\n            <div className=\"flex items-center gap-2\">\n              <Wrench className=\"w-4 h-4\" />\n              Tools\n            </div>\n          </CollapsibleHeader>\n          <CollapsibleContent className=\"collapsible-content\">\n            <Card className=\"border-border/50 mt-2\">\n              <CardContent className=\"p-3\">\n                {/* Drawing Tools Section */}\n                <div className=\"space-y-2\">\n                  <h4 className=\"text-xs font-medium text-muted-foreground\">Drawing</h4>\n                  <div className=\"grid grid-cols-3 gap-1\" role=\"toolbar\" aria-label=\"Drawing tools\">\n                    {DRAWING_TOOLS.map((tool) => (\n                      <ToolButton key={tool.id} tool={tool} />\n                    ))}\n                  </div>\n                </div>\n\n                {/* Selection Tools Section */}\n                <div className=\"space-y-2 mt-3\">\n                  <h4 className=\"text-xs font-medium text-muted-foreground\">Selection</h4>\n                  <div className=\"grid grid-cols-3 gap-1\" role=\"toolbar\" aria-label=\"Selection tools\">\n                    {SELECTION_TOOLS.map((tool) => (\n                      <ToolButton key={tool.id} tool={tool} />\n                    ))}\n                  </div>\n                </div>\n\n                {/* Utility Tools Section */}\n                <div className=\"space-y-2 mt-3\">\n                  <h4 className=\"text-xs font-medium text-muted-foreground\">Utility</h4>\n                  <div className=\"grid grid-cols-3 gap-1\" role=\"toolbar\" aria-label=\"Utility tools\">\n                    {UTILITY_TOOLS.map((tool) => (\n                      <ToolButton key={tool.id} tool={tool} />\n                    ))}\n                  </div>\n                </div>\n              </CardContent>\n            </Card>\n          </CollapsibleContent>\n        </Collapsible>\n\n        {/* Separator between Tools and Tool Options */}\n        {hasOptions && <PanelSeparator />}\n\n        {/* Tool Options */}\n        {hasOptions && (\n          <div>\n            <Collapsible open={showOptions} onOpenChange={setShowOptions}>\n            <CollapsibleHeader isOpen={showOptions}>\n              <div className=\"flex items-center gap-2\">\n                {getCurrentToolIcon()}\n                <span>Tool Options</span>\n              </div>\n            </CollapsibleHeader>\n            <CollapsibleContent className=\"collapsible-content\">\n              <Card className=\"bg-card/50 border-border/50 mt-2\">\n                <CardContent className=\"p-2 space-y-2\">\n                  {effectiveTool === 'rectangle' && (\n                    <div className=\"flex items-center justify-between\">\n                      <Label htmlFor=\"filled-rectangle\" className=\"text-xs cursor-pointer\">\n                        Filled\n                      </Label>\n                      <Switch\n                        id=\"filled-rectangle\"\n                        checked={rectangleFilled}\n                        onCheckedChange={setRectangleFilled}\n                      />\n                    </div>\n                  )}\n                  \n                  {effectiveTool === 'ellipse' && (\n                    <div className=\"flex items-center justify-between\">\n                      <Label htmlFor=\"filled-ellipse\" className=\"text-xs cursor-pointer\">\n                        Filled\n                      </Label>\n                      <Switch\n                        id=\"filled-ellipse\"\n                        checked={rectangleFilled}\n                        onCheckedChange={setRectangleFilled}\n                      />\n                    </div>\n                  )}\n                  \n                  {effectiveTool === 'paintbucket' && (\n                    <div className=\"flex items-center justify-between\">\n                      <Label htmlFor=\"contiguous-fill\" className=\"text-xs cursor-pointer\">\n                        Contiguous\n                      </Label>\n                      <Switch\n                        id=\"contiguous-fill\"\n                        checked={paintBucketContiguous}\n                        onCheckedChange={setPaintBucketContiguous}\n                      />\n                    </div>\n                  )}\n                  \n                  {effectiveTool === 'gradientfill' && (\n                    <>\n                      <div className=\"flex items-center justify-between\">\n                        <Label htmlFor=\"gradient-contiguous\" className=\"text-xs cursor-pointer\">\n                          Contiguous\n                        </Label>\n                        <Switch\n                          id=\"gradient-contiguous\"\n                          checked={contiguous}\n                          onCheckedChange={setContiguous}\n                        />\n                      </div>\n                      <div className=\"space-y-2 mt-2\">\n                        <div className=\"text-xs text-muted-foreground\">Selects same:</div>\n                        <div className=\"flex gap-1\">\n                          <Tooltip>\n                            <TooltipTrigger asChild>\n                              <Button\n                                variant={matchChar ? \"default\" : \"outline\"}\n                                size=\"sm\"\n                                className=\"h-6 w-6 p-0\"\n                                onClick={() => setMatchCriteria({ char: !matchChar, color: matchColor, bgColor: matchBgColor })}\n                              >\n                                <Type className=\"h-3 w-3\" />\n                              </Button>\n                            </TooltipTrigger>\n                            <TooltipContent>\n                              <p>Match character</p>\n                            </TooltipContent>\n                          </Tooltip>\n                          <Tooltip>\n                            <TooltipTrigger asChild>\n                              <Button\n                                variant={matchColor ? \"default\" : \"outline\"}\n                                size=\"sm\"\n                                className=\"h-6 w-6 p-0\"\n                                onClick={() => setMatchCriteria({ char: matchChar, color: !matchColor, bgColor: matchBgColor })}\n                              >\n                                <Palette className=\"h-3 w-3\" />\n                              </Button>\n                            </TooltipTrigger>\n                            <TooltipContent>\n                              <p>Match text color</p>\n                            </TooltipContent>\n                          </Tooltip>\n                          <Tooltip>\n                            <TooltipTrigger asChild>\n                              <Button\n                                variant={matchBgColor ? \"default\" : \"outline\"}\n                                size=\"sm\"\n                                className=\"h-6 w-6 p-0\"\n                                onClick={() => setMatchCriteria({ char: matchChar, color: matchColor, bgColor: !matchBgColor })}\n                              >\n                                <Square className=\"h-3 w-3 fill-current\" />\n                              </Button>\n                            </TooltipTrigger>\n                            <TooltipContent>\n                              <p>Match background color</p>\n                            </TooltipContent>\n                          </Tooltip>\n                        </div>\n                      </div>\n                    </>\n                  )}\n                  \n                  {effectiveTool === 'magicwand' && (\n                    <div className=\"flex items-center justify-between\">\n                      <Label htmlFor=\"contiguous-selection\" className=\"text-xs cursor-pointer\">\n                        Contiguous\n                      </Label>\n                      <Switch\n                        id=\"contiguous-selection\"\n                        checked={magicWandContiguous}\n                        onCheckedChange={setMagicWandContiguous}\n                      />\n                    </div>\n                  )}\n                  {effectiveTool === 'magicwand' && (\n                    <div className=\"space-y-2 mt-2\">\n                      <div className=\"text-xs text-muted-foreground\">Selects same:</div>\n                      <div className=\"flex gap-1\">\n                        <Tooltip>\n                          <TooltipTrigger asChild>\n                            <Button\n                              variant={magicMatchChar ? \"default\" : \"outline\"}\n                              size=\"sm\"\n                              className=\"h-6 w-6 p-0\"\n                              onClick={() => setMagicMatchChar(!magicMatchChar)}\n                            >\n                              <Type className=\"h-3 w-3\" />\n                            </Button>\n                          </TooltipTrigger>\n                          <TooltipContent>\n                            <p>Match character</p>\n                          </TooltipContent>\n                        </Tooltip>\n                        <Tooltip>\n                          <TooltipTrigger asChild>\n                            <Button\n                              variant={magicMatchColor ? \"default\" : \"outline\"}\n                              size=\"sm\"\n                              className=\"h-6 w-6 p-0\"\n                              onClick={() => setMagicMatchColor(!magicMatchColor)}\n                            >\n                              <Palette className=\"h-3 w-3\" />\n                            </Button>\n                          </TooltipTrigger>\n                          <TooltipContent>\n                            <p>Match text color</p>\n                          </TooltipContent>\n                        </Tooltip>\n                        <Tooltip>\n                          <TooltipTrigger asChild>\n                            <Button\n                              variant={magicMatchBgColor ? \"default\" : \"outline\"}\n                              size=\"sm\"\n                              className=\"h-6 w-6 p-0\"\n                              onClick={() => setMagicMatchBgColor(!magicMatchBgColor)}\n                            >\n                              <Square className=\"h-3 w-3 fill-current\" />\n                            </Button>\n                          </TooltipTrigger>\n                          <TooltipContent>\n                            <p>Match background color</p>\n                          </TooltipContent>\n                        </Tooltip>\n                      </div>\n                    </div>\n                  )}\n                  \n                  {/* Tool behavior toggles for drawing tools */}\n                  {(['pencil', 'paintbucket'] as Tool[]).includes(effectiveTool) && (\n                    <>\n                      {/* Paint bucket specific: Selects same criteria */}\n                      {effectiveTool === 'paintbucket' && (\n                        <div className=\"space-y-2 mt-2\">\n                          <div className=\"text-xs text-muted-foreground\">Selects same:</div>\n                          <div className=\"flex gap-1\">\n                            <Tooltip>\n                              <TooltipTrigger asChild>\n                                <Button\n                                  variant={fillMatchChar ? \"default\" : \"outline\"}\n                                  size=\"sm\"\n                                  className=\"h-6 w-6 p-0\"\n                                  onClick={() => setFillMatchChar(!fillMatchChar)}\n                                >\n                                  <Type className=\"h-3 w-3\" />\n                                </Button>\n                              </TooltipTrigger>\n                              <TooltipContent>\n                                <p>Match character</p>\n                              </TooltipContent>\n                            </Tooltip>\n                            <Tooltip>\n                              <TooltipTrigger asChild>\n                                <Button\n                                  variant={fillMatchColor ? \"default\" : \"outline\"}\n                                  size=\"sm\"\n                                  className=\"h-6 w-6 p-0\"\n                                  onClick={() => setFillMatchColor(!fillMatchColor)}\n                                >\n                                  <Palette className=\"h-3 w-3\" />\n                                </Button>\n                              </TooltipTrigger>\n                              <TooltipContent>\n                                <p>Match text color</p>\n                              </TooltipContent>\n                            </Tooltip>\n                            <Tooltip>\n                              <TooltipTrigger asChild>\n                                <Button\n                                  variant={fillMatchBgColor ? \"default\" : \"outline\"}\n                                  size=\"sm\"\n                                  className=\"h-6 w-6 p-0\"\n                                  onClick={() => setFillMatchBgColor(!fillMatchBgColor)}\n                                >\n                                  <Square className=\"h-3 w-3 fill-current\" />\n                                </Button>\n                              </TooltipTrigger>\n                              <TooltipContent>\n                                <p>Match background color</p>\n                              </TooltipContent>\n                            </Tooltip>\n                          </div>\n                        </div>\n                      )}\n                    </>\n                  )}\n\n                  {/* Tool Affects Section - Separate inset container */}\n                  {(effectiveTool === 'pencil' || effectiveTool === 'eraser' || effectiveTool === 'paintbucket') && (\n                    <Card className=\"bg-card/50 border-border/50 mt-2\">\n                      <CardContent className=\"p-3\">\n                        <div className=\"space-y-2\">\n                          <div className=\"text-xs text-muted-foreground\">Affects:</div>\n                          <div className=\"flex gap-1\">\n                            <Tooltip>\n                              <TooltipTrigger asChild>\n                                <Button\n                                  variant={toolAffectsChar ? \"default\" : \"outline\"}\n                                  size=\"sm\"\n                                  className=\"h-6 w-6 p-0\"\n                                  onClick={() => setToolAffectsChar(!toolAffectsChar)}\n                                >\n                                  <Type className=\"h-3 w-3\" />\n                                </Button>\n                              </TooltipTrigger>\n                              <TooltipContent>\n                                <p>Affect character</p>\n                              </TooltipContent>\n                            </Tooltip>\n                            <Tooltip>\n                              <TooltipTrigger asChild>\n                                <Button\n                                  variant={toolAffectsColor ? \"default\" : \"outline\"}\n                                  size=\"sm\"\n                                  className=\"h-6 w-6 p-0\"\n                                  onClick={() => setToolAffectsColor(!toolAffectsColor)}\n                                >\n                                  <Palette className=\"h-3 w-3\" />\n                                </Button>\n                              </TooltipTrigger>\n                              <TooltipContent>\n                                <p>Affect text color</p>\n                              </TooltipContent>\n                            </Tooltip>\n                            <Tooltip>\n                              <TooltipTrigger asChild>\n                                <Button\n                                  variant={toolAffectsBgColor ? \"default\" : \"outline\"}\n                                  size=\"sm\"\n                                  className=\"h-6 w-6 p-0\"\n                                  onClick={() => setToolAffectsBgColor(!toolAffectsBgColor)}\n                                >\n                                  <Square className=\"h-3 w-3 fill-current\" />\n                                </Button>\n                              </TooltipTrigger>\n                              <TooltipContent>\n                                <p>Affect background color</p>\n                              </TooltipContent>\n                            </Tooltip>\n                          </div>\n                        </div>\n                      </CardContent>\n                    </Card>\n                  )}\n                  \n                  {/* Brush controls - Separate container */}\n                  {(effectiveTool === 'pencil' || effectiveTool === 'eraser') && (\n                    <div className=\"mt-2\">\n                      <BrushControls tool={effectiveTool === 'eraser' ? 'eraser' : 'pencil'} />\n                    </div>\n                  )}\n                  \n                  {/* Eyedropper behavior toggles */}\n                  {effectiveTool === 'eyedropper' && (\n                    <>\n                      <div className=\"space-y-2\">\n                        <div className=\"text-xs text-muted-foreground\">Picks:</div>\n                        <div className=\"flex gap-1\">\n                          <Tooltip>\n                            <TooltipTrigger asChild>\n                              <Button\n                                variant={eyedropperPicksChar ? \"default\" : \"outline\"}\n                                size=\"sm\"\n                                className=\"h-6 w-6 p-0\"\n                                onClick={() => setEyedropperPicksChar(!eyedropperPicksChar)}\n                              >\n                                <Type className=\"h-3 w-3\" />\n                              </Button>\n                            </TooltipTrigger>\n                            <TooltipContent>\n                              <p>Pick character</p>\n                            </TooltipContent>\n                          </Tooltip>\n                          <Tooltip>\n                            <TooltipTrigger asChild>\n                              <Button\n                                variant={eyedropperPicksColor ? \"default\" : \"outline\"}\n                                size=\"sm\"\n                                className=\"h-6 w-6 p-0\"\n                                onClick={() => setEyedropperPicksColor(!eyedropperPicksColor)}\n                              >\n                                <Palette className=\"h-3 w-3\" />\n                              </Button>\n                            </TooltipTrigger>\n                            <TooltipContent>\n                              <p>Pick text color</p>\n                            </TooltipContent>\n                          </Tooltip>\n                          <Tooltip>\n                            <TooltipTrigger asChild>\n                              <Button\n                                variant={eyedropperPicksBgColor ? \"default\" : \"outline\"}\n                                size=\"sm\"\n                                className=\"h-6 w-6 p-0\"\n                                onClick={() => setEyedropperPicksBgColor(!eyedropperPicksBgColor)}\n                              >\n                                <Square className=\"h-3 w-3 fill-current\" />\n                              </Button>\n                            </TooltipTrigger>\n                            <TooltipContent>\n                              <p>Pick background color</p>\n                            </TooltipContent>\n                          </Tooltip>\n                        </div>\n                      </div>\n                    </>\n                  )}\n                </CardContent>\n              </Card>\n            </CollapsibleContent>\n          </Collapsible>\n          </div>\n        )}\n\n        {/* Separator after Tool Options */}\n        {hasOptions && <PanelSeparator />}\n      </div>\n    </TooltipProvider>\n  );\n};\n","usedDeprecatedRules":[]},{"filePath":"/Users/cameronfoxly/GitHubRepos/Ascii-Motion/src/components/features/ToolPalette_backup.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/cameronfoxly/GitHubRepos/Ascii-Motion/src/components/features/ToolPalette_new.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/cameronfoxly/GitHubRepos/Ascii-Motion/src/components/features/ToolStatusManager.tsx","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":30,"column":77,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":30,"endColumn":80,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[998,1001],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[998,1001],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React from 'react';\nimport { useToolStore } from '../../stores/toolStore';\nimport { useCanvasContext } from '../../contexts/CanvasContext';\nimport {\n  SelectionToolStatus,\n  LassoToolStatus,\n  MagicWandToolStatus,\n  DrawingToolStatus,\n  PaintBucketToolStatus,\n  RectangleToolStatus,\n  EllipseToolStatus,\n  EyedropperToolStatus,\n  TextToolStatus,\n  GradientFillToolStatus,\n  FlipHorizontalToolStatus,\n  FlipVerticalToolStatus,\n  AsciiTypeToolStatus,\n} from '../tools';\n\n/**\n * Tool Status Manager Component\n * Renders the appropriate tool status component based on the active tool\n */\nexport const ToolStatusManager: React.FC = () => {\n  const { activeTool } = useToolStore();\n  const { altKeyDown } = useCanvasContext();\n\n  // Calculate effective tool (Alt key overrides with eyedropper for drawing tools)\n  const drawingTools = ['pencil', 'eraser', 'paintbucket', 'gradientfill', 'rectangle', 'ellipse'] as const;\n  const shouldAllowEyedropperOverride = drawingTools.includes(activeTool as any);\n  const effectiveTool = (altKeyDown && shouldAllowEyedropperOverride) ? 'eyedropper' : activeTool;\n\n  // Render the appropriate tool status component with smaller text\n  const statusContent = (() => {\n    switch (effectiveTool) {\n      case 'select':\n        return <SelectionToolStatus />;\n      case 'lasso':\n        return <LassoToolStatus />;\n      case 'magicwand':\n        return <MagicWandToolStatus />;\n      case 'pencil':\n      case 'eraser':\n        return <DrawingToolStatus />;\n      case 'paintbucket':\n        return <PaintBucketToolStatus />;\n      case 'rectangle':\n        return <RectangleToolStatus />;\n      case 'ellipse':\n        return <EllipseToolStatus />;\n      case 'eyedropper':\n        return <EyedropperToolStatus />;\n      case 'text':\n        return <TextToolStatus />;\n      case 'gradientfill':\n        return <GradientFillToolStatus />;\n      case 'asciitype':\n        return <AsciiTypeToolStatus />;\n      case 'fliphorizontal':\n        return <FlipHorizontalToolStatus />;\n      case 'flipvertical':\n        return <FlipVerticalToolStatus />;\n      default:\n        return <span className=\"text-muted-foreground\">No tool selected</span>;\n    }\n  })();\n\n  return (\n    <div className=\"text-xs\">\n      {statusContent}\n    </div>\n  );\n};\n","usedDeprecatedRules":[]},{"filePath":"/Users/cameronfoxly/GitHubRepos/Ascii-Motion/src/components/features/VideoExportDialog.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/cameronfoxly/GitHubRepos/Ascii-Motion/src/components/features/ZoomControls.tsx","messages":[{"ruleId":"react-refresh/only-export-components","severity":2,"message":"Fast refresh only works when a file only exports components. Use a new file to share constants or functions between components.","line":10,"column":14,"nodeType":"Identifier","messageId":"namedExport","endLine":10,"endColumn":29}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React from 'react';\nimport { Button } from '@/components/ui/button';\nimport { Tooltip, TooltipContent, TooltipProvider, TooltipTrigger } from '@/components/ui/tooltip';\nimport { Minus, Plus, RotateCcw } from 'lucide-react';\nimport { useCanvasContext } from '../../contexts/CanvasContext';\n\n/**\n * Custom hook for zoom functionality that can be shared between UI and keyboard shortcuts\n */\nexport const useZoomControls = () => {\n  const { zoom, setZoom, panOffset, setPanOffset } = useCanvasContext();\n  \n  const zoomIn = () => {\n    const newZoom = Math.min(4.0, zoom + 0.2); // 20% increments (max 400%)\n    setZoom(Math.round(newZoom * 100) / 100); // Round to 2 decimal places\n  };\n  \n  const zoomOut = () => {\n    const newZoom = Math.max(0.2, zoom - 0.2); // 20% increments (min 20%)\n    setZoom(Math.round(newZoom * 100) / 100); // Round to 2 decimal places\n  };\n  \n  const resetZoom = () => {\n    setZoom(1.0);\n  };\n  \n  const resetView = () => {\n    setZoom(1.0);\n    setPanOffset({ x: 0, y: 0 });\n  };\n  \n  return { zoom, zoomIn, zoomOut, resetZoom, resetView, panOffset };\n};\n\nexport const ZoomControls: React.FC = () => {\n  const { zoom, zoomIn, zoomOut, resetZoom, resetView, panOffset } = useZoomControls();\n  \n  // Check if view is at default state (zoom = 1.0 and no pan offset)\n  const isViewAtDefault = zoom === 1.0 && panOffset.x === 0 && panOffset.y === 0;\n  \n  const zoomPercentage = Math.round(zoom * 100);\n  \n  return (\n    <TooltipProvider>\n      <div className=\"flex items-center gap-2\">\n        <span className=\"text-sm font-medium text-muted-foreground\">Zoom:</span>\n        \n        <div className=\"flex items-center gap-1\">\n          <Tooltip>\n            <TooltipTrigger asChild>\n              <Button\n                variant=\"outline\"\n                size=\"sm\"\n                onClick={zoomOut}\n                disabled={zoom <= 0.2}\n                className=\"h-7 w-7 p-0\"\n              >\n                <Minus className=\"w-3 h-3\" />\n              </Button>\n            </TooltipTrigger>\n            <TooltipContent>\n              <p>Zoom out (-)</p>\n            </TooltipContent>\n          </Tooltip>\n          \n          <Tooltip>\n            <TooltipTrigger asChild>\n              <Button\n                variant=\"outline\"\n                size=\"sm\"\n                onClick={resetZoom}\n                className=\"h-7 px-3 min-w-[60px]\"\n              >\n                <span className=\"text-xs font-medium\">{zoomPercentage}%</span>\n              </Button>\n            </TooltipTrigger>\n            <TooltipContent>\n              <p>Reset zoom to 100%</p>\n            </TooltipContent>\n          </Tooltip>\n          \n          <Tooltip>\n            <TooltipTrigger asChild>\n              <Button\n                variant=\"outline\"\n                size=\"sm\"\n                onClick={zoomIn}\n                disabled={zoom >= 4.0}\n                className=\"h-7 w-7 p-0\"\n              >\n                <Plus className=\"w-3 h-3\" />\n              </Button>\n            </TooltipTrigger>\n            <TooltipContent>\n              <p>Zoom in (+)</p>\n            </TooltipContent>\n          </Tooltip>\n        </div>\n        \n        <Tooltip>\n          <TooltipTrigger asChild>\n            <Button\n              variant=\"ghost\"\n              size=\"sm\"\n              onClick={resetView}\n              disabled={isViewAtDefault}\n              className=\"h-7 w-7 p-0 text-muted-foreground hover:text-foreground disabled:opacity-50\"\n            >\n              <RotateCcw className=\"w-3 h-3\" />\n            </Button>\n          </TooltipTrigger>\n          <TooltipContent>\n            <p>Reset view (zoom and position)</p>\n          </TooltipContent>\n        </Tooltip>\n      </div>\n    </TooltipProvider>\n  );\n};\n","usedDeprecatedRules":[]},{"filePath":"/Users/cameronfoxly/GitHubRepos/Ascii-Motion/src/components/features/effects/HueSaturationEffectPanel.tsx","messages":[],"suppressedMessages":[{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useEffect has missing dependencies: 'isCurrentlyPreviewing', 'startPreview', and 'stopPreview'. Either include them or remove the dependency array.","line":46,"column":6,"nodeType":"ArrayExpression","endLine":46,"endColumn":8,"suggestions":[{"desc":"Update the dependencies array to be: [isCurrentlyPreviewing, startPreview, stopPreview]","fix":{"range":[1275,1277],"text":"[isCurrentlyPreviewing, startPreview, stopPreview]"}}],"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/cameronfoxly/GitHubRepos/Ascii-Motion/src/components/features/effects/LevelsEffectPanel.tsx","messages":[],"suppressedMessages":[{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useEffect has missing dependencies: 'isCurrentlyPreviewing', 'startPreview', and 'stopPreview'. Either include them or remove the dependency array.","line":47,"column":6,"nodeType":"ArrayExpression","endLine":47,"endColumn":8,"suggestions":[{"desc":"Update the dependencies array to be: [isCurrentlyPreviewing, startPreview, stopPreview]","fix":{"range":[1309,1311],"text":"[isCurrentlyPreviewing, startPreview, stopPreview]"}}],"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/cameronfoxly/GitHubRepos/Ascii-Motion/src/components/features/effects/RemapCharactersEffectPanel.tsx","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":17,"column":74,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":17,"endColumn":77,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[742,745],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[742,745],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useEffect has missing dependencies: 'analyzeCanvas', 'clearAnalysisCache', 'isCurrentlyPreviewing', 'startPreview', and 'stopPreview'. Either include them or remove the dependency array.","line":100,"column":6,"nodeType":"ArrayExpression","endLine":100,"endColumn":8,"suggestions":[{"desc":"Update the dependencies array to be: [analyzeCanvas, clearAnalysisCache, isCurrentlyPreviewing, startPreview, stopPreview]","fix":{"range":[3454,3456],"text":"[analyzeCanvas, clearAnalysisCache, isCurrentlyPreviewing, startPreview, stopPreview]"}}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useEffect has missing dependencies: 'isCurrentlyPreviewing', 'startPreview', and 'stopPreview'. Either include them or remove the dependency array.","line":148,"column":6,"nodeType":"ArrayExpression","endLine":148,"endColumn":8,"suggestions":[{"desc":"Update the dependencies array to be: [isCurrentlyPreviewing, startPreview, stopPreview]","fix":{"range":[5240,5242],"text":"[isCurrentlyPreviewing, startPreview, stopPreview]"}}],"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * RemapCharactersEffectPanel - Character remapping controls\n * \n * Provides intuitive character remapping with automatic canvas character detection\n * and direct From/To character editing interface.\n */\n\nimport { useCallback, useEffect, useMemo, useState } from 'react';\nimport { Button } from '../../ui/button';\nimport { Label } from '../../ui/label';\nimport { useEffectsStore } from '../../../stores/effectsStore';\nimport { useCanvasStore } from '../../../stores/canvasStore';\nimport { EnhancedCharacterPicker } from '../EnhancedCharacterPicker';\nimport { RotateCcw, Eye, EyeOff, MoveRight, RotateCcwSquare } from 'lucide-react';\n\n// Character utility functions\nconst sortCharactersByFrequency = (characters: string[], canvasAnalysis: any): string[] => {\n  const charFrequency = canvasAnalysis?.charactersByFrequency || [];\n  const frequencyMap = charFrequency.reduce((map: Record<string, number>, { char, count }: { char: string, count: number }) => {\n    map[char] = count;\n    return map;\n  }, {});\n\n  return characters.sort((a, b) => {\n    const freqA = frequencyMap[a] || 0;\n    const freqB = frequencyMap[b] || 0;\n    // Sort by frequency (descending), then alphabetically\n    if (freqA !== freqB) {\n      return freqB - freqA;\n    }\n    return a.localeCompare(b);\n  });\n};\n\nexport function RemapCharactersEffectPanel() {\n  const { \n    remapCharactersSettings,\n    updateRemapCharactersSettings,\n    resetEffectSettings,\n    isPreviewActive,\n    previewEffect,\n    startPreview,\n    stopPreview,\n    updatePreview,\n    getUniqueCharacters,\n    analyzeCanvas,\n    canvasAnalysis,\n    isAnalyzing,\n    clearAnalysisCache\n  } = useEffectsStore();\n\n  const { cells } = useCanvasStore();\n\n  const isCurrentlyPreviewing = isPreviewActive && previewEffect === 'remap-characters';\n\n  // Character picker state\n  const [isCharacterPickerOpen, setIsCharacterPickerOpen] = useState(false);\n  const [characterPickerTarget, setCharacterPickerTarget] = useState<{ \n    fromChar: string; \n    isToChar: boolean; \n    triggerRef: React.RefObject<HTMLElement | null> | null \n  }>({ fromChar: '', isToChar: false, triggerRef: null });\n\n  // Get all unique characters from canvas analysis, sorted by frequency\n  const allCanvasCharacters = useMemo(() => {\n    // Only get characters if analysis is complete (not analyzing and has results)\n    if (isAnalyzing || !canvasAnalysis) {\n      return [];\n    }\n    const characters = getUniqueCharacters().filter(char => char.trim() !== ''); // Filter out empty/whitespace\n    return sortCharactersByFrequency(characters, canvasAnalysis);\n  }, [getUniqueCharacters, isAnalyzing, canvasAnalysis]);\n\n  // Create refs for all character picker buttons (must be at top level)\n  const characterPickerButtonRefs = useMemo(() => {\n    const refs: Record<string, React.RefObject<HTMLButtonElement | null>> = {};\n    allCanvasCharacters.forEach((fromChar) => {\n      refs[`${fromChar}-from`] = { current: null };\n      refs[`${fromChar}-to`] = { current: null };\n    });\n    return refs;\n  }, [allCanvasCharacters]);\n\n  // Auto-start preview when panel opens and analyze canvas\n  useEffect(() => {\n    // Clear cache and ensure fresh analysis every time panel opens\n    clearAnalysisCache();\n    analyzeCanvas();\n    \n    if (!isCurrentlyPreviewing) {\n      startPreview('remap-characters');\n    }\n    \n    // Cleanup on unmount\n    return () => {\n      if (isCurrentlyPreviewing) {\n        stopPreview();\n      }\n    };\n  }, []); // eslint-disable-line react-hooks/exhaustive-deps\n\n  // Re-analyze when canvas data changes (e.g., edits made outside the effect)\n  useEffect(() => {\n    // Clear cache and re-analyze when canvas cells change\n    clearAnalysisCache();\n    analyzeCanvas();\n  }, [cells, clearAnalysisCache, analyzeCanvas]);\n\n  // Initialize character mappings with identity mappings when canvas characters change\n  useEffect(() => {\n    // Only initialize if we have characters and analysis is complete\n    if (allCanvasCharacters.length > 0 && !isAnalyzing) {\n      const currentMappings = remapCharactersSettings.characterMappings;\n      const identityMappings: Record<string, string> = {};\n      \n      // Create identity mappings for all current canvas characters\n      allCanvasCharacters.forEach(char => {\n        // Preserve existing mapping if it exists, otherwise map to self\n        identityMappings[char] = currentMappings[char] || char;\n      });\n      \n      // Only update if the mappings have changed\n      const currentKeys = Object.keys(currentMappings).sort();\n      const newKeys = Object.keys(identityMappings).sort();\n      const keysChanged = JSON.stringify(currentKeys) !== JSON.stringify(newKeys);\n      \n      if (keysChanged || Object.keys(currentMappings).length === 0) {\n        updateRemapCharactersSettings({\n          characterMappings: identityMappings\n        });\n      }\n    }\n  }, [allCanvasCharacters, remapCharactersSettings.characterMappings, updateRemapCharactersSettings, isAnalyzing]);\n\n\n  // Auto-start preview when panel opens\n  useEffect(() => {\n    if (!isCurrentlyPreviewing) {\n      startPreview('remap-characters');\n    }\n    \n    // Cleanup on unmount\n    return () => {\n      if (isCurrentlyPreviewing) {\n        stopPreview();\n      }\n    };\n  }, []); // eslint-disable-line react-hooks/exhaustive-deps\n\n  // Update preview when settings change\n  useEffect(() => {\n    if (isCurrentlyPreviewing) {\n      updatePreview().catch(error => {\n        console.error('Preview update failed:', error);\n      });\n    }\n  }, [remapCharactersSettings, isCurrentlyPreviewing, updatePreview]);\n\n  // Update preview when active frame changes\n  useEffect(() => {\n    if (isCurrentlyPreviewing) {\n      updatePreview().catch(error => {\n        console.error('Preview update failed:', error);\n      });\n    }\n  }, [cells, isCurrentlyPreviewing, updatePreview]);\n\n  // Toggle preview\n  const handleTogglePreview = useCallback(() => {\n    if (isCurrentlyPreviewing) {\n      stopPreview();\n    } else {\n      startPreview('remap-characters');\n    }\n  }, [isCurrentlyPreviewing, startPreview, stopPreview]);\n\n  // Reset to default values\n  const handleReset = useCallback(() => {\n    resetEffectSettings('remap-characters');\n  }, [resetEffectSettings]);\n\n  // Update character mapping\n  const handleUpdateMapping = useCallback((fromChar: string, toChar: string, isToChar: boolean) => {\n    const newMappings = { ...remapCharactersSettings.characterMappings };\n    \n    if (isToChar) {\n      // Update the 'to' character\n      newMappings[fromChar] = toChar;\n    } else {\n      // This shouldn't happen in our UX, but handle just in case\n      console.warn('Updating from character not supported in this interface');\n    }\n    \n    updateRemapCharactersSettings({\n      characterMappings: newMappings\n    });\n  }, [remapCharactersSettings.characterMappings, updateRemapCharactersSettings]);\n\n  // Reset individual character mapping\n  const handleResetMapping = useCallback((fromChar: string) => {\n    const newMappings = { ...remapCharactersSettings.characterMappings };\n    newMappings[fromChar] = fromChar; // Reset to identity mapping\n    \n    updateRemapCharactersSettings({\n      characterMappings: newMappings\n    });\n  }, [remapCharactersSettings.characterMappings, updateRemapCharactersSettings]);\n\n  // Handle character picker\n  const handleOpenCharacterPicker = useCallback((fromChar: string, isToChar: boolean, triggerElement: HTMLElement | null) => {\n    setCharacterPickerTarget({\n      fromChar,\n      isToChar,\n      triggerRef: { current: triggerElement }\n    });\n    setIsCharacterPickerOpen(true);\n  }, []);\n\n  const handleCharacterPick = useCallback((character: string) => {\n    if (characterPickerTarget.fromChar && characterPickerTarget.isToChar) {\n      handleUpdateMapping(characterPickerTarget.fromChar, character, true);\n    }\n    setIsCharacterPickerOpen(false);\n    setCharacterPickerTarget({ fromChar: '', isToChar: false, triggerRef: null });\n  }, [characterPickerTarget, handleUpdateMapping]);\n\n  const handleCloseCharacterPicker = useCallback(() => {\n    setIsCharacterPickerOpen(false);\n    setCharacterPickerTarget({ fromChar: '', isToChar: false, triggerRef: null });\n  }, []);\n\n  return (\n    <div className=\"space-y-4\">\n      \n      {/* Live Preview Toggle */}\n      <div className=\"flex items-center justify-between p-3 bg-blue-50 dark:bg-blue-950/30 rounded border border-blue-200 dark:border-blue-800\">\n        <div className=\"space-y-1\">\n          <Label className=\"text-xs font-medium text-blue-900 dark:text-blue-100\">Live Preview</Label>\n          <div className=\"text-xs text-blue-700 dark:text-blue-300\">\n            {isCurrentlyPreviewing ? 'Changes are shown on canvas' : 'Preview is disabled'}\n          </div>\n        </div>\n        <Button\n          onClick={handleTogglePreview}\n          variant={isCurrentlyPreviewing ? \"default\" : \"outline\"}\n          size=\"sm\"\n          className=\"h-8 gap-1\"\n        >\n          {isCurrentlyPreviewing ? <Eye className=\"w-3 h-3\" /> : <EyeOff className=\"w-3 h-3\" />}\n          {isCurrentlyPreviewing ? 'On' : 'Off'}\n        </Button>\n      </div>\n\n      {/* Character Mappings */}\n      <div className=\"space-y-3\">\n        <div className=\"flex items-center justify-between\">\n          <Label className=\"text-xs font-medium\">\n            Character Mappings ({allCanvasCharacters.length})\n          </Label>\n          <Button\n            onClick={handleReset}\n            variant=\"ghost\"\n            size=\"sm\"\n            className=\"h-6 w-6 p-0\"\n            title=\"Reset all mappings\"\n            disabled={allCanvasCharacters.length === 0}\n          >\n            <RotateCcw className=\"w-3 h-3\" />\n          </Button>\n        </div>\n\n        {isAnalyzing ? (\n          <div className=\"p-4 border border-dashed border-muted-foreground/50 rounded text-center text-xs text-muted-foreground\">\n            Analyzing canvas characters...\n          </div>\n        ) : allCanvasCharacters.length === 0 ? (\n          <div className=\"p-4 border border-dashed border-muted-foreground/50 rounded text-center text-xs text-muted-foreground\">\n            No characters found in canvas. Draw something to see character mappings.\n          </div>\n        ) : (\n          <div className=\"space-y-2 max-h-64 overflow-y-auto\">\n            {/* Header */}\n            <div className=\"grid grid-cols-[32px_32px_32px_24px_24px] gap-2 items-center text-xs font-medium text-muted-foreground px-1\">\n              <div>From</div>\n              <div></div>\n              <div>To</div>\n              <div></div>\n              <div></div>\n            </div>\n\n            {/* Character mappings */}\n            <div className=\"space-y-1\">\n              {allCanvasCharacters.map((fromChar) => {\n                const toChar = remapCharactersSettings.characterMappings[fromChar] || fromChar;\n                const toButtonRef = characterPickerButtonRefs[`${fromChar}-to`];\n\n                return (\n                  <div \n                    key={fromChar} \n                    className=\"grid grid-cols-[32px_32px_32px_24px_24px] gap-2 items-center p-2 bg-background rounded border border-muted/30 hover:bg-muted/50 hover:border-muted/50 transition-colors text-xs\"\n                  >\n                    {/* From Character (read-only display) */}\n                    <div className=\"flex items-center justify-center\">\n                      <div className=\"w-6 h-6 bg-muted/50 border rounded text-center font-mono text-xs flex items-center justify-center\">\n                        {fromChar === ' ' ? '␣' : fromChar}\n                      </div>\n                    </div>\n\n                    {/* Arrow */}\n                    <div className=\"flex justify-center\">\n                      <MoveRight className=\"w-4 h-4 text-muted-foreground\" />\n                    </div>\n\n                    {/* To Character (editable) */}\n                    <div className=\"flex items-center justify-center\">\n                      <button\n                        ref={toButtonRef}\n                        onClick={(e) => handleOpenCharacterPicker(fromChar, true, e.currentTarget)}\n                        className=\"w-6 h-6 bg-background border rounded text-center font-mono text-xs flex items-center justify-center hover:border-blue-500 transition-colors cursor-pointer\"\n                        title={`Click to change target character for '${fromChar === ' ' ? 'space' : fromChar}'`}\n                      >\n                        {toChar === ' ' ? '␣' : toChar}\n                      </button>\n                    </div>\n\n                    {/* Individual Reset Button */}\n                    <Button\n                      onClick={() => handleResetMapping(fromChar)}\n                      variant=\"ghost\"\n                      size=\"sm\"\n                      className=\"h-6 w-6 p-0 text-muted-foreground hover:text-blue-600\"\n                      title={`Reset '${fromChar === ' ' ? 'space' : fromChar}' to map to itself`}\n                      disabled={fromChar === toChar}\n                    >\n                      <RotateCcwSquare className=\"w-3 h-3\" />\n                    </Button>\n\n                    {/* Remove Button - Hidden for auto-populated mappings */}\n                    <div className=\"w-6 h-6\"></div>\n                  </div>\n                );\n              })}\n            </div>\n          </div>\n        )}\n      </div>\n\n      {/* Character Picker */}\n      {isCharacterPickerOpen && characterPickerTarget.triggerRef && (\n        <EnhancedCharacterPicker\n          isOpen={isCharacterPickerOpen}\n          onClose={handleCloseCharacterPicker}\n          onSelectCharacter={handleCharacterPick}\n          triggerRef={characterPickerTarget.triggerRef}\n          initialValue=\"\"\n          title=\"Select Replacement Character\"\n        />\n      )}\n      \n    </div>\n  );\n}","usedDeprecatedRules":[]},{"filePath":"/Users/cameronfoxly/GitHubRepos/Ascii-Motion/src/components/features/effects/RemapColorsEffectPanel.tsx","messages":[],"suppressedMessages":[{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useEffect has missing dependencies: 'analyzeCanvas', 'clearAnalysisCache', 'isCurrentlyPreviewing', 'startPreview', and 'stopPreview'. Either include them or remove the dependency array.","line":121,"column":6,"nodeType":"ArrayExpression","endLine":121,"endColumn":8,"suggestions":[{"desc":"Update the dependencies array to be: [analyzeCanvas, clearAnalysisCache, isCurrentlyPreviewing, startPreview, stopPreview]","fix":{"range":[3630,3632],"text":"[analyzeCanvas, clearAnalysisCache, isCurrentlyPreviewing, startPreview, stopPreview]"}}],"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/cameronfoxly/GitHubRepos/Ascii-Motion/src/components/features/timeEffects/AddFramesDialog.tsx","messages":[{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useEffect has a missing dependency: 'handleApply'. Either include it or remove the dependency array.","line":63,"column":6,"nodeType":"ArrayExpression","endLine":63,"endColumn":51,"suggestions":[{"desc":"Update the dependencies array to be: [isAddFramesDialogOpen, closeAddFramesDialog, handleApply]","fix":{"range":[2335,2380],"text":"[isAddFramesDialogOpen, closeAddFramesDialog, handleApply]"}}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useState, useRef, useEffect, useCallback } from 'react';\nimport { createPortal } from 'react-dom';\nimport { Button } from '@/components/ui/button';\nimport { Card } from '@/components/ui/card';\nimport { Input } from '@/components/ui/input';\nimport { Label } from '@/components/ui/label';\nimport { Checkbox } from '@/components/ui/checkbox';\nimport { DraggableDialogBar } from '@/components/common/DraggableDialogBar';\nimport { useTimeEffectsStore } from '@/stores/timeEffectsStore';\nimport { useAnimationStore } from '@/stores/animationStore';\nimport { useAnimationHistory } from '@/hooks/useAnimationHistory';\nimport { ADD_FRAMES_LIMITS } from '@/constants/timeEffects';\n\nexport const AddFramesDialog: React.FC = () => {\n  const { \n    isAddFramesDialogOpen, \n    closeAddFramesDialog \n  } = useTimeEffectsStore();\n  \n  const { frames, currentFrameIndex } = useAnimationStore();\n  const { addMultipleFrames } = useAnimationHistory();\n\n  // Dialog state\n  const [positionOffset, setPositionOffset] = useState({ x: 0, y: 0 });\n  const [isDraggingDialog, setIsDraggingDialog] = useState(false);\n  const [hasBeenDragged, setHasBeenDragged] = useState(false);\n  const dragStartOffsetRef = useRef({ x: 0, y: 0 });\n  const dialogRef = useRef<HTMLDivElement>(null);\n  \n  // Form state\n  const [frameCount, setFrameCount] = useState(1);\n  const [frameCountInput, setFrameCountInput] = useState('1');\n  const [duplicateCurrentFrame, setDuplicateCurrentFrame] = useState(true);\n  \n  // Reset position when dialog opens\n  useEffect(() => {\n    if (isAddFramesDialogOpen) {\n      setPositionOffset({ x: 0, y: 0 });\n      setHasBeenDragged(false);\n      // Reset form to defaults\n      setFrameCount(1);\n      setFrameCountInput('1');\n      setDuplicateCurrentFrame(true);\n    }\n  }, [isAddFramesDialogOpen]);\n\n  // Handle escape key to close\n  useEffect(() => {\n    const handleKeyDown = (event: KeyboardEvent) => {\n      if (!isAddFramesDialogOpen) return;\n      \n      if (event.key === 'Escape') {\n        event.preventDefault();\n        closeAddFramesDialog();\n      } else if (event.key === 'Enter' && !event.shiftKey) {\n        event.preventDefault();\n        handleApply();\n      }\n    };\n\n    document.addEventListener('keydown', handleKeyDown);\n    return () => document.removeEventListener('keydown', handleKeyDown);\n  }, [isAddFramesDialogOpen, closeAddFramesDialog]);\n\n  // Dragging handlers\n  const handleDrag = useCallback((deltaX: number, deltaY: number) => {\n    setPositionOffset({\n      x: dragStartOffsetRef.current.x + deltaX,\n      y: dragStartOffsetRef.current.y + deltaY\n    });\n  }, []);\n  \n  const handleDragStart = useCallback(() => {\n    setIsDraggingDialog(true);\n    setHasBeenDragged(true);\n    dragStartOffsetRef.current = { ...positionOffset };\n  }, [positionOffset]);\n  \n  const handleDragEnd = useCallback(() => {\n    setIsDraggingDialog(false);\n    dragStartOffsetRef.current = { ...positionOffset };\n  }, [positionOffset]);\n\n  // Handle input changes - allow typing without validation\n  const handleFrameCountChange = (value: string) => {\n    // Allow empty string or numbers only (no decimals)\n    if (value === '' || /^\\d+$/.test(value)) {\n      setFrameCountInput(value);\n      // Only update frameCount state if valid number\n      if (value !== '') {\n        const numValue = parseInt(value, 10);\n        setFrameCount(numValue);\n      }\n    }\n  };\n\n  const handleFrameCountBlur = () => {\n    // Validate and clamp on blur\n    if (frameCountInput === '') {\n      const defaultValue = ADD_FRAMES_LIMITS.MIN_COUNT;\n      setFrameCountInput(defaultValue.toString());\n      setFrameCount(defaultValue);\n    } else {\n      const numValue = parseInt(frameCountInput, 10);\n      const clampedValue = Math.max(\n        ADD_FRAMES_LIMITS.MIN_COUNT,\n        Math.min(ADD_FRAMES_LIMITS.MAX_COUNT, numValue)\n      );\n      setFrameCountInput(clampedValue.toString());\n      setFrameCount(clampedValue);\n    }\n  };\n\n  // Apply changes\n  const handleApply = () => {\n    const sourceFrame = duplicateCurrentFrame ? frames[currentFrameIndex] : null;\n    addMultipleFrames(frameCount, sourceFrame);\n    closeAddFramesDialog();\n  };\n\n  // Calculate dialog position (lower-left corner)\n  const getDialogPosition = () => {\n    const dialogWidth = 400;\n    const margin = 8;\n    \n    // Calculate maxHeight to ensure dialog fits on screen\n    const viewportHeight = window.innerHeight;\n    const maxHeight = viewportHeight - (margin * 2);\n    \n    return {\n      bottom: margin,\n      left: margin,\n      width: dialogWidth,\n      maxHeight: `${maxHeight}px`\n    };\n  };\n\n  if (!isAddFramesDialogOpen) return null;\n\n  const position = getDialogPosition();\n\n  return createPortal(\n    <div\n      ref={dialogRef}\n      className={`fixed z-[99999] ${\n        !hasBeenDragged ? 'animate-in duration-200 slide-in-from-bottom-4 fade-in-0' : ''\n      }`}\n      style={{\n        bottom: position.bottom - positionOffset.y,\n        left: position.left + positionOffset.x,\n        width: position.width,\n        maxHeight: position.maxHeight,\n        transition: isDraggingDialog ? 'none' : undefined\n      }}\n      onClick={(e) => e.stopPropagation()}\n    >\n      <Card className=\"border border-border/50 shadow-lg\">\n        <DraggableDialogBar \n          title=\"Add Frames\" \n          onDrag={handleDrag}\n          onDragStart={handleDragStart}\n          onDragEnd={handleDragEnd}\n          onClose={closeAddFramesDialog}\n        />\n        \n        <div className=\"p-6 space-y-6\">\n          <div className=\"text-sm text-muted-foreground\">\n            Add multiple frames to your animation. New frames will be appended at the end.\n          </div>\n          \n          <div className=\"space-y-4\">\n            <div className=\"space-y-2\">\n              <Label htmlFor=\"frame-count-input\">Number of frames to add</Label>\n              <Input\n                id=\"frame-count-input\"\n                type=\"text\"\n                inputMode=\"numeric\"\n                value={frameCountInput}\n                onChange={(e) => handleFrameCountChange(e.target.value)}\n                onBlur={handleFrameCountBlur}\n                className=\"w-full\"\n              />\n              <div className=\"text-xs text-muted-foreground\">\n                Range: {ADD_FRAMES_LIMITS.MIN_COUNT}-{ADD_FRAMES_LIMITS.MAX_COUNT} frames\n              </div>\n            </div>\n            \n            <div className=\"flex items-center space-x-2\">\n              <Checkbox\n                id=\"duplicate-frame\"\n                checked={duplicateCurrentFrame}\n                onCheckedChange={(checked) => setDuplicateCurrentFrame(checked === true)}\n              />\n              <Label \n                htmlFor=\"duplicate-frame\" \n                className=\"text-sm font-normal cursor-pointer\"\n              >\n                Duplicate current frame content\n              </Label>\n            </div>\n            \n            <div className=\"text-xs text-muted-foreground bg-muted/50 p-3 rounded space-y-1\">\n              <div>\n                <strong>Current frame:</strong> {currentFrameIndex + 1} of {frames.length}\n              </div>\n              {duplicateCurrentFrame ? (\n                <div>\n                  ✓ New frames will contain the same content as frame {currentFrameIndex + 1}\n                </div>\n              ) : (\n                <div>\n                  ○ New frames will be empty (transparent background)\n                </div>\n              )}\n              <div>\n                <strong>After adding:</strong> Total frames will be {frames.length + frameCount}\n              </div>\n            </div>\n          </div>\n        </div>\n        \n        <div className=\"flex justify-end gap-2 p-6 pt-0\">\n          <Button variant=\"outline\" onClick={closeAddFramesDialog}>\n            Cancel\n          </Button>\n          <Button onClick={handleApply}>\n            Add {frameCount} Frame{frameCount !== 1 ? 's' : ''}\n          </Button>\n        </div>\n      </Card>\n    </div>,\n    document.body\n  );\n};","usedDeprecatedRules":[]},{"filePath":"/Users/cameronfoxly/GitHubRepos/Ascii-Motion/src/components/features/timeEffects/SetFrameDurationDialog.tsx","messages":[{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useEffect has a missing dependency: 'handleApply'. Either include it or remove the dependency array.","line":94,"column":6,"nodeType":"ArrayExpression","endLine":94,"endColumn":55,"suggestions":[{"desc":"Update the dependencies array to be: [isSetDurationDialogOpen, closeSetDurationDialog, handleApply]","fix":{"range":[3693,3742],"text":"[isSetDurationDialogOpen, closeSetDurationDialog, handleApply]"}}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useState, useRef, useEffect, useCallback, useMemo } from 'react';\nimport { createPortal } from 'react-dom';\nimport { Button } from '@/components/ui/button';\nimport { Card } from '@/components/ui/card';\nimport { Input } from '@/components/ui/input';\nimport { Label } from '@/components/ui/label';\nimport { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs';\nimport { DraggableDialogBar } from '@/components/common/DraggableDialogBar';\nimport { useTimeEffectsStore } from '@/stores/timeEffectsStore';\nimport { useTimeEffectsHistory } from '@/hooks/useTimeEffectsHistory';\nimport { useAnimationStore } from '@/stores/animationStore';\nimport { fpsToMs, msToFps } from '@/utils/timeEffectsProcessing';\nimport { FRAME_DURATION_LIMITS } from '@/constants/timeEffects';\nimport type { FrameDurationMode } from '@/types/timeEffects';\n\nexport const SetFrameDurationDialog: React.FC = () => {\n  const { \n    isSetDurationDialogOpen, \n    closeSetDurationDialog \n  } = useTimeEffectsStore();\n  \n  const { setFrameDurationsWithHistory } = useTimeEffectsHistory();\n  const { frames, selectedFrameIndices } = useAnimationStore();\n\n  const selectedIndices = useMemo(() => {\n    return Array.from(selectedFrameIndices).sort((a, b) => a - b);\n  }, [selectedFrameIndices]);\n\n  const hasMultiSelection = selectedIndices.length > 1;\n  const targetIndices = useMemo(() => {\n    if (hasMultiSelection) {\n      return selectedIndices;\n    }\n    return frames.map((_, index) => index);\n  }, [hasMultiSelection, selectedIndices, frames]);\n\n  // Dialog state\n  const [positionOffset, setPositionOffset] = useState({ x: 0, y: 0 });\n  const [isDraggingDialog, setIsDraggingDialog] = useState(false);\n  const [hasBeenDragged, setHasBeenDragged] = useState(false);\n  const dragStartOffsetRef = useRef({ x: 0, y: 0 });\n  const dialogRef = useRef<HTMLDivElement>(null);\n  \n  // Form state\n  const [mode, setMode] = useState<FrameDurationMode>('ms');\n  const [milliseconds, setMilliseconds] = useState(100);\n  const [fps, setFps] = useState(10);\n  \n  // Input text state (allows empty/partial input while typing)\n  const [msInputValue, setMsInputValue] = useState('100');\n  const [fpsInputValue, setFpsInputValue] = useState('10');\n  \n  // Calculate current average frame duration for initial values\n  useEffect(() => {\n    if (isSetDurationDialogOpen && targetIndices.length > 0) {\n      const totalDuration = targetIndices.reduce((sum, frameIndex) => {\n        const frame = frames[frameIndex];\n        return frame ? sum + frame.duration : sum;\n      }, 0);\n      const averageDuration = totalDuration / targetIndices.length;\n      const roundedMs = Math.round(averageDuration);\n      const roundedFps = Math.round(msToFps(averageDuration));\n      setMilliseconds(roundedMs);\n      setFps(roundedFps);\n      setMsInputValue(roundedMs.toString());\n      setFpsInputValue(roundedFps.toString());\n    }\n  }, [isSetDurationDialogOpen, frames, targetIndices]);\n\n  // Reset position when dialog opens\n  useEffect(() => {\n    if (isSetDurationDialogOpen) {\n      setPositionOffset({ x: 0, y: 0 });\n      setHasBeenDragged(false);\n    }\n  }, [isSetDurationDialogOpen]);\n\n  // Handle escape key to close\n  useEffect(() => {\n    const handleKeyDown = (event: KeyboardEvent) => {\n      if (!isSetDurationDialogOpen) return;\n      \n      if (event.key === 'Escape') {\n        event.preventDefault();\n        closeSetDurationDialog();\n      } else if (event.key === 'Enter' && !event.shiftKey) {\n        event.preventDefault();\n        handleApply();\n      }\n    };\n\n    document.addEventListener('keydown', handleKeyDown);\n    return () => document.removeEventListener('keydown', handleKeyDown);\n  }, [isSetDurationDialogOpen, closeSetDurationDialog]);\n\n  // Sync display values when mode changes (not input values - those stay as user typed)\n  useEffect(() => {\n    if (mode === 'ms') {\n      const roundedFps = Math.round(msToFps(milliseconds));\n      setFps(roundedFps);\n    } else {\n      const roundedMs = Math.round(fpsToMs(fps));\n      setMilliseconds(roundedMs);\n    }\n  }, [mode, milliseconds, fps]);\n\n  // Dragging handlers\n  const handleDrag = useCallback((deltaX: number, deltaY: number) => {\n    setPositionOffset({\n      x: dragStartOffsetRef.current.x + deltaX,\n      y: dragStartOffsetRef.current.y + deltaY\n    });\n  }, []);\n  \n  const handleDragStart = useCallback(() => {\n    setIsDraggingDialog(true);\n    setHasBeenDragged(true);\n    dragStartOffsetRef.current = { ...positionOffset };\n  }, [positionOffset]);\n  \n  const handleDragEnd = useCallback(() => {\n    setIsDraggingDialog(false);\n    dragStartOffsetRef.current = { ...positionOffset };\n  }, [positionOffset]);\n\n  // Handle input changes - allow typing without validation\n  const handleMillisecondsChange = (value: string) => {\n    // Allow empty string or numbers only (no decimals)\n    if (value === '' || /^\\d+$/.test(value)) {\n      setMsInputValue(value);\n      // Only update milliseconds state if valid number\n      if (value !== '') {\n        const numValue = parseInt(value, 10);\n        setMilliseconds(numValue);\n      }\n    }\n  };\n\n  const handleMillisecondsBlur = () => {\n    // Validate and clamp on blur\n    if (msInputValue === '') {\n      const defaultValue = FRAME_DURATION_LIMITS.MIN_MS;\n      setMsInputValue(defaultValue.toString());\n      setMilliseconds(defaultValue);\n    } else {\n      const numValue = parseInt(msInputValue, 10);\n      const clampedValue = Math.max(\n        FRAME_DURATION_LIMITS.MIN_MS,\n        Math.min(FRAME_DURATION_LIMITS.MAX_MS, numValue)\n      );\n      setMsInputValue(clampedValue.toString());\n      setMilliseconds(clampedValue);\n    }\n  };\n\n  const handleFpsChange = (value: string) => {\n    // Allow empty string or numbers only (no decimals)\n    if (value === '' || /^\\d+$/.test(value)) {\n      setFpsInputValue(value);\n      // Only update fps state if valid number\n      if (value !== '') {\n        const numValue = parseInt(value, 10);\n        setFps(numValue);\n      }\n    }\n  };\n\n  const handleFpsBlur = () => {\n    // Validate and clamp on blur\n    if (fpsInputValue === '') {\n      const defaultValue = FRAME_DURATION_LIMITS.MIN_FPS;\n      setFpsInputValue(defaultValue.toString());\n      setFps(defaultValue);\n    } else {\n      const numValue = parseInt(fpsInputValue, 10);\n      const clampedValue = Math.max(\n        FRAME_DURATION_LIMITS.MIN_FPS,\n        Math.min(FRAME_DURATION_LIMITS.MAX_FPS, numValue)\n      );\n      setFpsInputValue(clampedValue.toString());\n      setFps(clampedValue);\n    }\n  };\n\n  // Apply changes\n  const handleApply = () => {\n  const targetDuration = mode === 'ms' ? milliseconds : fpsToMs(fps);\n  setFrameDurationsWithHistory(targetDuration, targetIndices);\n  };\n\n  // Calculate dialog position (lower-left corner)\n  const getDialogPosition = () => {\n    const dialogWidth = 400;\n    const margin = 8;\n    \n    // Calculate maxHeight to ensure dialog fits on screen\n    const viewportHeight = window.innerHeight;\n    const maxHeight = viewportHeight - (margin * 2);\n    \n    return {\n      bottom: margin,\n      left: margin,\n      width: dialogWidth,\n      maxHeight: `${maxHeight}px`\n    };\n  };\n\n  if (!isSetDurationDialogOpen) return null;\n\n  const position = getDialogPosition();\n\n  return createPortal(\n    <div\n      ref={dialogRef}\n      className={`fixed z-[99999] ${\n        !hasBeenDragged ? 'animate-in duration-200 slide-in-from-bottom-4 fade-in-0' : ''\n      }`}\n      style={{\n        bottom: position.bottom - positionOffset.y,\n        left: position.left + positionOffset.x,\n        width: position.width,\n        maxHeight: position.maxHeight,\n        transition: isDraggingDialog ? 'none' : undefined\n      }}\n      onClick={(e) => e.stopPropagation()}\n    >\n      <Card className=\"border border-border/50 shadow-lg\">\n        <DraggableDialogBar \n          title=\"Set Frame Duration\" \n          onDrag={handleDrag}\n          onDragStart={handleDragStart}\n          onDragEnd={handleDragEnd}\n          onClose={closeSetDurationDialog}\n        />\n        \n        <div className=\"p-6 space-y-6\">\n          <div className=\"text-sm text-muted-foreground\">\n            {hasMultiSelection ? (\n              <>\n                Set the duration for the <strong>{targetIndices.length}</strong> selected frame\n                {targetIndices.length === 1 ? '' : 's'}. This leaves unselected frames untouched.\n              </>\n            ) : (\n              <>Set the duration for all {frames.length} frames in the animation. This affects playback speed.</>\n            )}\n          </div>\n          \n          <Tabs value={mode} onValueChange={(value) => setMode(value as FrameDurationMode)}>\n            <TabsList className=\"grid w-full grid-cols-2\">\n              <TabsTrigger value=\"ms\">Milliseconds</TabsTrigger>\n              <TabsTrigger value=\"fps\">FPS</TabsTrigger>\n            </TabsList>\n            \n            <TabsContent value=\"ms\" className=\"space-y-4 mt-4\">\n              <div className=\"space-y-2\">\n                <Label htmlFor=\"ms-input\">Duration (ms)</Label>\n                <Input\n                  id=\"ms-input\"\n                  type=\"text\"\n                  inputMode=\"numeric\"\n                  value={msInputValue}\n                  onChange={(e) => handleMillisecondsChange(e.target.value)}\n                  onBlur={handleMillisecondsBlur}\n                  className=\"w-full\"\n                />\n                <div className=\"text-xs text-muted-foreground\">\n                  Range: {FRAME_DURATION_LIMITS.MIN_MS}-{FRAME_DURATION_LIMITS.MAX_MS}ms\n                  {milliseconds > 0 && (\n                    <> {' • '}Equivalent to {Math.round(msToFps(milliseconds))} FPS</>\n                  )}\n                </div>\n              </div>\n            </TabsContent>\n            \n            <TabsContent value=\"fps\" className=\"space-y-4 mt-4\">\n              <div className=\"space-y-2\">\n                <Label htmlFor=\"fps-input\">Frames per Second</Label>\n                <Input\n                  id=\"fps-input\"\n                  type=\"text\"\n                  inputMode=\"numeric\"\n                  value={fpsInputValue}\n                  onChange={(e) => handleFpsChange(e.target.value)}\n                  onBlur={handleFpsBlur}\n                  className=\"w-full\"\n                />\n                <div className=\"text-xs text-muted-foreground\">\n                  Range: {FRAME_DURATION_LIMITS.MIN_FPS}-{FRAME_DURATION_LIMITS.MAX_FPS} FPS\n                  {fps > 0 && (\n                    <> {' • '}Equivalent to {fpsToMs(fps)}ms per frame</>\n                  )}\n                </div>\n              </div>\n            </TabsContent>\n          </Tabs>\n\n          <div className=\"text-xs text-muted-foreground bg-muted/50 p-3 rounded\">\n            {hasMultiSelection ? (\n              <>\n                <strong>Note:</strong> Only the {targetIndices.length} selected frame\n                {targetIndices.length === 1 ? '' : 's'} will be updated. Undo restores previous durations and the selection highlight.\n              </>\n            ) : (\n              <>\n                <strong>Note:</strong> This will set the same duration for all {frames.length} frames in your animation.\n                You can undo this change if needed.\n              </>\n            )}\n          </div>\n        </div>\n        \n        <div className=\"flex justify-end gap-2 p-6 pt-0\">\n          <Button variant=\"outline\" onClick={closeSetDurationDialog}>\n            Cancel\n          </Button>\n          <Button onClick={handleApply}>\n            Apply\n          </Button>\n        </div>\n      </Card>\n    </div>,\n    document.body\n  );\n};","usedDeprecatedRules":[]},{"filePath":"/Users/cameronfoxly/GitHubRepos/Ascii-Motion/src/components/features/timeEffects/WaveWarpDialog.tsx","messages":[{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useEffect has missing dependencies: 'handleApply' and 'handleCancel'. Either include them or remove the dependency array.","line":106,"column":6,"nodeType":"ArrayExpression","endLine":106,"endColumn":28,"suggestions":[{"desc":"Update the dependencies array to be: [handleApply, handleCancel, isWaveWarpDialogOpen]","fix":{"range":[3795,3817],"text":"[handleApply, handleCancel, isWaveWarpDialogOpen]"}}]}],"suppressedMessages":[{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useEffect has missing dependencies: 'isPreviewActive', 'startPreview', and 'updateWaveWarpSettings'. Either include them or remove the dependency array.","line":74,"column":6,"nodeType":"ArrayExpression","endLine":74,"endColumn":43,"suggestions":[{"desc":"Update the dependencies array to be: [isWaveWarpDialogOpen, frames.length, updateWaveWarpSettings, isPreviewActive, startPreview]","fix":{"range":[2706,2743],"text":"[isWaveWarpDialogOpen, frames.length, updateWaveWarpSettings, isPreviewActive, startPreview]"}}],"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useState, useRef, useEffect, useCallback } from 'react';\nimport { createPortal } from 'react-dom';\nimport { Button } from '@/components/ui/button';\nimport { Card } from '@/components/ui/card';\nimport { Input } from '@/components/ui/input';\nimport { Label } from '@/components/ui/label';\nimport { Checkbox } from '@/components/ui/checkbox';\nimport { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/components/ui/select';\nimport { Slider } from '@/components/ui/slider';\nimport { DraggableDialogBar } from '@/components/common/DraggableDialogBar';\nimport { useTimeEffectsStore } from '@/stores/timeEffectsStore';\nimport { useTimeEffectsHistory } from '@/hooks/useTimeEffectsHistory';\nimport { useAnimationStore } from '@/stores/animationStore';\nimport { \n  DEFAULT_WAVE_WARP_SETTINGS, \n  WAVE_WARP_RANGES\n} from '@/constants/timeEffects';\nimport type { WaveAxis, FrameRangeSettings } from '@/types/timeEffects';\nimport { Eye, EyeOff } from 'lucide-react';\n\nexport const WaveWarpDialog: React.FC = () => {\n  const { \n    isWaveWarpDialogOpen, \n    closeWaveWarpDialog,\n    waveWarpSettings,\n    updateWaveWarpSettings,\n    updateFrameRange,\n    isPreviewActive,\n    previewEffect,\n    startPreview,\n    stopPreview,\n    updatePreview\n  } = useTimeEffectsStore();\n  \n  const { applyWaveWarpWithHistory } = useTimeEffectsHistory();\n  const { frames, currentFrameIndex } = useAnimationStore();\n\n  // Dialog state\n  const [positionOffset, setPositionOffset] = useState({ x: 0, y: 0 });\n  const [isDraggingDialog, setIsDraggingDialog] = useState(false);\n  const [hasBeenDragged, setHasBeenDragged] = useState(false);\n  const dragStartOffsetRef = useRef({ x: 0, y: 0 });\n  const dialogRef = useRef<HTMLDivElement>(null);\n  \n  // Local frame range state (separate from effect settings)\n  const [localFrameRange, setLocalFrameRange] = useState<FrameRangeSettings>({\n    applyToAll: true,\n    startFrame: 0,\n    endFrame: 0\n  });\n  \n  // Reset position and settings when dialog opens\n  useEffect(() => {\n    if (isWaveWarpDialogOpen) {\n      setPositionOffset({ x: 0, y: 0 });\n      setHasBeenDragged(false);\n      // Reset to defaults\n      updateWaveWarpSettings(DEFAULT_WAVE_WARP_SETTINGS);\n      setLocalFrameRange({\n        startFrame: 0,\n        endFrame: Math.max(0, frames.length - 1),\n        applyToAll: true\n      });\n      \n      // Auto-start preview (default to on)\n      setTimeout(() => {\n        if (!isPreviewActive) {\n          console.log('[WaveWarp] Auto-starting preview');\n          startPreview('wave-warp');\n        }\n      }, 100); // Small delay to ensure dialog is fully mounted\n    }\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [isWaveWarpDialogOpen, frames.length]); // Intentionally omit isPreviewActive to avoid infinite loop\n\n  // Stop preview when dialog closes\n  useEffect(() => {\n    if (!isWaveWarpDialogOpen && isPreviewActive && previewEffect === 'wave-warp') {\n      stopPreview();\n    }\n  }, [isWaveWarpDialogOpen, isPreviewActive, previewEffect, stopPreview]);\n\n  // Update preview when current frame changes\n  useEffect(() => {\n    if (isWaveWarpDialogOpen && isPreviewActive) {\n      updatePreview();\n    }\n  }, [currentFrameIndex, isWaveWarpDialogOpen, isPreviewActive, updatePreview]);\n\n  // Handle escape key to close\n  useEffect(() => {\n    const handleKeyDown = (event: KeyboardEvent) => {\n      if (!isWaveWarpDialogOpen) return;\n      \n      if (event.key === 'Escape') {\n        event.preventDefault();\n        handleCancel();\n      } else if (event.key === 'Enter' && !event.shiftKey) {\n        event.preventDefault();\n        handleApply();\n      }\n    };\n\n    document.addEventListener('keydown', handleKeyDown);\n    return () => document.removeEventListener('keydown', handleKeyDown);\n  }, [isWaveWarpDialogOpen]);\n\n  // Dragging handlers\n  const handleDrag = useCallback((deltaX: number, deltaY: number) => {\n    setPositionOffset({\n      x: dragStartOffsetRef.current.x + deltaX,\n      y: dragStartOffsetRef.current.y + deltaY\n    });\n  }, []);\n  \n  const handleDragStart = useCallback(() => {\n    setIsDraggingDialog(true);\n    setHasBeenDragged(true);\n    dragStartOffsetRef.current = { ...positionOffset };\n  }, [positionOffset]);\n  \n  const handleDragEnd = useCallback(() => {\n    setIsDraggingDialog(false);\n    dragStartOffsetRef.current = { ...positionOffset };\n  }, [positionOffset]);\n\n  // Handle settings changes with preview update\n  const handleSettingChange = (updates: Partial<typeof waveWarpSettings>) => {\n    updateWaveWarpSettings(updates);\n    if (isPreviewActive) {\n      // Preview updates automatically through store\n    }\n  };\n\n  // Handle frame range changes\n  const handleFrameRangeChange = (updates: Partial<FrameRangeSettings>) => {\n    const newRange = { ...localFrameRange, ...updates };\n    setLocalFrameRange(newRange);\n    updateFrameRange(newRange);\n  };\n\n  // Toggle preview\n  const handlePreviewToggle = () => {\n    if (isPreviewActive) {\n      stopPreview();\n    } else {\n      startPreview('wave-warp');\n    }\n  };\n\n  // Apply changes\n  const handleApply = async () => {\n    // Update the frame range in store before applying\n    updateFrameRange(localFrameRange);\n    const success = await applyWaveWarpWithHistory();\n    if (success) {\n      closeWaveWarpDialog();\n    }\n  };\n\n  // Cancel and close\n  const handleCancel = () => {\n    if (isPreviewActive) {\n      stopPreview();\n    }\n    closeWaveWarpDialog();\n  };\n\n  // Calculate dialog position (lower-left corner)\n  const getDialogPosition = () => {\n    const dialogWidth = 480;\n    const dialogHeight = 600;\n    const margin = 8;\n    \n    return {\n      bottom: margin,\n      left: margin,\n      width: dialogWidth,\n      maxHeight: dialogHeight\n    };\n  };\n\n  if (!isWaveWarpDialogOpen) return null;\n\n  const position = getDialogPosition();\n\n  return createPortal(\n    <div\n      ref={dialogRef}\n      className={`fixed z-[99999] ${\n        !hasBeenDragged ? 'animate-in duration-200 slide-in-from-bottom-4 fade-in-0' : ''\n      }`}\n      style={{\n        bottom: position.bottom - positionOffset.y,\n        left: position.left + positionOffset.x,\n        width: position.width,\n        maxHeight: position.maxHeight,\n        transition: isDraggingDialog ? 'none' : undefined\n      }}\n      onClick={(e) => e.stopPropagation()}\n    >\n      <Card className=\"border border-border/50 shadow-lg\">\n        <DraggableDialogBar \n          title=\"Wave Warp Effect\" \n          onDrag={handleDrag}\n          onDragStart={handleDragStart}\n          onDragEnd={handleDragEnd}\n          onClose={handleCancel}\n        />\n        \n        <div className=\"p-6 space-y-6 max-h-[500px] overflow-y-auto\">\n          <div className=\"text-sm text-muted-foreground\">\n            Apply wave displacement to character content over time. Characters move in sine wave patterns.\n          </div>\n          \n          {/* Live Preview Toggle */}\n          <div className=\"flex items-center justify-between p-3 border border-border/50 rounded-lg bg-muted/20\">\n            <div className=\"flex items-center gap-2\">\n              {isPreviewActive ? (\n                <Eye className=\"h-4 w-4 text-primary\" />\n              ) : (\n                <EyeOff className=\"h-4 w-4 text-muted-foreground\" />\n              )}\n              <span className=\"text-sm font-medium\">Live Preview</span>\n            </div>\n            <Button\n              variant={isPreviewActive ? \"default\" : \"outline\"}\n              size=\"sm\"\n              onClick={handlePreviewToggle}\n            >\n              {isPreviewActive ? 'Stop' : 'Start'}\n            </Button>\n          </div>\n\n          {/* Wave Settings */}\n          <div className=\"space-y-4\">\n            <h3 className=\"text-sm font-semibold\">Wave Parameters</h3>\n            \n            {/* Axis Selection */}\n            <div className=\"space-y-2\">\n              <Label htmlFor=\"axis-select\">Wave Axis</Label>\n              <Select\n                value={waveWarpSettings.axis}\n                onValueChange={(value: WaveAxis) => handleSettingChange({ axis: value })}\n              >\n                <SelectTrigger>\n                  <SelectValue />\n                </SelectTrigger>\n                <SelectContent>\n                  <SelectItem value=\"horizontal\">Horizontal</SelectItem>\n                  <SelectItem value=\"vertical\">Vertical</SelectItem>\n                </SelectContent>\n              </Select>\n            </div>\n\n            {/* Frequency */}\n            <div className=\"space-y-3\">\n              <div className=\"flex items-center justify-between\">\n                <Label>Frequency</Label>\n                <span className=\"text-xs text-muted-foreground\">{waveWarpSettings.frequency.toFixed(1)}</span>\n              </div>\n              <Slider\n                value={waveWarpSettings.frequency}\n                onValueChange={(value) => handleSettingChange({ frequency: value })}\n                min={WAVE_WARP_RANGES.FREQUENCY.min}\n                max={WAVE_WARP_RANGES.FREQUENCY.max}\n                step={WAVE_WARP_RANGES.FREQUENCY.step}\n                className=\"w-full\"\n              />\n              <div className=\"text-xs text-muted-foreground\">\n                Range: {WAVE_WARP_RANGES.FREQUENCY.min} - {WAVE_WARP_RANGES.FREQUENCY.max}\n              </div>\n            </div>\n\n            {/* Amplitude */}\n            <div className=\"space-y-3\">\n              <div className=\"flex items-center justify-between\">\n                <Label>Amplitude</Label>\n                <span className=\"text-xs text-muted-foreground\">{waveWarpSettings.amplitude}</span>\n              </div>\n              <Slider\n                value={waveWarpSettings.amplitude}\n                onValueChange={(value) => handleSettingChange({ amplitude: value })}\n                min={WAVE_WARP_RANGES.AMPLITUDE.min}\n                max={WAVE_WARP_RANGES.AMPLITUDE.max}\n                step={WAVE_WARP_RANGES.AMPLITUDE.step}\n                className=\"w-full\"\n              />\n              <div className=\"text-xs text-muted-foreground\">\n                Range: {WAVE_WARP_RANGES.AMPLITUDE.min} - {WAVE_WARP_RANGES.AMPLITUDE.max} characters\n              </div>\n            </div>\n\n            {/* Speed */}\n            <div className=\"space-y-3\">\n              <div className=\"flex items-center justify-between\">\n                <Label>Speed</Label>\n                <span className=\"text-xs text-muted-foreground\">{waveWarpSettings.speed}ms</span>\n              </div>\n              <Slider\n                value={waveWarpSettings.speed}\n                onValueChange={(value) => handleSettingChange({ speed: value })}\n                min={WAVE_WARP_RANGES.SPEED.min}\n                max={WAVE_WARP_RANGES.SPEED.max}\n                step={WAVE_WARP_RANGES.SPEED.step}\n                className=\"w-full\"\n              />\n              <div className=\"text-xs text-muted-foreground\">\n                Range: {WAVE_WARP_RANGES.SPEED.min} - {WAVE_WARP_RANGES.SPEED.max}ms per cycle\n              </div>\n            </div>\n\n            {/* Phase Offset */}\n            <div className=\"space-y-3\">\n              <div className=\"flex items-center justify-between\">\n                <Label>Phase Offset</Label>\n                <span className=\"text-xs text-muted-foreground\">{waveWarpSettings.phase}°</span>\n              </div>\n              <Slider\n                value={waveWarpSettings.phase}\n                onValueChange={(value) => handleSettingChange({ phase: value })}\n                min={WAVE_WARP_RANGES.PHASE.min}\n                max={WAVE_WARP_RANGES.PHASE.max}\n                step={WAVE_WARP_RANGES.PHASE.step}\n                className=\"w-full\"\n              />\n              <div className=\"text-xs text-muted-foreground\">\n                Range: {WAVE_WARP_RANGES.PHASE.min} - {WAVE_WARP_RANGES.PHASE.max} degrees\n              </div>\n            </div>\n          </div>\n\n          {/* Frame Range Settings */}\n          <div className=\"space-y-4\">\n            <h3 className=\"text-sm font-semibold\">Frame Range</h3>\n            \n            <div className=\"flex items-center space-x-2\">\n              <Checkbox\n                id=\"all-frames\"\n                checked={localFrameRange.applyToAll}\n                onCheckedChange={(checked) => \n                  handleFrameRangeChange({ applyToAll: checked === true })\n                }\n              />\n              <Label htmlFor=\"all-frames\" className=\"text-sm\">\n                Apply to all frames\n              </Label>\n            </div>\n\n            {!localFrameRange.applyToAll && (\n              <div className=\"grid grid-cols-2 gap-4\">\n                <div className=\"space-y-2\">\n                  <Label htmlFor=\"start-frame\">Start Frame</Label>\n                  <Input\n                    id=\"start-frame\"\n                    type=\"number\"\n                    value={localFrameRange.startFrame + 1}\n                    onChange={(e) => handleFrameRangeChange({ \n                      startFrame: Math.max(0, parseInt(e.target.value) - 1 || 0)\n                    })}\n                    min={1}\n                    max={frames.length}\n                    className=\"w-full\"\n                  />\n                </div>\n                <div className=\"space-y-2\">\n                  <Label htmlFor=\"end-frame\">End Frame</Label>\n                  <Input\n                    id=\"end-frame\"\n                    type=\"number\"\n                    value={localFrameRange.endFrame + 1}\n                    onChange={(e) => handleFrameRangeChange({ \n                      endFrame: Math.min(frames.length - 1, parseInt(e.target.value) - 1 || frames.length - 1)\n                    })}\n                    min={1}\n                    max={frames.length}\n                    className=\"w-full\"\n                  />\n                </div>\n              </div>\n            )}\n\n            <div className=\"text-xs text-muted-foreground bg-muted/50 p-3 rounded\">\n              {localFrameRange.applyToAll \n                ? `Will apply to all ${frames.length} frames`\n                : `Will apply to frames ${localFrameRange.startFrame + 1} - ${localFrameRange.endFrame + 1} (${localFrameRange.endFrame - localFrameRange.startFrame + 1} frames)`\n              }\n            </div>\n          </div>\n        </div>\n        \n        <div className=\"flex justify-end gap-2 p-6 pt-0\">\n          <Button variant=\"outline\" onClick={handleCancel}>\n            Cancel\n          </Button>\n          <Button onClick={handleApply}>\n            Apply Wave Warp\n          </Button>\n        </div>\n      </Card>\n    </div>,\n    document.body\n  );\n};","usedDeprecatedRules":[]},{"filePath":"/Users/cameronfoxly/GitHubRepos/Ascii-Motion/src/components/features/timeEffects/WiggleDialog.tsx","messages":[{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useEffect has missing dependencies: 'handleApply' and 'handleCancel'. Either include them or remove the dependency array.","line":107,"column":6,"nodeType":"ArrayExpression","endLine":107,"endColumn":26,"suggestions":[{"desc":"Update the dependencies array to be: [handleApply, handleCancel, isWiggleDialogOpen]","fix":{"range":[3854,3874],"text":"[handleApply, handleCancel, isWiggleDialogOpen]"}}]}],"suppressedMessages":[{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useEffect has missing dependencies: 'isPreviewActive', 'startPreview', and 'updateWiggleSettings'. Either include them or remove the dependency array.","line":75,"column":6,"nodeType":"ArrayExpression","endLine":75,"endColumn":41,"suggestions":[{"desc":"Update the dependencies array to be: [isWiggleDialogOpen, frames.length, updateWiggleSettings, isPreviewActive, startPreview]","fix":{"range":[2739,2774],"text":"[isWiggleDialogOpen, frames.length, updateWiggleSettings, isPreviewActive, startPreview]"}}],"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useState, useRef, useEffect, useCallback } from 'react';\nimport { createPortal } from 'react-dom';\nimport { Button } from '@/components/ui/button';\nimport { Card } from '@/components/ui/card';\nimport { Input } from '@/components/ui/input';\nimport { Label } from '@/components/ui/label';\nimport { Checkbox } from '@/components/ui/checkbox';\nimport { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/components/ui/select';\nimport { Slider } from '@/components/ui/slider';\nimport { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs';\nimport { DraggableDialogBar } from '@/components/common/DraggableDialogBar';\nimport { useTimeEffectsStore } from '@/stores/timeEffectsStore';\nimport { useTimeEffectsHistory } from '@/hooks/useTimeEffectsHistory';\nimport { useAnimationStore } from '@/stores/animationStore';\nimport { \n  DEFAULT_WIGGLE_SETTINGS, \n  WIGGLE_RANGES\n} from '@/constants/timeEffects';\nimport type { WiggleMode, FrameRangeSettings } from '@/types/timeEffects';\nimport { Eye, EyeOff, Waves, Zap } from 'lucide-react';\n\nexport const WiggleDialog: React.FC = () => {\n  const { \n    isWiggleDialogOpen, \n    closeWiggleDialog,\n    wiggleSettings,\n    updateWiggleSettings,\n    updateFrameRange,\n    isPreviewActive,\n    previewEffect,\n    startPreview,\n    stopPreview,\n    updatePreview\n  } = useTimeEffectsStore();\n  \n  const { applyWiggleWithHistory } = useTimeEffectsHistory();\n  const { frames, currentFrameIndex } = useAnimationStore();\n\n  // Dialog state\n  const [positionOffset, setPositionOffset] = useState({ x: 0, y: 0 });\n  const [isDraggingDialog, setIsDraggingDialog] = useState(false);\n  const [hasBeenDragged, setHasBeenDragged] = useState(false);\n  const dragStartOffsetRef = useRef({ x: 0, y: 0 });\n  const dialogRef = useRef<HTMLDivElement>(null);\n  \n  // Local frame range state\n  const [localFrameRange, setLocalFrameRange] = useState<FrameRangeSettings>({\n    applyToAll: true,\n    startFrame: 0,\n    endFrame: 0\n  });\n  \n  // Reset position and settings when dialog opens\n  useEffect(() => {\n    if (isWiggleDialogOpen) {\n      setPositionOffset({ x: 0, y: 0 });\n      setHasBeenDragged(false);\n      // Reset to defaults\n      updateWiggleSettings(DEFAULT_WIGGLE_SETTINGS);\n      setLocalFrameRange({\n        startFrame: 0,\n        endFrame: Math.max(0, frames.length - 1),\n        applyToAll: true\n      });\n      \n      // Auto-start preview (default to on)\n      setTimeout(() => {\n        if (!isPreviewActive) {\n          console.log('[Wiggle] Auto-starting preview');\n          startPreview('wiggle');\n        }\n      }, 100); // Small delay to ensure dialog is fully mounted\n    }\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [isWiggleDialogOpen, frames.length]); // Intentionally omit isPreviewActive to avoid infinite loop\n\n  // Stop preview when dialog closes (only if this dialog's effect is active)\n  useEffect(() => {\n    if (!isWiggleDialogOpen && isPreviewActive && previewEffect === 'wiggle') {\n      stopPreview();\n    }\n  }, [isWiggleDialogOpen, isPreviewActive, previewEffect, stopPreview]);\n\n  // Update preview when current frame changes\n  useEffect(() => {\n    if (isWiggleDialogOpen && isPreviewActive) {\n      updatePreview();\n    }\n  }, [currentFrameIndex, isWiggleDialogOpen, isPreviewActive, updatePreview]);\n\n  // Handle escape key to close\n  useEffect(() => {\n    const handleKeyDown = (event: KeyboardEvent) => {\n      if (!isWiggleDialogOpen) return;\n      \n      if (event.key === 'Escape') {\n        event.preventDefault();\n        handleCancel();\n      } else if (event.key === 'Enter' && !event.shiftKey) {\n        event.preventDefault();\n        handleApply();\n      }\n    };\n\n    document.addEventListener('keydown', handleKeyDown);\n    return () => document.removeEventListener('keydown', handleKeyDown);\n  }, [isWiggleDialogOpen]);\n\n  // Dragging handlers\n  const handleDrag = useCallback((deltaX: number, deltaY: number) => {\n    setPositionOffset({\n      x: dragStartOffsetRef.current.x + deltaX,\n      y: dragStartOffsetRef.current.y + deltaY\n    });\n  }, []);\n  \n  const handleDragStart = useCallback(() => {\n    setIsDraggingDialog(true);\n    setHasBeenDragged(true);\n    dragStartOffsetRef.current = { ...positionOffset };\n  }, [positionOffset]);\n  \n  const handleDragEnd = useCallback(() => {\n    setIsDraggingDialog(false);\n    dragStartOffsetRef.current = { ...positionOffset };\n  }, [positionOffset]);\n\n  // Handle settings changes with preview update\n  const handleSettingChange = (updates: Partial<typeof wiggleSettings>) => {\n    updateWiggleSettings(updates);\n    if (isPreviewActive) {\n      // Preview updates automatically through store\n    }\n  };\n\n  // Handle frame range changes\n  const handleFrameRangeChange = (updates: Partial<FrameRangeSettings>) => {\n    const newRange = { ...localFrameRange, ...updates };\n    setLocalFrameRange(newRange);\n    updateFrameRange(newRange);\n  };\n\n  // Toggle preview\n  const handlePreviewToggle = () => {\n    if (isPreviewActive) {\n      stopPreview();\n    } else {\n      startPreview('wiggle');\n    }\n  };\n\n  // Apply changes\n  const handleApply = async () => {\n    // Update the frame range in store before applying\n    updateFrameRange(localFrameRange);\n    const success = await applyWiggleWithHistory();\n    if (success) {\n      closeWiggleDialog();\n    }\n  };\n\n  // Cancel and close\n  const handleCancel = () => {\n    if (isPreviewActive) {\n      stopPreview();\n    }\n    closeWiggleDialog();\n  };\n\n  // Generate new random seed\n  const generateNewSeed = () => {\n    const newSeed = Math.floor(Math.random() * 10000);\n    handleSettingChange({ noiseSeed: newSeed });\n  };\n\n  // Calculate dialog position (lower-left corner, offset from WaveWarp)\n  const getDialogPosition = () => {\n    const dialogWidth = 520;\n    const dialogHeight = 700;\n    const margin = 8;\n    \n    return {\n      bottom: margin,\n      left: margin + 500, // Offset from WaveWarp dialog\n      width: dialogWidth,\n      maxHeight: dialogHeight\n    };\n  };\n\n  // Check if current mode is wave-based or noise-based\n  const isWaveMode = wiggleSettings.mode === 'horizontal-wave' || wiggleSettings.mode === 'vertical-wave';\n  const isNoiseMode = wiggleSettings.mode === 'noise';\n\n  if (!isWiggleDialogOpen) return null;\n\n  const position = getDialogPosition();\n\n  return createPortal(\n    <div\n      ref={dialogRef}\n      className={`fixed z-[99999] ${\n        !hasBeenDragged ? 'animate-in duration-200 slide-in-from-bottom-4 fade-in-0' : ''\n      }`}\n      style={{\n        bottom: position.bottom - positionOffset.y,\n        left: position.left + positionOffset.x,\n        width: position.width,\n        maxHeight: position.maxHeight,\n        transition: isDraggingDialog ? 'none' : undefined\n      }}\n      onClick={(e) => e.stopPropagation()}\n    >\n      <Card className=\"border border-border/50 shadow-lg\">\n        <DraggableDialogBar \n          title=\"Wiggle Effect\" \n          onDrag={handleDrag}\n          onDragStart={handleDragStart}\n          onDragEnd={handleDragEnd}\n          onClose={handleCancel}\n        />\n        \n        <div className=\"p-6 space-y-6 max-h-[600px] overflow-y-auto\">\n          <div className=\"text-sm text-muted-foreground\">\n            Apply wiggle displacement to all characters together. Choose from wave patterns or noise-based motion.\n          </div>\n          \n          {/* Live Preview Toggle */}\n          <div className=\"flex items-center justify-between p-3 border border-border/50 rounded-lg bg-muted/20\">\n            <div className=\"flex items-center gap-2\">\n              {isPreviewActive ? (\n                <Eye className=\"h-4 w-4 text-primary\" />\n              ) : (\n                <EyeOff className=\"h-4 w-4 text-muted-foreground\" />\n              )}\n              <span className=\"text-sm font-medium\">Live Preview</span>\n            </div>\n            <Button\n              variant={isPreviewActive ? \"default\" : \"outline\"}\n              size=\"sm\"\n              onClick={handlePreviewToggle}\n            >\n              {isPreviewActive ? 'Stop' : 'Start'}\n            </Button>\n          </div>\n\n          {/* Mode Selection */}\n          <div className=\"space-y-4\">\n            <h3 className=\"text-sm font-semibold\">Wiggle Mode</h3>\n            \n            <Select\n              value={wiggleSettings.mode}\n              onValueChange={(value: WiggleMode) => handleSettingChange({ mode: value })}\n            >\n              <SelectTrigger>\n                <SelectValue />\n              </SelectTrigger>\n              <SelectContent>\n                <SelectItem value=\"horizontal-wave\">\n                  <div className=\"flex items-center gap-2\">\n                    <Waves className=\"h-4 w-4\" />\n                    <span>Horizontal Wave</span>\n                  </div>\n                </SelectItem>\n                <SelectItem value=\"vertical-wave\">\n                  <div className=\"flex items-center gap-2\">\n                    <Waves className=\"h-4 w-4 rotate-90\" />\n                    <span>Vertical Wave</span>\n                  </div>\n                </SelectItem>\n                <SelectItem value=\"noise\">\n                  <div className=\"flex items-center gap-2\">\n                    <Zap className=\"h-4 w-4\" />\n                    <span>Perlin Noise</span>\n                  </div>\n                </SelectItem>\n              </SelectContent>\n            </Select>\n\n            <div className=\"text-xs text-muted-foreground p-2 bg-muted/30 rounded\">\n              {isWaveMode && \"Wave modes create smooth sine wave motion in the selected direction.\"}\n              {isNoiseMode && \"Noise mode creates organic, random-like motion using Perlin noise.\"}\n            </div>\n          </div>\n\n          {/* Dynamic Settings based on Mode */}\n          <Tabs value={isWaveMode ? \"wave\" : \"noise\"} className=\"w-full\">\n            <TabsList className=\"grid w-full grid-cols-2\">\n              <TabsTrigger value=\"wave\" disabled={!isWaveMode}>\n                <Waves className=\"h-4 w-4 mr-2\" />\n                Wave Settings\n              </TabsTrigger>\n              <TabsTrigger value=\"noise\" disabled={!isNoiseMode}>\n                <Zap className=\"h-4 w-4 mr-2\" />\n                Noise Settings\n              </TabsTrigger>\n            </TabsList>\n\n            {/* Wave Settings Tab */}\n            <TabsContent value=\"wave\" className=\"space-y-4 mt-4\">\n              <h4 className=\"text-sm font-medium\">Wave Parameters</h4>\n              \n              {/* Wave Frequency */}\n              <div className=\"space-y-3\">\n                <div className=\"flex items-center justify-between\">\n                  <Label>Frequency</Label>\n                  <span className=\"text-xs text-muted-foreground\">{wiggleSettings.waveFrequency.toFixed(1)}</span>\n                </div>\n                <Slider\n                  value={wiggleSettings.waveFrequency}\n                  onValueChange={(value) => handleSettingChange({ waveFrequency: value })}\n                  min={WIGGLE_RANGES.WAVE_FREQUENCY.min}\n                  max={WIGGLE_RANGES.WAVE_FREQUENCY.max}\n                  step={WIGGLE_RANGES.WAVE_FREQUENCY.step}\n                  className=\"w-full\"\n                />\n                <div className=\"text-xs text-muted-foreground\">\n                  Range: {WIGGLE_RANGES.WAVE_FREQUENCY.min} - {WIGGLE_RANGES.WAVE_FREQUENCY.max}\n                </div>\n              </div>\n\n              {/* Wave Amplitude */}\n              <div className=\"space-y-3\">\n                <div className=\"flex items-center justify-between\">\n                  <Label>Amplitude</Label>\n                  <span className=\"text-xs text-muted-foreground\">{wiggleSettings.waveAmplitude}</span>\n                </div>\n                <Slider\n                  value={wiggleSettings.waveAmplitude}\n                  onValueChange={(value) => handleSettingChange({ waveAmplitude: value })}\n                  min={WIGGLE_RANGES.WAVE_AMPLITUDE.min}\n                  max={WIGGLE_RANGES.WAVE_AMPLITUDE.max}\n                  step={WIGGLE_RANGES.WAVE_AMPLITUDE.step}\n                  className=\"w-full\"\n                />\n                <div className=\"text-xs text-muted-foreground\">\n                  Range: {WIGGLE_RANGES.WAVE_AMPLITUDE.min} - {WIGGLE_RANGES.WAVE_AMPLITUDE.max} characters\n                </div>\n              </div>\n\n              {/* Wave Speed */}\n              <div className=\"space-y-3\">\n                <div className=\"flex items-center justify-between\">\n                  <Label>Speed</Label>\n                  <span className=\"text-xs text-muted-foreground\">{wiggleSettings.waveSpeed}ms</span>\n                </div>\n                <Slider\n                  value={wiggleSettings.waveSpeed}\n                  onValueChange={(value) => handleSettingChange({ waveSpeed: value })}\n                  min={WIGGLE_RANGES.WAVE_SPEED.min}\n                  max={WIGGLE_RANGES.WAVE_SPEED.max}\n                  step={WIGGLE_RANGES.WAVE_SPEED.step}\n                  className=\"w-full\"\n                />\n                <div className=\"text-xs text-muted-foreground\">\n                  Range: {WIGGLE_RANGES.WAVE_SPEED.min} - {WIGGLE_RANGES.WAVE_SPEED.max}ms per cycle\n                </div>\n              </div>\n            </TabsContent>\n\n            {/* Noise Settings Tab */}\n            <TabsContent value=\"noise\" className=\"space-y-4 mt-4\">\n              <h4 className=\"text-sm font-medium\">Perlin Noise Parameters</h4>\n              \n              {/* Noise Octaves */}\n              <div className=\"space-y-3\">\n                <div className=\"flex items-center justify-between\">\n                  <Label>Octaves (Detail)</Label>\n                  <span className=\"text-xs text-muted-foreground\">{wiggleSettings.noiseOctaves}</span>\n                </div>\n                <Slider\n                  value={wiggleSettings.noiseOctaves}\n                  onValueChange={(value) => handleSettingChange({ noiseOctaves: Math.round(value) })}\n                  min={WIGGLE_RANGES.NOISE_OCTAVES.min}\n                  max={WIGGLE_RANGES.NOISE_OCTAVES.max}\n                  step={WIGGLE_RANGES.NOISE_OCTAVES.step}\n                  className=\"w-full\"\n                />\n                <div className=\"text-xs text-muted-foreground\">\n                  Range: {WIGGLE_RANGES.NOISE_OCTAVES.min} - {WIGGLE_RANGES.NOISE_OCTAVES.max} layers\n                </div>\n              </div>\n\n              {/* Noise Frequency */}\n              <div className=\"space-y-3\">\n                <div className=\"flex items-center justify-between\">\n                  <Label>Frequency (Scale)</Label>\n                  <span className=\"text-xs text-muted-foreground\">{wiggleSettings.noiseFrequency.toFixed(3)}</span>\n                </div>\n                <Slider\n                  value={wiggleSettings.noiseFrequency}\n                  onValueChange={(value) => handleSettingChange({ noiseFrequency: value })}\n                  min={WIGGLE_RANGES.NOISE_FREQUENCY.min}\n                  max={WIGGLE_RANGES.NOISE_FREQUENCY.max}\n                  step={WIGGLE_RANGES.NOISE_FREQUENCY.step}\n                  className=\"w-full\"\n                />\n                <div className=\"text-xs text-muted-foreground\">\n                  Range: {WIGGLE_RANGES.NOISE_FREQUENCY.min} - {WIGGLE_RANGES.NOISE_FREQUENCY.max}\n                </div>\n              </div>\n\n              {/* Noise Amplitude */}\n              <div className=\"space-y-3\">\n                <div className=\"flex items-center justify-between\">\n                  <Label>Amplitude</Label>\n                  <span className=\"text-xs text-muted-foreground\">{wiggleSettings.noiseAmplitude}</span>\n                </div>\n                <Slider\n                  value={wiggleSettings.noiseAmplitude}\n                  onValueChange={(value) => handleSettingChange({ noiseAmplitude: value })}\n                  min={WIGGLE_RANGES.NOISE_AMPLITUDE.min}\n                  max={WIGGLE_RANGES.NOISE_AMPLITUDE.max}\n                  step={WIGGLE_RANGES.NOISE_AMPLITUDE.step}\n                  className=\"w-full\"\n                />\n                <div className=\"text-xs text-muted-foreground\">\n                  Range: {WIGGLE_RANGES.NOISE_AMPLITUDE.min} - {WIGGLE_RANGES.NOISE_AMPLITUDE.max} characters\n                </div>\n              </div>\n\n              {/* Noise Seed */}\n              <div className=\"space-y-3\">\n                <div className=\"flex items-center justify-between\">\n                  <Label>Random Seed</Label>\n                  <Button variant=\"outline\" size=\"sm\" onClick={generateNewSeed}>\n                    New Seed\n                  </Button>\n                </div>\n                <Input\n                  type=\"number\"\n                  value={wiggleSettings.noiseSeed}\n                  onChange={(e) => handleSettingChange({ noiseSeed: parseInt(e.target.value) || 0 })}\n                  min={WIGGLE_RANGES.NOISE_SEED.min}\n                  max={WIGGLE_RANGES.NOISE_SEED.max}\n                  className=\"w-full\"\n                />\n                <div className=\"text-xs text-muted-foreground\">\n                  Range: {WIGGLE_RANGES.NOISE_SEED.min} - {WIGGLE_RANGES.NOISE_SEED.max}\n                </div>\n              </div>\n            </TabsContent>\n          </Tabs>\n\n          {/* Frame Range Settings */}\n          <div className=\"space-y-4\">\n            <h3 className=\"text-sm font-semibold\">Frame Range</h3>\n            \n            <div className=\"flex items-center space-x-2\">\n              <Checkbox\n                id=\"all-frames\"\n                checked={localFrameRange.applyToAll}\n                onCheckedChange={(checked) => \n                  handleFrameRangeChange({ applyToAll: checked === true })\n                }\n              />\n              <Label htmlFor=\"all-frames\" className=\"text-sm\">\n                Apply to all frames\n              </Label>\n            </div>\n\n            {!localFrameRange.applyToAll && (\n              <div className=\"grid grid-cols-2 gap-4\">\n                <div className=\"space-y-2\">\n                  <Label htmlFor=\"start-frame\">Start Frame</Label>\n                  <Input\n                    id=\"start-frame\"\n                    type=\"number\"\n                    value={localFrameRange.startFrame + 1}\n                    onChange={(e) => handleFrameRangeChange({ \n                      startFrame: Math.max(0, parseInt(e.target.value) - 1 || 0)\n                    })}\n                    min={1}\n                    max={frames.length}\n                    className=\"w-full\"\n                  />\n                </div>\n                <div className=\"space-y-2\">\n                  <Label htmlFor=\"end-frame\">End Frame</Label>\n                  <Input\n                    id=\"end-frame\"\n                    type=\"number\"\n                    value={localFrameRange.endFrame + 1}\n                    onChange={(e) => handleFrameRangeChange({ \n                      endFrame: Math.min(frames.length - 1, parseInt(e.target.value) - 1 || frames.length - 1)\n                    })}\n                    min={1}\n                    max={frames.length}\n                    className=\"w-full\"\n                  />\n                </div>\n              </div>\n            )}\n\n            <div className=\"text-xs text-muted-foreground bg-muted/50 p-3 rounded\">\n              {localFrameRange.applyToAll \n                ? `Will apply to all ${frames.length} frames`\n                : `Will apply to frames ${localFrameRange.startFrame + 1} - ${localFrameRange.endFrame + 1} (${localFrameRange.endFrame - localFrameRange.startFrame + 1} frames)`\n              }\n            </div>\n          </div>\n        </div>\n        \n        <div className=\"flex justify-end gap-2 p-6 pt-0\">\n          <Button variant=\"outline\" onClick={handleCancel}>\n            Cancel\n          </Button>\n          <Button onClick={handleApply}>\n            Apply Wiggle\n          </Button>\n        </div>\n      </Card>\n    </div>,\n    document.body\n  );\n};","usedDeprecatedRules":[]},{"filePath":"/Users/cameronfoxly/GitHubRepos/Ascii-Motion/src/components/icons/GitHubIcon.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/cameronfoxly/GitHubRepos/Ascii-Motion/src/components/icons/GradientIcon.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'strokeWidth' is assigned a value but never used.","line":15,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":15,"endColumn":14}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React from 'react';\nimport type { IconProps } from './types';\nimport { defaultIconProps } from './types';\n\n/**\n * Custom Gradient Fill Icon Component\n * Displays a pixelated gradient pattern representing the gradient fill tool\n * \n * Based on custom SVG design with smooth gradient appearance\n * Matches ASCII Motion's aesthetic for pixel/character-based content\n */\nexport const GradientIcon: React.FC<IconProps> = ({ \n  size = defaultIconProps.size,\n  color = defaultIconProps.color,\n  strokeWidth = defaultIconProps.strokeWidth,\n  className,\n  ...props \n}) => {\n  const sizeValue = typeof size === 'number' ? size : parseInt(size.toString());\n  \n  return (\n    <svg \n      width={sizeValue}\n      height={sizeValue} \n      viewBox=\"0 0 24 24\" \n      fill=\"none\" \n      xmlns=\"http://www.w3.org/2000/svg\"\n      className={className}\n      {...props}\n    >\n      <path d=\"M8.03125 18.2744H6.24609V16.4893H8.03125V18.2744Z\" fill={color}/>\n      <path d=\"M11.5996 18.2744H9.81445V16.4893H11.5996V18.2744Z\" fill={color}/>\n      <path d=\"M8.03125 14.7051H6.24609V12.9199H8.03125V14.7051Z\" fill={color}/>\n      <path d=\"M11.5996 14.7051H9.81445V12.9199H11.5996V14.7051Z\" fill={color}/>\n      <path d=\"M8.03125 11.1357H6.24609V9.35059H8.03125V11.1357Z\" fill={color}/>\n      <path d=\"M11.5996 11.1357H9.81445V9.35059H11.5996V11.1357Z\" fill={color}/>\n      <path d=\"M13.3848 9.35059H11.5996V7.56641L13.3848 7.56543V9.35059Z\" fill={color}/>\n      <path d=\"M8.03125 7.56641H6.24609V5.78125H8.03125V7.56641Z\" fill={color}/>\n      <path d=\"M11.5996 7.56641L9.81445 7.56543V5.78125H11.5996V7.56641Z\" fill={color}/>\n      <path \n        fillRule=\"evenodd\" \n        clipRule=\"evenodd\" \n        d=\"M19 2C20.6569 2 22 3.34315 22 5V19C22 20.6569 20.6569 22 19 22H5C3.34315 22 2 20.6569 2 19V5C2 3.34315 3.34315 2 5 2H19ZM16.9551 20H18.7383V18.2744H16.9551V20ZM13.3848 20H15.1699V18.2744H13.3848V20ZM5 4C4.44772 4 4 4.44772 4 5V19C4 19.5523 4.44772 20 5 20H11.5996V18.2744H13.3848V16.4893H15.1699V14.7051H13.3848V16.4893H11.5996V14.7051H13.3848V12.9199H15.1699V11.1357H13.3848V12.9199H11.5996V11.1357H13.3848V9.35059H15.1699V7.56543H13.3848V5.78125H15.1699V4H13.3848V5.78125H11.5996V4H5ZM16.9551 16.4893H18.7383V14.7051H16.9551V16.4893ZM16.9551 12.9199H18.7383V11.1357H16.9551V12.9199ZM16.9551 9.35059H18.7383V7.56543H16.9551V9.35059ZM16.9551 5.78125H18.7383V4H16.9551V5.78125Z\" \n        fill={color}\n      />\n    </svg>\n  );\n};","usedDeprecatedRules":[]},{"filePath":"/Users/cameronfoxly/GitHubRepos/Ascii-Motion/src/components/icons/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/cameronfoxly/GitHubRepos/Ascii-Motion/src/components/icons/types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/cameronfoxly/GitHubRepos/Ascii-Motion/src/components/tools/AsciiTypeTool.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/cameronfoxly/GitHubRepos/Ascii-Motion/src/components/tools/DrawingTool.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/cameronfoxly/GitHubRepos/Ascii-Motion/src/components/tools/EllipseTool.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/cameronfoxly/GitHubRepos/Ascii-Motion/src/components/tools/EyedropperTool.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/cameronfoxly/GitHubRepos/Ascii-Motion/src/components/tools/FlipHorizontalTool.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/cameronfoxly/GitHubRepos/Ascii-Motion/src/components/tools/FlipVerticalTool.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/cameronfoxly/GitHubRepos/Ascii-Motion/src/components/tools/GradientFillTool.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/cameronfoxly/GitHubRepos/Ascii-Motion/src/components/tools/LassoTool.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/cameronfoxly/GitHubRepos/Ascii-Motion/src/components/tools/MagicWandTool.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/cameronfoxly/GitHubRepos/Ascii-Motion/src/components/tools/PaintBucketTool.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/cameronfoxly/GitHubRepos/Ascii-Motion/src/components/tools/RectangleTool.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/cameronfoxly/GitHubRepos/Ascii-Motion/src/components/tools/SelectionTool.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/cameronfoxly/GitHubRepos/Ascii-Motion/src/components/tools/TextTool.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/cameronfoxly/GitHubRepos/Ascii-Motion/src/components/tools/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/cameronfoxly/GitHubRepos/Ascii-Motion/src/components/ui/alert.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/cameronfoxly/GitHubRepos/Ascii-Motion/src/components/ui/badge.tsx","messages":[{"ruleId":"react-refresh/only-export-components","severity":2,"message":"Fast refresh only works when a file only exports components. Use a new file to share constants or functions between components.","line":36,"column":17,"nodeType":"Identifier","messageId":"namedExport","endLine":36,"endColumn":30}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import * as React from \"react\"\nimport { cva, type VariantProps } from \"class-variance-authority\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst badgeVariants = cva(\n  \"inline-flex items-center rounded-md border px-2.5 py-0.5 text-xs font-semibold transition-colors focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2\",\n  {\n    variants: {\n      variant: {\n        default:\n          \"border-transparent bg-primary text-primary-foreground shadow hover:bg-primary/80\",\n        secondary:\n          \"border-transparent bg-secondary text-secondary-foreground hover:bg-secondary/80\",\n        destructive:\n          \"border-transparent bg-destructive text-destructive-foreground shadow hover:bg-destructive/80\",\n        outline: \"text-foreground\",\n      },\n    },\n    defaultVariants: {\n      variant: \"default\",\n    },\n  }\n)\n\nexport interface BadgeProps\n  extends React.HTMLAttributes<HTMLDivElement>,\n    VariantProps<typeof badgeVariants> {}\n\nfunction Badge({ className, variant, ...props }: BadgeProps) {\n  return (\n    <div className={cn(badgeVariants({ variant }), className)} {...props} />\n  )\n}\n\nexport { Badge, badgeVariants }\n","usedDeprecatedRules":[]},{"filePath":"/Users/cameronfoxly/GitHubRepos/Ascii-Motion/src/components/ui/button.tsx","messages":[{"ruleId":"react-refresh/only-export-components","severity":2,"message":"Fast refresh only works when a file only exports components. Use a new file to share constants or functions between components.","line":57,"column":18,"nodeType":"Identifier","messageId":"namedExport","endLine":57,"endColumn":32}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import * as React from \"react\"\nimport { Slot } from \"@radix-ui/react-slot\"\nimport { cva, type VariantProps } from \"class-variance-authority\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst buttonVariants = cva(\n  \"inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium transition-colors focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0\",\n  {\n    variants: {\n      variant: {\n        default:\n          \"bg-primary text-primary-foreground shadow hover:bg-primary/90\",\n        destructive:\n          \"bg-destructive text-destructive-foreground shadow-sm hover:bg-destructive/90\",\n        outline:\n          \"border border-input bg-background shadow-sm hover:bg-accent hover:text-accent-foreground\",\n        secondary:\n          \"bg-secondary text-secondary-foreground shadow-sm hover:bg-secondary/80\",\n        ghost: \"hover:bg-accent hover:text-accent-foreground\",\n        link: \"text-primary underline-offset-4 hover:underline\",\n      },\n      size: {\n        default: \"h-9 px-4 py-2\",\n        sm: \"h-8 rounded-md px-3 text-xs\",\n        lg: \"h-10 rounded-md px-8\",\n        icon: \"h-9 w-9\",\n      },\n    },\n    defaultVariants: {\n      variant: \"default\",\n      size: \"default\",\n    },\n  }\n)\n\nexport interface ButtonProps\n  extends React.ButtonHTMLAttributes<HTMLButtonElement>,\n    VariantProps<typeof buttonVariants> {\n  asChild?: boolean\n}\n\nconst Button = React.forwardRef<HTMLButtonElement, ButtonProps>(\n  ({ className, variant, size, asChild = false, ...props }, ref) => {\n    const Comp = asChild ? Slot : \"button\"\n    return (\n      <Comp\n        className={cn(buttonVariants({ variant, size, className }))}\n        ref={ref}\n        {...props}\n      />\n    )\n  }\n)\nButton.displayName = \"Button\"\n\nexport { Button, buttonVariants }\n","usedDeprecatedRules":[]},{"filePath":"/Users/cameronfoxly/GitHubRepos/Ascii-Motion/src/components/ui/card.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/cameronfoxly/GitHubRepos/Ascii-Motion/src/components/ui/checkbox.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/cameronfoxly/GitHubRepos/Ascii-Motion/src/components/ui/collapsible.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/cameronfoxly/GitHubRepos/Ascii-Motion/src/components/ui/dialog.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/cameronfoxly/GitHubRepos/Ascii-Motion/src/components/ui/dropdown-menu.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/cameronfoxly/GitHubRepos/Ascii-Motion/src/components/ui/input.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/cameronfoxly/GitHubRepos/Ascii-Motion/src/components/ui/label.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/cameronfoxly/GitHubRepos/Ascii-Motion/src/components/ui/menubar.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/cameronfoxly/GitHubRepos/Ascii-Motion/src/components/ui/popover.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/cameronfoxly/GitHubRepos/Ascii-Motion/src/components/ui/progress.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/cameronfoxly/GitHubRepos/Ascii-Motion/src/components/ui/scroll-area.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/cameronfoxly/GitHubRepos/Ascii-Motion/src/components/ui/select.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/cameronfoxly/GitHubRepos/Ascii-Motion/src/components/ui/separator.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/cameronfoxly/GitHubRepos/Ascii-Motion/src/components/ui/sheet.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/cameronfoxly/GitHubRepos/Ascii-Motion/src/components/ui/slider.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/cameronfoxly/GitHubRepos/Ascii-Motion/src/components/ui/switch.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/cameronfoxly/GitHubRepos/Ascii-Motion/src/components/ui/tabs.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/cameronfoxly/GitHubRepos/Ascii-Motion/src/components/ui/textarea.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/cameronfoxly/GitHubRepos/Ascii-Motion/src/components/ui/toggle.tsx","messages":[{"ruleId":"react-refresh/only-export-components","severity":2,"message":"Fast refresh only works when a file only exports components. Use a new file to share constants or functions between components.","line":43,"column":18,"nodeType":"Identifier","messageId":"namedExport","endLine":43,"endColumn":32}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import * as React from \"react\"\nimport * as TogglePrimitive from \"@radix-ui/react-toggle\"\nimport { cva, type VariantProps } from \"class-variance-authority\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst toggleVariants = cva(\n  \"inline-flex items-center justify-center gap-2 rounded-md text-sm font-medium transition-colors hover:bg-muted hover:text-muted-foreground focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring disabled:pointer-events-none disabled:opacity-50 data-[state=on]:bg-accent data-[state=on]:text-accent-foreground [&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0\",\n  {\n    variants: {\n      variant: {\n        default: \"bg-transparent\",\n        outline:\n          \"border border-input bg-transparent shadow-sm hover:bg-accent hover:text-accent-foreground\",\n      },\n      size: {\n        default: \"h-9 px-2 min-w-9\",\n        sm: \"h-8 px-1.5 min-w-8\",\n        lg: \"h-10 px-2.5 min-w-10\",\n      },\n    },\n    defaultVariants: {\n      variant: \"default\",\n      size: \"default\",\n    },\n  }\n)\n\nconst Toggle = React.forwardRef<\n  React.ElementRef<typeof TogglePrimitive.Root>,\n  React.ComponentPropsWithoutRef<typeof TogglePrimitive.Root> &\n    VariantProps<typeof toggleVariants>\n>(({ className, variant, size, ...props }, ref) => (\n  <TogglePrimitive.Root\n    ref={ref}\n    className={cn(toggleVariants({ variant, size, className }))}\n    {...props}\n  />\n))\n\nToggle.displayName = TogglePrimitive.Root.displayName\n\nexport { Toggle, toggleVariants }\n","usedDeprecatedRules":[]},{"filePath":"/Users/cameronfoxly/GitHubRepos/Ascii-Motion/src/components/ui/tooltip.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/cameronfoxly/GitHubRepos/Ascii-Motion/src/constants/colors.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/cameronfoxly/GitHubRepos/Ascii-Motion/src/constants/defaultCharacterPalettes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/cameronfoxly/GitHubRepos/Ascii-Motion/src/constants/defaultPalettes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/cameronfoxly/GitHubRepos/Ascii-Motion/src/constants/effectsDefaults.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/cameronfoxly/GitHubRepos/Ascii-Motion/src/constants/figletFonts.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/cameronfoxly/GitHubRepos/Ascii-Motion/src/constants/hotkeys.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/cameronfoxly/GitHubRepos/Ascii-Motion/src/constants/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/cameronfoxly/GitHubRepos/Ascii-Motion/src/constants/onionSkin.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/cameronfoxly/GitHubRepos/Ascii-Motion/src/constants/timeEffects.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/cameronfoxly/GitHubRepos/Ascii-Motion/src/constants/version.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/cameronfoxly/GitHubRepos/Ascii-Motion/src/contexts/CanvasContext.tsx","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":111,"column":34,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":111,"endColumn":37,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3914,3917],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3914,3917],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"react-refresh/only-export-components","severity":2,"message":"Fast refresh only works when a file only exports components. Use a new file to share constants or functions between components.","line":275,"column":14,"nodeType":"Identifier","messageId":"namedExport","endLine":275,"endColumn":30},{"ruleId":"react-refresh/only-export-components","severity":2,"message":"Fast refresh only works when a file only exports components. Use a new file to share constants or functions between components.","line":284,"column":14,"nodeType":"Identifier","messageId":"namedExport","endLine":284,"endColumn":33}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { createContext, useContext, useState, useRef, useMemo, useCallback } from 'react';\nimport type { ReactNode } from 'react';\nimport type { Cell } from '../types';\nimport { usePasteMode } from '../hooks/usePasteMode';\nimport { useFrameSynchronization } from '../hooks/useFrameSynchronization';\nimport type { PasteModeState } from '../hooks/usePasteMode';\nimport { calculateFontMetrics, calculateCellDimensions, DEFAULT_SPACING } from '../utils/fontMetrics';\nimport type { FontMetrics } from '../utils/fontMetrics';\n\n// Canvas-specific state that doesn't belong in global stores\ninterface SelectionPreviewState {\n  active: boolean;\n  modifier: 'replace' | 'add' | 'subtract';\n  tool: 'select' | 'lasso' | 'magicwand' | null;\n  baseCells: string[];\n  gestureCells: string[];\n}\n\ninterface CanvasState {\n  // Canvas display settings\n  cellSize: number; // Base font size for character height\n  zoom: number; // 0.2 to 4.0 (20% to 400% in 20% increments)\n  panOffset: { x: number; y: number };\n  \n  // Typography settings\n  characterSpacing: number; // multiplier for character width spacing\n  lineSpacing: number;      // multiplier for line height spacing\n  fontSize: number;         // base font size in pixels\n  \n  // Computed font metrics\n  fontMetrics: FontMetrics;\n  cellWidth: number;   // actual cell width including spacing\n  cellHeight: number;  // actual cell height including spacing\n  \n  // Interaction state\n  isDrawing: boolean;\n  mouseButtonDown: boolean;\n  shiftKeyDown: boolean;\n  altKeyDown: boolean;  // For temporary eyedropper activation\n  \n  // Selection state\n  selectionMode: 'none' | 'dragging' | 'moving';\n  pendingSelectionStart: { x: number; y: number } | null;\n  justCommittedMove: boolean;\n  \n  // Hover state\n  hoveredCell: { x: number; y: number } | null;\n  \n  // Hover preview state (for tool-specific previews like brush outline)\n  hoverPreview: {\n    active: boolean;\n    mode: 'none' | 'brush' | 'eraser-brush' | 'rectangle' | 'ellipse' | 'line';\n    cells: Array<{ x: number; y: number }>;\n  };\n  \n  // Move/drag state\n  moveState: {\n    originalData: Map<string, Cell>;\n    originalPositions: Set<string>;\n    startPos: { x: number; y: number };\n    baseOffset: { x: number; y: number };\n    currentOffset: { x: number; y: number };\n  } | null;\n  \n  // Paste mode state\n  pasteMode: PasteModeState;\n\n  // Selection preview (for additive/subtractive gestures)\n  selectionPreview: SelectionPreviewState;\n}\n\ninterface CanvasActions {\n  // Canvas settings\n  setCellSize: (size: number) => void;\n  setZoom: (zoom: number) => void;\n  setPanOffset: (offset: { x: number; y: number }) => void;\n  \n    // Typography actions\n  setCharacterSpacing: (spacing: number) => void;\n  setLineSpacing: (spacing: number) => void;\n  setFontSize: (size: number) => void;\n  \n  // Interaction actions\n  setIsDrawing: (drawing: boolean) => void;\n  setMouseButtonDown: (down: boolean) => void;\n  setShiftKeyDown: (down: boolean) => void;\n  setAltKeyDown: (down: boolean) => void;\n  \n  // Selection actions\n  setSelectionMode: (mode: CanvasState['selectionMode']) => void;\n  setPendingSelectionStart: (start: { x: number; y: number } | null) => void;\n  setJustCommittedMove: (committed: boolean) => void;\n  \n  // Hover actions\n  setHoveredCell: (cell: { x: number; y: number } | null) => void;\n  setHoverPreview: (preview: {\n    active: boolean;\n    mode: 'none' | 'brush' | 'eraser-brush' | 'rectangle' | 'ellipse' | 'line';\n    cells: Array<{ x: number; y: number }>;\n  }) => void;\n  \n  // Move/drag actions\n  setMoveState: (state: CanvasState['moveState']) => void;\n  \n  // Paste mode actions\n  startPasteMode: (position: { x: number; y: number }) => boolean;\n  updatePastePosition: (position: { x: number; y: number }) => void;\n  startPasteDrag: (clickPosition: { x: number; y: number }) => void;\n  stopPasteDrag: () => void;\n  cancelPasteMode: () => void;\n  commitPaste: () => Map<string, any> | null;\n  \n  // Canvas ref\n  canvasRef: React.RefObject<HTMLCanvasElement | null>;\n\n  // Selection preview actions\n  setSelectionPreview: (preview: SelectionPreviewState) => void;\n}\n\ninterface CanvasContextValue extends CanvasState, CanvasActions {}\n\nconst CanvasContext = createContext<CanvasContextValue | null>(null);\n\ninterface CanvasProviderProps {\n  children: ReactNode;\n  initialCellSize?: number;\n}\n\nexport const CanvasProvider: React.FC<CanvasProviderProps> = ({ \n  children, \n  initialCellSize = 18 \n}) => {\n  const canvasRef = useRef<HTMLCanvasElement>(null);\n  \n  // Canvas display settings\n  const [cellSize, setCellSize] = useState(initialCellSize);\n  const [zoom, setZoom] = useState(1.0);\n  const [panOffset, setPanOffset] = useState({ x: 0, y: 0 });\n  \n  // Typography settings\n  const [characterSpacing, setCharacterSpacing] = useState(DEFAULT_SPACING.characterSpacing);\n  const [lineSpacing, setLineSpacing] = useState(DEFAULT_SPACING.lineSpacing);\n  \n  // Computed font metrics (recalculated when cellSize changes)\n  const fontMetrics = useMemo(() => {\n    return calculateFontMetrics(cellSize);\n  }, [cellSize]);\n  \n  // Computed cell dimensions (recalculated when metrics or spacing changes)\n  const { cellWidth, cellHeight } = useMemo(() => {\n    return calculateCellDimensions(fontMetrics, { characterSpacing, lineSpacing });\n  }, [fontMetrics, characterSpacing, lineSpacing]);\n  \n  // Interaction state\n  const [isDrawing, setIsDrawing] = useState(false);\n  const [mouseButtonDown, setMouseButtonDown] = useState(false);\n  const [shiftKeyDown, setShiftKeyDown] = useState(false);\n  const [altKeyDown, setAltKeyDown] = useState(false);\n  \n  // Selection state\n  const [selectionMode, setSelectionMode] = useState<CanvasState['selectionMode']>('none');\n  const [pendingSelectionStart, setPendingSelectionStart] = useState<{ x: number; y: number } | null>(null);\n  const [justCommittedMove, setJustCommittedMove] = useState(false);\n  \n  // Hover state\n  const [hoveredCell, setHoveredCell] = useState<{ x: number; y: number } | null>(null);\n  \n  // Hover preview state (for tool-specific previews like brush outline)\n  const [hoverPreview, setHoverPreview] = useState<{\n    active: boolean;\n    mode: 'none' | 'brush' | 'eraser-brush' | 'rectangle' | 'ellipse' | 'line';\n    cells: Array<{ x: number; y: number }>;\n  }>({\n    active: false,\n    mode: 'none',\n    cells: []\n  });\n  \n  // Move/drag state\n  const [moveState, setMoveState] = useState<CanvasState['moveState']>(null);\n  const [selectionPreviewState, setSelectionPreviewState] = useState<SelectionPreviewState>({\n    active: false,\n    modifier: 'replace',\n    tool: null,\n    baseCells: [],\n    gestureCells: []\n  });\n\n  const setSelectionPreview = useCallback((preview: SelectionPreviewState) => {\n    setSelectionPreviewState(preview);\n  }, []);\n  \n  // Paste mode integration\n  const {\n    pasteMode,\n    startPasteMode,\n    updatePastePosition,\n    startPasteDrag,\n    stopPasteDrag,\n    cancelPasteMode,\n    commitPaste\n  } = usePasteMode();\n\n  // Frame synchronization for animation\n  useFrameSynchronization(moveState, setMoveState);\n\n  const contextValue: CanvasContextValue = {\n    // Display state\n    cellSize,\n    zoom,\n    panOffset,\n    \n    // Typography state\n    characterSpacing,\n    lineSpacing,\n    fontSize: cellSize,\n    fontMetrics,\n    cellWidth,\n    cellHeight,\n    \n    // Interaction state\n    isDrawing,\n    mouseButtonDown,\n    shiftKeyDown,\n    altKeyDown,\n    selectionMode,\n    pendingSelectionStart,\n    justCommittedMove,\n    hoveredCell,\n    hoverPreview,\n    moveState,\n    pasteMode,\n  selectionPreview: selectionPreviewState,\n    \n    // Display actions\n    setCellSize,\n    setZoom,\n    setPanOffset,\n    \n    // Typography actions\n    setCharacterSpacing,\n    setLineSpacing,\n    setFontSize: setCellSize,\n    \n    // Interaction actions\n    setIsDrawing,\n    setMouseButtonDown,\n    setShiftKeyDown,\n    setAltKeyDown,\n    setSelectionMode,\n    setPendingSelectionStart,\n    setJustCommittedMove,\n    setHoveredCell,\n    setHoverPreview,\n    setMoveState,\n    startPasteMode,\n    updatePastePosition,\n    startPasteDrag,\n    stopPasteDrag,\n    cancelPasteMode,\n    commitPaste,\n  setSelectionPreview,\n    \n    // Ref\n    canvasRef,\n  };\n\n  return (\n    <CanvasContext.Provider value={contextValue}>\n      {children}\n    </CanvasContext.Provider>\n  );\n};\n\nexport const useCanvasContext = (): CanvasContextValue => {\n  const context = useContext(CanvasContext);\n  if (!context) {\n    throw new Error('useCanvasContext must be used within a CanvasProvider');\n  }\n  return context;\n};\n\n// Helper hook for canvas dimensions calculations\nexport const useCanvasDimensions = () => {\n  const { cellWidth, cellHeight, zoom, panOffset } = useCanvasContext();\n  \n  return {\n    cellWidth,\n    cellHeight,\n    getCanvasSize: (gridWidth: number, gridHeight: number) => ({\n      width: gridWidth * cellWidth,\n      height: gridHeight * cellHeight,\n    }),\n    getGridCoordinates: (\n      mouseX: number, \n      mouseY: number, \n      canvasRect: DOMRect,\n      gridWidth: number,\n      gridHeight: number\n    ) => {\n      // Get relative position within canvas (in CSS pixels)\n      const relativeX = mouseX - canvasRect.left;\n      const relativeY = mouseY - canvasRect.top;\n      \n      // Note: No need to account for device pixel ratio here because:\n      // - mouseX/mouseY are in CSS pixels \n      // - canvasRect is in CSS pixels\n      // - Our coordinate calculations should remain in CSS pixel space\n      // - The high-DPI scaling happens only in the rendering context\n      \n      // Account for pan offset - subtract pan offset to get actual grid position\n      const adjustedX = relativeX - panOffset.x;\n      const adjustedY = relativeY - panOffset.y;\n      \n      // Account for zoom - divide by zoomed cell size\n      const effectiveCellWidth = cellWidth * zoom;\n      const effectiveCellHeight = cellHeight * zoom;\n      const x = Math.floor(adjustedX / effectiveCellWidth);\n      const y = Math.floor(adjustedY / effectiveCellHeight);\n      \n      return {\n        x: Math.max(0, Math.min(x, gridWidth - 1)),\n        y: Math.max(0, Math.min(y, gridHeight - 1)),\n      };\n    },\n    getGridCoordinatesWithCenter: (\n      mouseX: number, \n      mouseY: number, \n      canvasRect: DOMRect,\n      gridWidth: number,\n      gridHeight: number\n    ) => {\n      // Get relative position within canvas (in CSS pixels)\n      const relativeX = mouseX - canvasRect.left;\n      const relativeY = mouseY - canvasRect.top;\n      \n      // Account for pan offset - subtract pan offset to get actual grid position\n      const adjustedX = relativeX - panOffset.x;\n      const adjustedY = relativeY - panOffset.y;\n      \n      // Account for zoom - divide by zoomed cell size\n      const effectiveCellWidth = cellWidth * zoom;\n      const effectiveCellHeight = cellHeight * zoom;\n      const x = Math.floor(adjustedX / effectiveCellWidth);\n      const y = Math.floor(adjustedY / effectiveCellHeight);\n      \n      // Return cell center coordinates (add 0.5 to snap to center)\n      return {\n        x: Math.max(0.5, Math.min(x + 0.5, gridWidth - 0.5)),\n        y: Math.max(0.5, Math.min(y + 0.5, gridHeight - 0.5)),\n      };\n    },\n  };\n};\n","usedDeprecatedRules":[]},{"filePath":"/Users/cameronfoxly/GitHubRepos/Ascii-Motion/src/contexts/ModalContext.tsx","messages":[{"ruleId":"react-refresh/only-export-components","severity":2,"message":"Fast refresh only works when a file only exports components. Use a new file to share constants or functions between components.","line":12,"column":14,"nodeType":"Identifier","messageId":"namedExport","endLine":12,"endColumn":29}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { createContext, useContext, useState, useCallback } from 'react';\nimport type { ReactNode } from 'react';\n\ninterface ModalContextType {\n  isAnyModalOpen: boolean;\n  openModal: (modalId: string) => void;\n  closeModal: (modalId: string) => void;\n}\n\nconst ModalContext = createContext<ModalContextType | undefined>(undefined);\n\nexport const useModalContext = () => {\n  const context = useContext(ModalContext);\n  if (!context) {\n    throw new Error('useModalContext must be used within a ModalProvider');\n  }\n  return context;\n};\n\ninterface ModalProviderProps {\n  children: ReactNode;\n}\n\nexport const ModalProvider: React.FC<ModalProviderProps> = ({ children }) => {\n  const [openModals, setOpenModals] = useState<Set<string>>(new Set());\n\n  const openModal = useCallback((modalId: string) => {\n    setOpenModals(prev => new Set(prev).add(modalId));\n  }, []);\n\n  const closeModal = useCallback((modalId: string) => {\n    setOpenModals(prev => {\n      const newSet = new Set(prev);\n      newSet.delete(modalId);\n      return newSet;\n    });\n  }, []);\n\n  const isAnyModalOpen = openModals.size > 0;\n\n  return (\n    <ModalContext.Provider value={{ isAnyModalOpen, openModal, closeModal }}>\n      {children}\n    </ModalContext.Provider>\n  );\n};\n","usedDeprecatedRules":[]},{"filePath":"/Users/cameronfoxly/GitHubRepos/Ascii-Motion/src/contexts/ThemeContext.tsx","messages":[{"ruleId":"react-refresh/only-export-components","severity":2,"message":"Fast refresh only works when a file only exports components. Use a new file to share constants or functions between components.","line":50,"column":17,"nodeType":"Identifier","messageId":"namedExport","endLine":50,"endColumn":25}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { createContext, useContext, useEffect, useState } from 'react'\n\ntype Theme = 'dark' | 'light'\n\ninterface ThemeContextType {\n  theme: Theme\n  setTheme: (theme: Theme) => void\n  toggleTheme: () => void\n}\n\nconst ThemeContext = createContext<ThemeContextType | undefined>(undefined)\n\nexport function ThemeProvider({ children }: { children: React.ReactNode }) {\n  const [theme, setTheme] = useState<Theme>(() => {\n    // Check localStorage first, then default to dark\n    const stored = localStorage.getItem('ascii-motion-theme') as Theme\n    return stored || 'dark'\n  })\n\n  useEffect(() => {\n    const root = window.document.documentElement\n    \n    // Remove previous theme classes\n    root.classList.remove('light', 'dark')\n    \n    // Add current theme class\n    root.classList.add(theme)\n    \n    // Store in localStorage\n    localStorage.setItem('ascii-motion-theme', theme)\n  }, [theme])\n\n  const toggleTheme = () => {\n    setTheme(theme === 'dark' ? 'light' : 'dark')\n  }\n\n  const value = {\n    theme,\n    setTheme,\n    toggleTheme\n  }\n\n  return (\n    <ThemeContext.Provider value={value}>\n      {children}\n    </ThemeContext.Provider>\n  )\n}\n\nexport function useTheme() {\n  const context = useContext(ThemeContext)\n  if (context === undefined) {\n    throw new Error('useTheme must be used within a ThemeProvider')\n  }\n  return context\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/cameronfoxly/GitHubRepos/Ascii-Motion/src/hooks/useAnimationHistory.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":53,"column":57,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":53,"endColumn":60,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1774,1777],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1774,1777],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":284,"column":71,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":284,"endColumn":74,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8890,8893],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8890,8893],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useCallback has a missing dependency: 'selectedFrameIndices'. Either include it or remove the dependency array.","line":353,"column":6,"nodeType":"ArrayExpression","endLine":353,"endColumn":48,"suggestions":[{"desc":"Update the dependencies array to be: [frames, currentFrameIndex, selectedFrameIndices, pushToHistory]","fix":{"range":[11315,11357],"text":"[frames, currentFrameIndex, selectedFrameIndices, pushToHistory]"}}]},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useCallback has an unnecessary dependency: 'selectedFrameIndices'. Either exclude it or remove the dependency array.","line":378,"column":6,"nodeType":"ArrayExpression","endLine":378,"endColumn":70,"suggestions":[{"desc":"Update the dependencies array to be: [frames, currentFrameIndex, pushToHistory]","fix":{"range":[12056,12120],"text":"[frames, currentFrameIndex, pushToHistory]"}}]}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { useCallback } from 'react';\nimport { useAnimationStore } from '../stores/animationStore';\nimport { useToolStore } from '../stores/toolStore';\nimport type { \n  Cell,\n  AddFrameHistoryAction, \n  DuplicateFrameHistoryAction, \n  DeleteFrameHistoryAction, \n  ReorderFramesHistoryAction, \n  UpdateDurationHistoryAction,\n  UpdateNameHistoryAction\n} from '../types';\nimport { cloneFrame, cloneFrames } from '../utils/frameUtils';\n\n/**\n * Custom hook that provides animation actions with integrated undo/redo history\n * This ensures all timeline operations are recorded in the history stack\n */\nexport const useAnimationHistory = () => {\n  const { \n    frames, \n    currentFrameIndex, \n    selectedFrameIndices,\n    addFrame: addFrameStore, \n    removeFrame: removeFrameStore, \n    duplicateFrame: duplicateFrameStore, \n    duplicateFrameRange: duplicateFrameRangeStore,\n    updateFrameDuration: updateFrameDurationStore, \n    updateFrameName: updateFrameNameStore, \n    reorderFrames: reorderFramesStore \n  } = useAnimationStore();\n  \n  const { pushToHistory } = useToolStore();\n\n  /**\n   * Add a new blank frame with history recording\n   */\n  const addFrame = useCallback((atIndex?: number) => {\n    const insertIndex = atIndex !== undefined ? atIndex : frames.length;\n    const previousCurrentFrame = currentFrameIndex;\n    \n    // Create blank canvas data for new frame\n    const blankCanvasData = new Map<string, Cell>();\n    \n    // Create history action before making the change\n    const historyAction: AddFrameHistoryAction = {\n      type: 'add_frame',\n      timestamp: Date.now(),\n      description: `Add frame at position ${insertIndex + 1}`,\n      data: {\n        frameIndex: insertIndex,\n        frame: {\n          id: `frame-${Date.now()}-${Math.random()}` as any,\n          name: `Frame ${insertIndex + 1}`,\n          duration: 1000, // Default duration\n          data: new Map(blankCanvasData),\n          thumbnail: undefined\n        },\n        canvasData: new Map(blankCanvasData),\n        previousCurrentFrame\n      }\n    };\n    \n    // Execute the action\n    addFrameStore(insertIndex, blankCanvasData);\n    \n    // Record in history\n    pushToHistory(historyAction);\n  }, [frames.length, currentFrameIndex, addFrameStore, pushToHistory]);\n\n  /**\n   * Duplicate a frame with history recording\n   */\n  const duplicateFrame = useCallback((index: number) => {\n    const frameToDuplicate = frames[index];\n    if (!frameToDuplicate) return;\n    \n    const previousCurrentFrame = currentFrameIndex;\n    \n    // Create history action\n    const historyAction: DuplicateFrameHistoryAction = {\n      type: 'duplicate_frame',\n      timestamp: Date.now(),\n      description: `Duplicate frame ${index + 1}`,\n      data: {\n        originalIndex: index,\n        newIndex: index + 1,\n        frame: cloneFrame(frameToDuplicate),\n        previousCurrentFrame\n      }\n    };\n    \n    // Execute the action\n    duplicateFrameStore(index);\n    \n    // Record in history\n    pushToHistory(historyAction);\n  }, [frames, currentFrameIndex, duplicateFrameStore, pushToHistory]);\n\n  const duplicateFrameRange = useCallback((frameIndices: number[]) => {\n    if (frameIndices.length === 0) return;\n\n    const uniqueIndices = Array.from(new Set(frameIndices)).sort((a, b) => a - b);\n\n    if (uniqueIndices.length === 1) {\n      duplicateFrame(uniqueIndices[0]);\n      return;\n    }\n\n    if (uniqueIndices.some(idx => idx < 0 || idx >= frames.length)) {\n      return;\n    }\n\n    const previousFramesSnapshot = cloneFrames(frames);\n    const previousSelection = Array.from(selectedFrameIndices).sort((a, b) => a - b);\n    const previousCurrentFrame = currentFrameIndex;\n\n    duplicateFrameRangeStore(uniqueIndices);\n\n    const {\n      frames: framesAfter,\n      selectedFrameIndices: selectionAfter,\n      currentFrameIndex: currentAfter\n    } = useAnimationStore.getState();\n\n    const newFramesSnapshot = cloneFrames(framesAfter);\n    const newSelection = Array.from(selectionAfter).sort((a, b) => a - b);\n    const previousFrameIds = new Set(previousFramesSnapshot.map(frame => frame.id));\n    const insertedFrameIds = framesAfter\n      .filter(frame => !previousFrameIds.has(frame.id))\n      .map(frame => frame.id);\n\n    const historyAction: import('../types').DuplicateFrameRangeHistoryAction = {\n      type: 'duplicate_frame_range',\n      timestamp: Date.now(),\n      description: `Duplicate ${uniqueIndices.length} frame${uniqueIndices.length > 1 ? 's' : ''}`,\n      data: {\n        originalFrameIndices: uniqueIndices,\n        insertedFrameIds,\n        previousFrames: previousFramesSnapshot,\n        newFrames: newFramesSnapshot,\n        previousSelection,\n        newSelection,\n        previousCurrentFrame,\n        newCurrentFrame: currentAfter\n      }\n    };\n\n    pushToHistory(historyAction);\n  }, [frames, currentFrameIndex, duplicateFrameRangeStore, pushToHistory, selectedFrameIndices, duplicateFrame]);\n\n  /**\n   * Remove a frame with history recording\n   */\n  const removeFrame = useCallback((index: number) => {\n    const frameToDelete = frames[index];\n    if (!frameToDelete || frames.length <= 1) return;\n    \n    const previousCurrentFrame = currentFrameIndex;\n    let newCurrentFrame = currentFrameIndex;\n    \n    if (index <= currentFrameIndex && currentFrameIndex > 0) {\n      newCurrentFrame = currentFrameIndex - 1;\n    } else if (newCurrentFrame >= frames.length - 1) {\n      newCurrentFrame = frames.length - 2;\n    }\n    \n    // Create history action\n    const historyAction: DeleteFrameHistoryAction = {\n      type: 'delete_frame',\n      timestamp: Date.now(),\n      description: `Delete frame ${index + 1}`,\n      data: {\n        frameIndex: index,\n        frame: cloneFrame(frameToDelete),\n        previousCurrentFrame,\n        newCurrentFrame\n      }\n    };\n    \n    // Execute the action\n    removeFrameStore(index);\n    \n    // Record in history\n    pushToHistory(historyAction);\n  }, [frames, currentFrameIndex, removeFrameStore, pushToHistory]);\n\n  /**\n   * Reorder frames with history recording\n   */\n  const reorderFrames = useCallback((fromIndex: number, toIndex: number) => {\n    if (fromIndex < 0 || fromIndex >= frames.length ||\n        toIndex < 0 || toIndex > frames.length ||\n        fromIndex === toIndex) {\n      return;\n    }\n    \n    const previousCurrentFrame = currentFrameIndex;\n    let newCurrentFrame = currentFrameIndex;\n    \n    if (currentFrameIndex === fromIndex) {\n      newCurrentFrame = toIndex;\n    } else if (fromIndex < currentFrameIndex && toIndex >= currentFrameIndex) {\n      newCurrentFrame = currentFrameIndex - 1;\n    } else if (fromIndex > currentFrameIndex && toIndex <= currentFrameIndex) {\n      newCurrentFrame = currentFrameIndex + 1;\n    }\n    \n    // Create history action\n    const historyAction: ReorderFramesHistoryAction = {\n      type: 'reorder_frames',\n      timestamp: Date.now(),\n      description: `Move frame ${fromIndex + 1} to position ${toIndex + 1}`,\n      data: {\n        fromIndex,\n        toIndex,\n        previousCurrentFrame,\n        newCurrentFrame\n      }\n    };\n    \n    // Execute the action\n    reorderFramesStore(fromIndex, toIndex);\n    \n    // Record in history\n    pushToHistory(historyAction);\n  }, [frames.length, currentFrameIndex, reorderFramesStore, pushToHistory]);\n\n  /**\n   * Update frame duration with history recording\n   */\n  const updateFrameDuration = useCallback((index: number, duration: number) => {\n    const frame = frames[index];\n    if (!frame || frame.duration === duration) return;\n    \n    // Create history action\n    const historyAction: UpdateDurationHistoryAction = {\n      type: 'update_duration',\n      timestamp: Date.now(),\n      description: `Change frame ${index + 1} duration to ${duration}ms`,\n      data: {\n        frameIndex: index,\n        oldDuration: frame.duration,\n        newDuration: duration\n      }\n    };\n    \n    // Execute the action\n    updateFrameDurationStore(index, duration);\n    \n    // Record in history\n    pushToHistory(historyAction);\n  }, [frames, updateFrameDurationStore, pushToHistory]);\n\n  /**\n   * Update frame name with history recording\n   */\n  const updateFrameName = useCallback((index: number, name: string) => {\n    const frame = frames[index];\n    if (!frame || frame.name === name) return;\n    \n    // Create history action\n    const historyAction: UpdateNameHistoryAction = {\n      type: 'update_name',\n      timestamp: Date.now(),\n      description: `Rename frame ${index + 1} to \"${name}\"`,\n      data: {\n        frameIndex: index,\n        oldName: frame.name,\n        newName: name\n      }\n    };\n    \n    // Execute the action\n    updateFrameNameStore(index, name);\n    \n    // Record in history\n    pushToHistory(historyAction);\n  }, [frames, updateFrameNameStore, pushToHistory]);\n\n  /**\n   * Add multiple frames with history recording\n   */\n  const addMultipleFrames = useCallback((count: number, sourceFrame?: any) => {\n    if (count <= 0) return;\n    \n    // For now, add frames one by one using the existing single-frame method\n    // This ensures each frame is properly tracked in history\n    for (let i = 0; i < count; i++) {\n      if (sourceFrame) {\n        // Use duplicate frame functionality\n        const currentLength = frames.length + i;\n        duplicateFrame(Math.min(currentFrameIndex, currentLength - 1));\n      } else {\n        // Add blank frame\n        addFrame();\n      }\n    }\n  }, [frames.length, currentFrameIndex, addFrame, duplicateFrame]);\n\n  /**\n   * Delete multiple frames at once with history recording\n   */\n  const deleteFrameRange = useCallback((frameIndices: number[]) => {\n    if (frameIndices.length === 0) return;\n    \n    // Sort indices to get correct frame data before deletion\n    const sortedIndices = [...frameIndices].sort((a, b) => a - b);\n    \n    // Collect frames to be deleted\n    const framesToDelete = sortedIndices\n      .map(idx => frames[idx])\n      .filter((frame): frame is typeof frames[number] => Boolean(frame));\n    \n    if (framesToDelete.length === 0 || framesToDelete.length >= frames.length) {\n      // Can't delete all frames\n      return;\n    }\n    \n    const previousCurrentFrame = currentFrameIndex;\n    \n    // Calculate new current frame after deletion\n    const removedBeforeCurrent = sortedIndices.filter(idx => idx < currentFrameIndex).length;\n    const newCurrentFrame = Math.max(0, Math.min(\n      currentFrameIndex - removedBeforeCurrent,\n      frames.length - framesToDelete.length - 1\n    ));\n    \n    // Create history action\n    const previousFramesSnapshot = cloneFrames(frames);\n\n    const selectionBeforeDelete = Array.from(selectedFrameIndices).sort((a, b) => a - b);\n\n    const historyAction: import('../types').DeleteFrameRangeHistoryAction = {\n      type: 'delete_frame_range',\n      timestamp: Date.now(),\n      description: `Delete ${framesToDelete.length} frame${framesToDelete.length > 1 ? 's' : ''}`,\n      data: {\n        frameIndices: sortedIndices,\n  frames: framesToDelete.map((frame) => cloneFrame(frame)),\n        previousCurrentFrame,\n        newCurrentFrame,\n        previousFrames: previousFramesSnapshot,\n        previousSelection: selectionBeforeDelete\n      }\n    };\n    \n    // Execute the action\n    useAnimationStore.getState().removeFrameRange(sortedIndices);\n    \n    // Record in history\n    pushToHistory(historyAction);\n  }, [frames, currentFrameIndex, pushToHistory]);\n\n  /**\n   * Delete all frames and reset to single blank frame with history recording\n   */\n  const deleteAllFramesWithReset = useCallback(() => {\n    const previousCurrentFrame = currentFrameIndex;\n    const framesToSave = cloneFrames(frames);\n    \n    // Create history action\n    const historyAction: import('../types').DeleteAllFramesHistoryAction = {\n      type: 'delete_all_frames',\n      timestamp: Date.now(),\n      description: 'Delete all frames',\n      data: {\n        frames: framesToSave,\n        previousCurrentFrame\n      }\n    };\n    \n    // Execute the action\n    useAnimationStore.getState().clearAllFrames();\n    \n    // Record in history\n    pushToHistory(historyAction);\n  }, [frames, currentFrameIndex, pushToHistory, selectedFrameIndices]);\n\n  /**\n   * Reorder multiple frames as a contiguous group with history recording\n   */\n  const reorderFrameRange = useCallback((frameIndices: number[], targetIndex: number) => {\n    if (frameIndices.length === 0) return;\n    \n    const sortedIndices = [...frameIndices].sort((a, b) => a - b);\n    \n    // Validate indices\n    if (sortedIndices.some(idx => idx < 0 || idx >= frames.length)) {\n      return;\n    }\n    \n    const previousCurrentFrame = currentFrameIndex;\n    \n    // Calculate new current frame after reordering\n    let newCurrentFrame = currentFrameIndex;\n    \n    if (sortedIndices.includes(currentFrameIndex)) {\n      // Current frame is being moved\n      const framesBefore = sortedIndices.filter(idx => idx < targetIndex).length;\n      const adjustedTarget = Math.max(0, targetIndex - framesBefore);\n      const positionInSelection = sortedIndices.indexOf(currentFrameIndex);\n      newCurrentFrame = adjustedTarget + positionInSelection;\n    } else {\n      // Adjust current index based on movement\n      const movedFromBefore = sortedIndices.filter(idx => idx < currentFrameIndex).length;\n      const movedToBefore = targetIndex <= currentFrameIndex ? frameIndices.length : 0;\n      newCurrentFrame = currentFrameIndex - movedFromBefore + movedToBefore;\n    }\n    \n    newCurrentFrame = Math.max(0, Math.min(newCurrentFrame, frames.length - 1));\n    \n    // Create history action\n    const movedFrameIds = sortedIndices\n      .map(idx => frames[idx])\n      .filter((frame): frame is typeof frames[number] => Boolean(frame))\n      .map(frame => frame.id);\n\n    const previousSelectionFrameIds = Array.from(selectedFrameIndices)\n      .map(idx => frames[idx])\n      .filter((frame): frame is typeof frames[number] => Boolean(frame))\n      .map(frame => frame.id);\n\n    const historyAction: import('../types').ReorderFrameRangeHistoryAction = {\n      type: 'reorder_frame_range',\n      timestamp: Date.now(),\n      description: `Move ${frameIndices.length} frame${frameIndices.length > 1 ? 's' : ''} to position ${targetIndex + 1}`,\n      data: {\n        frameIndices: sortedIndices,\n        targetIndex,\n        previousCurrentFrame,\n        newCurrentFrame,\n        movedFrameIds,\n        previousSelectionFrameIds,\n        newSelectionFrameIds: movedFrameIds\n      }\n    };\n    \n    // Execute the action\n    useAnimationStore.getState().reorderFrameRange(sortedIndices, targetIndex);\n    \n    // Record in history\n    pushToHistory(historyAction);\n  }, [frames, currentFrameIndex, pushToHistory, selectedFrameIndices]);\n\n  return {\n    addFrame,\n    duplicateFrame,\n    duplicateFrameRange,\n    removeFrame,\n    reorderFrames,\n    updateFrameDuration,\n    updateFrameName,\n    addMultipleFrames,\n    deleteFrameRange,\n    deleteAllFramesWithReset,\n    reorderFrameRange\n  };\n};\n","usedDeprecatedRules":[]},{"filePath":"/Users/cameronfoxly/GitHubRepos/Ascii-Motion/src/hooks/useAnimationPlayback.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/cameronfoxly/GitHubRepos/Ascii-Motion/src/hooks/useAsciiTypePlacement.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/cameronfoxly/GitHubRepos/Ascii-Motion/src/hooks/useAsciiTypeTool.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/cameronfoxly/GitHubRepos/Ascii-Motion/src/hooks/useCanvasDragAndDrop.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/cameronfoxly/GitHubRepos/Ascii-Motion/src/hooks/useCanvasLassoSelection.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/cameronfoxly/GitHubRepos/Ascii-Motion/src/hooks/useCanvasMagicWandSelection.ts","messages":[{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useCallback has an unnecessary dependency: 'magicWandSelection'. Either exclude it or remove the dependency array.","line":357,"column":6,"nodeType":"ArrayExpression","endLine":364,"endColumn":4,"suggestions":[{"desc":"Update the dependencies array to be: [mouseButtonDown, getGridCoordinatesFromEvent, selectionMode, moveState, setMoveState]","fix":{"range":[12432,12571],"text":"[mouseButtonDown, getGridCoordinatesFromEvent, selectionMode, moveState, setMoveState]"}}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { useCallback, useRef } from 'react';\nimport { useCanvasContext, useCanvasDimensions } from '../contexts/CanvasContext';\nimport { useCanvasState } from './useCanvasState';\nimport { useCanvasStore } from '../stores/canvasStore';\nimport { useAnimationStore } from '../stores/animationStore';\nimport { useToolStore } from '../stores/toolStore';\nimport type { Cell } from '../types';\nimport { unionSelectionMasks, subtractSelectionMask } from '../utils/selectionUtils';\n\n/**\n * Hook for handling magic wand selection tool behavior\n * Manages character/color-based selection creation, movement, and drag operations\n */\nexport const useCanvasMagicWandSelection = () => {\n  const { canvasRef, mouseButtonDown, setMouseButtonDown, setSelectionPreview } = useCanvasContext();\n  const { getGridCoordinates } = useCanvasDimensions();\n  const {\n    selectionMode,\n    moveState,\n    justCommittedMove,\n    commitMove,\n    setSelectionMode,\n    setMoveState,\n    setJustCommittedMove,\n  } = useCanvasState();\n  \n  const { currentFrameIndex } = useAnimationStore();\n  const { width, height, cells, getCell } = useCanvasStore();\n  const { \n    magicWandSelection, \n    magicWandContiguous,\n    startMagicWandSelection,\n    clearMagicWandSelection,\n    pushCanvasHistory,\n    magicMatchChar,\n    magicMatchColor,\n    magicMatchBgColor,\n    setMagicWandSelectionFromMask\n  } = useToolStore();\n\n  const selectionModifierRef = useRef<'replace' | 'add' | 'subtract'>('replace');\n  const baseSelectionMaskRef = useRef<Set<string>>(new Set());\n  const selectionGestureActiveRef = useRef(false);\n  const baseTargetCellRef = useRef<Cell | null>(null);\n\n  const clearSelectionPreview = useCallback(() => {\n    setSelectionPreview({\n      active: false,\n      modifier: 'replace',\n      tool: null,\n      baseCells: [],\n      gestureCells: []\n    });\n  }, [setSelectionPreview]);\n\n  const resetSelectionGesture = useCallback(() => {\n    selectionModifierRef.current = 'replace';\n    baseSelectionMaskRef.current = new Set();\n    selectionGestureActiveRef.current = false;\n    baseTargetCellRef.current = null;\n    clearSelectionPreview();\n  }, [clearSelectionPreview]);\n\n  const beginSelectionPreview = useCallback((modifier: 'replace' | 'add' | 'subtract') => {\n    if (modifier === 'replace') {\n      clearSelectionPreview();\n      return;\n    }\n\n    setSelectionPreview({\n      active: true,\n      modifier,\n      tool: 'magicwand',\n      baseCells: Array.from(baseSelectionMaskRef.current),\n      gestureCells: []\n    });\n  }, [setSelectionPreview, clearSelectionPreview]);\n\n  const updateSelectionPreview = useCallback((gestureCells: Set<string>) => {\n    if (!selectionGestureActiveRef.current) {\n      return;\n    }\n\n    if (selectionModifierRef.current === 'replace') {\n      clearSelectionPreview();\n      return;\n    }\n\n    setSelectionPreview({\n      active: true,\n      modifier: selectionModifierRef.current,\n      tool: 'magicwand',\n      baseCells: Array.from(baseSelectionMaskRef.current),\n      gestureCells: Array.from(gestureCells)\n    });\n  }, [setSelectionPreview, clearSelectionPreview]);\n\n  const finalizeSelectionGesture = useCallback(() => {\n    if (!selectionGestureActiveRef.current) {\n      return;\n    }\n\n    const currentMask = magicWandSelection.active ? new Set(magicWandSelection.selectedCells) : new Set<string>();\n    let nextMask: Set<string>;\n\n    switch (selectionModifierRef.current) {\n      case 'add':\n        nextMask = unionSelectionMasks(baseSelectionMaskRef.current, currentMask);\n        break;\n      case 'subtract':\n        nextMask = subtractSelectionMask(baseSelectionMaskRef.current, currentMask);\n        break;\n      default:\n        nextMask = currentMask;\n        break;\n    }\n\n    const finalTarget = selectionModifierRef.current === 'replace'\n      ? magicWandSelection.targetCell\n      : baseTargetCellRef.current ?? magicWandSelection.targetCell;\n\n    setMagicWandSelectionFromMask(nextMask, finalTarget ?? undefined);\n    resetSelectionGesture();\n  }, [magicWandSelection, setMagicWandSelectionFromMask, resetSelectionGesture]);\n\n  // Convert mouse coordinates to grid coordinates\n  const getGridCoordinatesFromEvent = useCallback((event: React.MouseEvent<HTMLCanvasElement>) => {\n    const canvas = canvasRef.current;\n    if (!canvas) return { x: 0, y: 0 };\n\n    const rect = canvas.getBoundingClientRect();\n    const mouseX = event.clientX;\n    const mouseY = event.clientY;\n\n    return getGridCoordinates(mouseX, mouseY, rect, width, height);\n  }, [getGridCoordinates, width, height, canvasRef]);\n\n  // Check if a cell is empty (has no character or default character)\n  const isCellEmpty = useCallback((cell: Cell | undefined) => {\n    if (!cell) return true;\n    return !cell.char || cell.char === '' || cell.char === ' ';\n  }, []);\n\n  // Check if two cells match according to enabled criteria (AND semantics)\n  const cellsMatch = useCallback((cell1: Cell | undefined, cell2: Cell | undefined) => {\n    // Both empty considered match only if character matching is enabled (so they represent same absence)\n    if (isCellEmpty(cell1) && isCellEmpty(cell2)) {\n      return magicMatchChar; // Only match empties if char criterion is on\n    }\n    if (isCellEmpty(cell1) || isCellEmpty(cell2)) return false;\n    if (!cell1 || !cell2) return false;\n    if (magicMatchChar && cell1.char !== cell2.char) return false;\n    if (magicMatchColor && cell1.color !== cell2.color) return false;\n    if (magicMatchBgColor && cell1.bgColor !== cell2.bgColor) return false;\n    // If all enabled criteria passed\n    return true;\n  }, [isCellEmpty, magicMatchChar, magicMatchColor, magicMatchBgColor]);\n\n  // Find all matching cells using flood fill (contiguous) or scan (non-contiguous)\n  const findMatchingCells = useCallback((targetX: number, targetY: number, targetCell: Cell | undefined) => {\n    // If no criteria enabled, do nothing\n    if (!magicMatchChar && !magicMatchColor && !magicMatchBgColor) {\n      return new Set<string>();\n    }\n    // If target is empty and char not part of criteria -> nothing\n    if (isCellEmpty(targetCell) && !magicMatchChar) {\n      return new Set<string>();\n    }\n\n    const matchingCells = new Set<string>();\n\n    if (magicWandContiguous) {\n      // Contiguous selection using flood fill\n      const visited = new Set<string>();\n      const queue: { x: number; y: number }[] = [{ x: targetX, y: targetY }];\n\n      while (queue.length > 0) {\n        const { x, y } = queue.shift()!;\n        const cellKey = `${x},${y}`;\n\n        // Skip if out of bounds or already visited\n        if (x < 0 || x >= width || y < 0 || y >= height || visited.has(cellKey)) {\n          continue;\n        }\n\n        visited.add(cellKey);\n        const currentCell = getCell(x, y);\n\n        // If this cell matches the target, add it and check neighbors\n        if (cellsMatch(currentCell, targetCell)) {\n          matchingCells.add(cellKey);\n\n          // Add neighbors to queue\n          queue.push(\n            { x: x - 1, y }, // left\n            { x: x + 1, y }, // right\n            { x, y: y - 1 }, // up\n            { x, y: y + 1 }  // down\n          );\n        }\n      }\n    } else {\n      // Non-contiguous selection - scan entire canvas\n      for (let x = 0; x < width; x++) {\n        for (let y = 0; y < height; y++) {\n          const currentCell = getCell(x, y);\n          if (cellsMatch(currentCell, targetCell)) {\n            matchingCells.add(`${x},${y}`);\n          }\n        }\n      }\n    }\n\n    return matchingCells;\n  }, [width, height, getCell, cellsMatch, isCellEmpty, magicWandContiguous, magicMatchChar, magicMatchColor, magicMatchBgColor]);\n\n  // Check if a point is inside the current magic wand selection\n  const isPointInMagicWandSelection = useCallback((x: number, y: number) => {\n    if (!magicWandSelection.active || magicWandSelection.selectedCells.size === 0) return false;\n    \n    // If there's a move state, we need to check against the original (non-offset) coordinates\n    // because the selectedCells are stored in original coordinates\n    if (moveState) {\n      const totalOffset = {\n        x: moveState.baseOffset.x + moveState.currentOffset.x,\n        y: moveState.baseOffset.y + moveState.currentOffset.y\n      };\n      \n      // Convert the click point back to original coordinates\n      const originalX = x - totalOffset.x;\n      const originalY = y - totalOffset.y;\n      return magicWandSelection.selectedCells.has(`${originalX},${originalY}`);\n    }\n    \n    // No move state, check directly\n    return magicWandSelection.selectedCells.has(`${x},${y}`);\n  }, [magicWandSelection, moveState]);\n\n  // Handle magic wand selection mouse down\n  const handleMagicWandMouseDown = useCallback((event: React.MouseEvent<HTMLCanvasElement>) => {\n    const { x, y } = getGridCoordinatesFromEvent(event);\n    const modifier: 'replace' | 'add' | 'subtract' = event.altKey ? 'subtract' : (event.shiftKey ? 'add' : 'replace');\n    selectionModifierRef.current = modifier;\n\n    const existingMask = magicWandSelection.active ? new Set(magicWandSelection.selectedCells) : new Set<string>();\n    baseTargetCellRef.current = magicWandSelection.active ? magicWandSelection.targetCell : null;\n\n    // Save current state for undo\n    pushCanvasHistory(new Map(cells), currentFrameIndex);\n\n    if (moveState && magicWandSelection.active && !isPointInMagicWandSelection(x, y) && modifier === 'replace') {\n      commitMove();\n      clearMagicWandSelection();\n      setJustCommittedMove(true);\n      resetSelectionGesture();\n      return;\n    }\n\n    // Check if we clicked inside an existing selection to start move mode (only without modifiers)\n    if (magicWandSelection.active && isPointInMagicWandSelection(x, y) && modifier === 'replace') {\n      setSelectionMode('moving');\n\n      if (moveState) {\n        const adjustedStartPos = {\n          x: x - moveState.currentOffset.x,\n          y: y - moveState.currentOffset.y\n        };\n        setMoveState({\n          ...moveState,\n          startPos: adjustedStartPos\n        });\n      } else {\n        const originalData = new Map<string, Cell>();\n        magicWandSelection.selectedCells.forEach((cellKey) => {\n          const [cx, cy] = cellKey.split(',').map(Number);\n          const cell = getCell(cx, cy);\n          if (cell && !isCellEmpty(cell)) {\n            originalData.set(cellKey, cell);\n          }\n        });\n\n        setMoveState({\n          originalData,\n          originalPositions: new Set(originalData.keys()),\n          startPos: { x, y },\n          baseOffset: { x: 0, y: 0 },\n          currentOffset: { x: 0, y: 0 }\n        });\n      }\n      setMouseButtonDown(true);\n      resetSelectionGesture();\n      return;\n    }\n\n    setJustCommittedMove(false);\n\n    const targetCell = getCell(x, y);\n    const matchingCells = findMatchingCells(x, y, targetCell);\n\n    if (matchingCells.size === 0) {\n      if (modifier === 'replace') {\n        clearMagicWandSelection();\n      }\n      resetSelectionGesture();\n      setMouseButtonDown(true);\n      return;\n    }\n\n    baseSelectionMaskRef.current = existingMask;\n    selectionGestureActiveRef.current = true;\n    beginSelectionPreview(modifier);\n\n    startMagicWandSelection(targetCell, matchingCells);\n    setSelectionMode('none');\n    updateSelectionPreview(matchingCells);\n    setMouseButtonDown(true);\n  }, [\n    getGridCoordinatesFromEvent,\n    magicWandSelection,\n    pushCanvasHistory,\n    cells,\n    currentFrameIndex,\n    moveState,\n    isPointInMagicWandSelection,\n    commitMove,\n    clearMagicWandSelection,\n    setJustCommittedMove,\n    resetSelectionGesture,\n    beginSelectionPreview,\n    setSelectionMode,\n    setMoveState,\n    setMouseButtonDown,\n    getCell,\n    isCellEmpty,\n    findMatchingCells,\n    startMagicWandSelection,\n    updateSelectionPreview\n  ]);\n\n  // Handle mouse move during magic wand selection\n  const handleMagicWandMouseMove = useCallback((event: React.MouseEvent<HTMLCanvasElement>) => {\n    const { x, y } = getGridCoordinatesFromEvent(event);\n\n    // Handle move mode - only update position if mouse button is down (mouse-initiated move)\n    // This prevents arrow key-initiated moves from jumping to follow mouse movement\n    if (selectionMode === 'moving' && moveState && mouseButtonDown) {\n      const newOffset = {\n        x: x - moveState.startPos.x,\n        y: y - moveState.startPos.y\n      };\n      \n      setMoveState({\n        ...moveState,\n        currentOffset: newOffset\n      });\n    }\n  }, [\n    mouseButtonDown, \n    magicWandSelection, \n    getGridCoordinatesFromEvent, \n    selectionMode, \n    moveState, \n    setMoveState\n  ]);\n\n  // Handle mouse up for magic wand selection\n  const handleMagicWandMouseUp = useCallback(() => {\n    if (!mouseButtonDown) return;\n\n    setMouseButtonDown(false);\n\n    // If we were in moving mode, that's the end of the move operation\n    // The move will be committed when the user clicks elsewhere or presses Enter/Escape\n    if (selectionMode === 'moving' && moveState) {\n      // Move operation is complete, but not committed yet\n      // User can continue adjusting or commit/cancel\n    }\n\n    // Reset just committed flag after a short delay to allow for proper click detection\n    if (justCommittedMove) {\n      setTimeout(() => setJustCommittedMove(false), 100);\n    }\n\n    if (selectionGestureActiveRef.current) {\n      finalizeSelectionGesture();\n    }\n  }, [\n    mouseButtonDown,\n    setMouseButtonDown,\n    selectionMode,\n    moveState,\n    justCommittedMove,\n    setJustCommittedMove,\n    finalizeSelectionGesture\n  ]);\n\n  return {\n    handleMagicWandMouseDown,\n    handleMagicWandMouseMove,\n    handleMagicWandMouseUp,\n    isPointInMagicWandSelection,\n  };\n};\n","usedDeprecatedRules":[]},{"filePath":"/Users/cameronfoxly/GitHubRepos/Ascii-Motion/src/hooks/useCanvasMouseHandlers.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/cameronfoxly/GitHubRepos/Ascii-Motion/src/hooks/useCanvasRenderer.ts","messages":[{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useCallback has missing dependencies: 'activeTool', 'canvasBackgroundColor', 'drawGridBackground', 'effectiveCellHeight', 'effectiveCellWidth', 'height', 'hoveredCell', 'lassoSelection.selectedCells', 'moveState', 'panOffset.x', 'panOffset.y', 'pasteMode.isActive', 'pasteMode.preview', 'textToolState.cursorPosition', 'textToolState.cursorVisible', 'textToolState.isTyping', and 'width'. Either include them or remove the dependency array.","line":551,"column":6,"nodeType":"ArrayExpression","endLine":574,"endColumn":4,"suggestions":[{"desc":"Update the dependencies array to be: [canvasRef, canvasConfig.canvasBackgroundColor, canvasConfig.canvasWidth, canvasConfig.canvasHeight, canvasConfig.height, canvasConfig.width, canvasConfig.effectiveCellWidth, canvasConfig.panOffset.x, canvasConfig.panOffset.y, canvasConfig.effectiveCellHeight, drawGridBackground, renderOnionSkins, drawingStyles.font, drawingStyles.textAlign, drawingStyles.textBaseline, drawingStyles.defaultTextColor, drawingStyles.defaultBgColor, moveState, isTimeEffectPreviewActive, overlayState.moveState, overlayState.selectionData, toolState.lassoSelection.active, toolState.linePreview.active, toolState.linePreview.points, toolState.activeTool, toolState.rectangleFilled, pasteMode.isActive, pasteMode.preview, hoveredCell, width, height, isPreviewActive, previewData, textToolState.isTyping, textToolState.cursorVisible, textToolState.cursorPosition, drawCell, getCell, getTotalOffset, getEllipsePoints, lassoSelection.selectedCells, effectiveCellWidth, panOffset.x, panOffset.y, effectiveCellHeight, isEffectPreviewActive, activeTool, previewOrigin, previewDimensions, canvasBackgroundColor]","fix":{"range":[22051,22579],"text":"[canvasRef, canvasConfig.canvasBackgroundColor, canvasConfig.canvasWidth, canvasConfig.canvasHeight, canvasConfig.height, canvasConfig.width, canvasConfig.effectiveCellWidth, canvasConfig.panOffset.x, canvasConfig.panOffset.y, canvasConfig.effectiveCellHeight, drawGridBackground, renderOnionSkins, drawingStyles.font, drawingStyles.textAlign, drawingStyles.textBaseline, drawingStyles.defaultTextColor, drawingStyles.defaultBgColor, moveState, isTimeEffectPreviewActive, overlayState.moveState, overlayState.selectionData, toolState.lassoSelection.active, toolState.linePreview.active, toolState.linePreview.points, toolState.activeTool, toolState.rectangleFilled, pasteMode.isActive, pasteMode.preview, hoveredCell, width, height, isPreviewActive, previewData, textToolState.isTyping, textToolState.cursorVisible, textToolState.cursorPosition, drawCell, getCell, getTotalOffset, getEllipsePoints, lassoSelection.selectedCells, effectiveCellWidth, panOffset.x, panOffset.y, effectiveCellHeight, isEffectPreviewActive, activeTool, previewOrigin, previewDimensions, canvasBackgroundColor]"}}]},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useEffect has a missing dependency: 'canvasRef'. Either include it or remove the dependency array.","line":603,"column":6,"nodeType":"ArrayExpression","endLine":603,"endColumn":47,"suggestions":[{"desc":"Update the dependencies array to be: [canvasWidth, canvasHeight, renderCanvas, canvasRef]","fix":{"range":[23469,23510],"text":"[canvasWidth, canvasHeight, renderCanvas, canvasRef]"}}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { useCallback, useEffect, useMemo } from 'react';\nimport { useCanvasStore } from '../stores/canvasStore';\nimport { useToolStore } from '../stores/toolStore';\nimport { usePreviewStore } from '../stores/previewStore';\nimport { useEffectsStore } from '../stores/effectsStore';\nimport { useTimeEffectsStore } from '../stores/timeEffectsStore';\nimport { useAsciiTypeStore } from '../stores/asciiTypeStore';\nimport { useCanvasContext } from '../contexts/CanvasContext';\nimport { useTheme } from '../contexts/ThemeContext';\nimport { useCanvasState } from './useCanvasState';\nimport { useMemoizedGrid } from './useMemoizedGrid';\nimport { useDrawingTool } from './useDrawingTool';\nimport { useOnionSkinRenderer } from './useOnionSkinRenderer';\nimport { measureCanvasRender, finishCanvasRender } from '../utils/performance';\nimport { \n  setupTextRendering\n} from '../utils/canvasTextRendering';\nimport { scheduleCanvasRender } from '../utils/renderScheduler';\nimport { markFullRedraw } from '../utils/dirtyTracker';\nimport { calculateAdaptiveGridColor } from '../utils/gridColor';\nimport type { Cell } from '../types';\n\n/**\n * Setup high-DPI canvas for crisp text rendering\n * Returns scale factor for coordinate transformations\n */\nconst setupHighDPICanvas = (\n  canvas: HTMLCanvasElement,\n  displayWidth: number,\n  displayHeight: number\n): { ctx: CanvasRenderingContext2D; scale: number } => {\n  const ctx = canvas.getContext('2d');\n  if (!ctx) throw new Error('Failed to get 2D context');\n\n  // Use device pixel ratio for crisp rendering on high-DPI displays\n  const devicePixelRatio = window.devicePixelRatio || 1;\n  \n  // Set canvas internal resolution to match device pixel ratio\n  canvas.width = displayWidth * devicePixelRatio;\n  canvas.height = displayHeight * devicePixelRatio;\n  \n  // Set CSS size to desired display size (no transform needed)\n  canvas.style.width = `${displayWidth}px`;\n  canvas.style.height = `${displayHeight}px`;\n  \n  // Scale the drawing context to match the device pixel ratio\n  ctx.scale(devicePixelRatio, devicePixelRatio);\n  \n  // Apply high-quality text rendering settings\n  ctx.textBaseline = 'top';\n  ctx.imageSmoothingEnabled = true;\n  ctx.imageSmoothingQuality = 'high';\n  \n  return { ctx, scale: devicePixelRatio };\n};\n\n/**\n * Hook for optimized canvas rendering with memoization\n * Implements Step 5.1 performance optimizations:\n * - Memoized font and style calculations\n * - Grid-level change detection\n * - Performance measurement\n */\nexport const useCanvasRenderer = () => {\n  const { canvasRef, pasteMode, panOffset, hoveredCell, fontMetrics } = useCanvasContext();\n  const { theme } = useTheme();\n  const {\n    effectiveCellWidth,\n    effectiveCellHeight,\n    zoom,\n    moveState,\n    canvasWidth,\n    canvasHeight,\n    getTotalOffset,\n  } = useCanvasState();\n\n  const { \n    width, \n    height, \n    cells,\n    canvasBackgroundColor,\n    showGrid,\n    getCell\n  } = useCanvasStore();\n\n  const { activeTool, rectangleFilled, lassoSelection, magicWandSelection, textToolState, linePreview } = useToolStore();\n  const { previewData, isPreviewActive } = usePreviewStore();\n  const { isPreviewActive: isEffectPreviewActive } = useEffectsStore();\n  const { isPreviewActive: isTimeEffectPreviewActive } = useTimeEffectsStore();\n  const { previewOrigin, previewDimensions } = useAsciiTypeStore();\n  \n  // Debug: Log preview state changes\n  useEffect(() => {\n    console.log('[Canvas Renderer] Preview state changed:', {\n      isPreviewActive,\n      previewDataSize: previewData.size,\n      isEffectPreviewActive,  \n      isTimeEffectPreviewActive\n    });\n  }, [isPreviewActive, previewData, isEffectPreviewActive, isTimeEffectPreviewActive]);\n  const { getEllipsePoints } = useDrawingTool();\n\n  // Use onion skin renderer for frame overlays\n  const { renderOnionSkins } = useOnionSkinRenderer();\n\n  // Use memoized grid for optimized rendering  \n  const { selectionData } = useMemoizedGrid(\n    moveState,\n    getTotalOffset\n  );\n\n  // Memoize canvas dimensions and styling to reduce re-renders\n  const canvasConfig = useMemo(() => ({\n    width,\n    height,\n    canvasWidth,\n    canvasHeight,\n    effectiveCellWidth,\n    effectiveCellHeight,\n    panOffset,\n    showGrid,\n    canvasBackgroundColor\n  }), [width, height, canvasWidth, canvasHeight, effectiveCellWidth, effectiveCellHeight, panOffset, showGrid, canvasBackgroundColor]);\n\n  // Memoize tool state to reduce re-renders\n  const toolState = useMemo(() => ({\n    activeTool,\n    rectangleFilled,\n    lassoSelection,\n    magicWandSelection,\n    textToolState,\n    linePreview\n  }), [activeTool, rectangleFilled, lassoSelection, magicWandSelection, textToolState, linePreview]);\n\n  // Memoize overlay state\n  const overlayState = useMemo(() => ({\n    moveState,\n    selectionData,\n    hoveredCell,\n    pasteMode\n  }), [moveState, selectionData, hoveredCell, pasteMode]);\n\n  // Memoize font and style calculations\n  const drawingStyles = useMemo(() => {\n    // Scale font size with zoom - keep original logic\n    const scaledFontSize = fontMetrics.fontSize * zoom;\n    const scaledFontString = `${scaledFontSize}px '${fontMetrics.fontFamily}', monospace`;\n    \n    return {\n      font: scaledFontString,\n      gridLineColor: calculateAdaptiveGridColor(canvasBackgroundColor, theme),\n      gridLineWidth: 1, // Use 1 pixel for crisp grid lines\n      textAlign: 'center' as CanvasTextAlign,\n      textBaseline: 'middle' as CanvasTextBaseline,\n      defaultTextColor: '#FFFFFF',\n      defaultBgColor: '#000000'\n    };\n  }, [fontMetrics, zoom, canvasBackgroundColor, theme]);\n\n    // Optimized drawCell function with pixel-aligned rendering (but no coordinate changes)\n  const drawCell = useCallback((ctx: CanvasRenderingContext2D, x: number, y: number, cell: Cell) => {\n    // Round pixel positions to ensure crisp rendering\n    const pixelX = Math.round(x * effectiveCellWidth + panOffset.x);\n    const pixelY = Math.round(y * effectiveCellHeight + panOffset.y);\n    const cellWidth = Math.round(effectiveCellWidth);\n    const cellHeight = Math.round(effectiveCellHeight);\n\n    // Draw background (only if different from canvas background)\n    if (cell.bgColor && cell.bgColor !== 'transparent' && cell.bgColor !== canvasBackgroundColor) {\n      ctx.fillStyle = cell.bgColor;\n      ctx.fillRect(pixelX, pixelY, cellWidth, cellHeight);\n    }\n\n    // Draw character with pixel-perfect positioning\n    if (cell.char && cell.char !== ' ') {\n      ctx.fillStyle = cell.color || drawingStyles.defaultTextColor;\n      ctx.font = drawingStyles.font;\n      ctx.textAlign = drawingStyles.textAlign;\n      ctx.textBaseline = drawingStyles.textBaseline;\n      \n      // Center text with rounded positions for crisp rendering\n      const centerX = Math.round(pixelX + cellWidth / 2);\n      const centerY = Math.round(pixelY + cellHeight / 2);\n      \n      ctx.fillText(cell.char, centerX, centerY);\n    }\n  }, [effectiveCellWidth, effectiveCellHeight, panOffset, canvasBackgroundColor, drawingStyles]);\n\n  // Separate function to render grid background\n  const drawGridBackground = useCallback((ctx: CanvasRenderingContext2D) => {\n    if (!showGrid) return;\n    \n    ctx.strokeStyle = drawingStyles.gridLineColor;\n    ctx.lineWidth = drawingStyles.gridLineWidth;\n    \n    // Draw vertical lines\n    for (let x = 0; x <= width; x++) {\n      const lineX = Math.round(x * effectiveCellWidth + panOffset.x) + 0.5;\n      ctx.beginPath();\n      ctx.moveTo(lineX, panOffset.y);\n      ctx.lineTo(lineX, height * effectiveCellHeight + panOffset.y);\n      ctx.stroke();\n    }\n    \n    // Draw horizontal lines\n    for (let y = 0; y <= height; y++) {\n      const lineY = Math.round(y * effectiveCellHeight + panOffset.y) + 0.5;\n      ctx.beginPath();\n      ctx.moveTo(panOffset.x, lineY);\n      ctx.lineTo(width * effectiveCellWidth + panOffset.x, lineY);\n      ctx.stroke();\n    }\n  }, [width, height, effectiveCellWidth, effectiveCellHeight, panOffset, drawingStyles, showGrid]);\n\n  // Optimized render function with performance measurement and subtle DPI improvements\n  const renderCanvas = useCallback(() => {\n    const canvas = canvasRef.current;\n    if (!canvas) return;\n\n    const ctx = canvas.getContext('2d');\n    if (!ctx) return;\n\n    // Apply only text rendering optimizations without affecting canvas size/coordinates\n    setupTextRendering(ctx);\n\n    // Start performance measurement\n    measureCanvasRender();\n\n    // Clear canvas and fill with background color\n    if (canvasConfig.canvasBackgroundColor === 'transparent') {\n      // For transparent backgrounds, clear the canvas completely\n      ctx.clearRect(0, 0, canvasConfig.canvasWidth, canvasConfig.canvasHeight);\n    } else {\n      // For solid backgrounds, fill with the background color\n      ctx.fillStyle = canvasConfig.canvasBackgroundColor;\n      ctx.fillRect(0, 0, canvasConfig.canvasWidth, canvasConfig.canvasHeight);\n    }\n\n    // Render grid background layer first (behind content)\n    drawGridBackground(ctx);\n\n    // Render onion skin layers (previous and next frames)\n    renderOnionSkins();\n\n    // Set font context once for the entire render batch\n    ctx.font = drawingStyles.font;\n    ctx.textAlign = drawingStyles.textAlign;\n    ctx.textBaseline = drawingStyles.textBaseline;\n\n    // Create a set of coordinates that are being moved (optimized)\n    const movingCells = new Set<string>();\n    if (moveState) {\n      const originalKeys = moveState.originalPositions ?? new Set(moveState.originalData.keys());\n      originalKeys.forEach((key: string) => {\n        movingCells.add(key);\n      });\n    }\n\n    // Draw static cells (excluding cells being moved)\n    // Skip drawing original cells if time effects preview is active (preview will render all cells)\n    if (!isTimeEffectPreviewActive) {\n      for (let y = 0; y < canvasConfig.height; y++) {\n        for (let x = 0; x < canvasConfig.width; x++) {\n          const key = `${x},${y}`;\n          \n          if (movingCells.has(key)) {\n            // Draw empty cell in original position during move\n            drawCell(ctx, x, y, { \n              char: ' ', \n              color: drawingStyles.defaultTextColor, \n              bgColor: drawingStyles.defaultBgColor \n            });\n          } else {\n            const cell = getCell(x, y);\n            if (cell) {\n              drawCell(ctx, x, y, cell);\n            }\n          }\n        }\n      }\n    }\n\n    // Draw moved cells at their new positions\n    if (overlayState.moveState && overlayState.moveState.originalData.size > 0) {\n      const totalOffset = getTotalOffset(overlayState.moveState);\n      overlayState.moveState.originalData.forEach((cell: Cell, key: string) => {\n        const [origX, origY] = key.split(',').map(Number);\n        const newX = origX + totalOffset.x;\n        const newY = origY + totalOffset.y;\n        \n        // Only draw if within bounds\n        if (newX >= 0 && newX < canvasConfig.width && newY >= 0 && newY < canvasConfig.height) {\n          drawCell(ctx, newX, newY, cell);\n        }\n      });\n    }\n\n    // Draw selection overlay\n    if (overlayState.selectionData) {\n      if (toolState.activeTool === 'ellipse') {\n        // Draw ellipse preview with highlighted cells\n        const centerX = (overlayState.selectionData.startX + overlayState.selectionData.startX + overlayState.selectionData.width - 1) / 2;\n        const centerY = (overlayState.selectionData.startY + overlayState.selectionData.startY + overlayState.selectionData.height - 1) / 2;\n        const radiusX = (overlayState.selectionData.width - 1) / 2;\n        const radiusY = (overlayState.selectionData.height - 1) / 2;\n\n        // Get ellipse points to highlight exactly which cells will be affected\n        const ellipsePoints = getEllipsePoints(centerX, centerY, radiusX, radiusY, toolState.rectangleFilled);\n        \n        // Highlight each cell that will be part of the ellipse\n        ctx.fillStyle = 'rgba(168, 85, 247, 0.3)'; // Purple highlight\n        ellipsePoints.forEach(({ x, y }) => {\n          if (x >= 0 && y >= 0 && x < canvasConfig.width && y < canvasConfig.height) {\n            ctx.fillRect(\n              Math.round(x * canvasConfig.effectiveCellWidth + canvasConfig.panOffset.x),\n              Math.round(y * canvasConfig.effectiveCellHeight + canvasConfig.panOffset.y),\n              Math.round(canvasConfig.effectiveCellWidth),\n              Math.round(canvasConfig.effectiveCellHeight)\n            );\n          }\n        });\n\n        // Draw ellipse outline\n        ctx.strokeStyle = '#A855F7'; // Purple border\n        ctx.lineWidth = 2;\n        ctx.setLineDash([5, 5]);\n        \n        // Draw ellipse path using HTML5 Canvas ellipse method\n        ctx.beginPath();\n        ctx.ellipse(\n          (centerX + 0.5) * canvasConfig.effectiveCellWidth + canvasConfig.panOffset.x,  // center x\n          (centerY + 0.5) * canvasConfig.effectiveCellHeight + canvasConfig.panOffset.y,  // center y  \n          (radiusX + 0.5) * canvasConfig.effectiveCellWidth,  // radius x\n          (radiusY + 0.5) * canvasConfig.effectiveCellHeight,  // radius y\n          0,                           // rotation\n          0,                           // start angle\n          2 * Math.PI                  // end angle\n        );\n        ctx.stroke();\n        ctx.setLineDash([]);\n      } else {\n        // Default rectangle preview for rectangle tool and selection tool\n        ctx.strokeStyle = '#3B82F6';\n        ctx.lineWidth = 2;\n        ctx.setLineDash([5, 5]);\n        ctx.strokeRect(\n          Math.round(overlayState.selectionData.startX * canvasConfig.effectiveCellWidth + canvasConfig.panOffset.x),\n          Math.round(overlayState.selectionData.startY * canvasConfig.effectiveCellHeight + canvasConfig.panOffset.y),\n          Math.round(overlayState.selectionData.width * canvasConfig.effectiveCellWidth),\n          Math.round(overlayState.selectionData.height * canvasConfig.effectiveCellHeight)\n        );\n        ctx.setLineDash([]);\n      }\n    }\n\n    // Draw lasso selection overlay\n    if (toolState.lassoSelection.active) {\n      // Note: Lasso path drawing removed for cleaner UX - only show filled selection\n      \n      // Highlight selected cells\n      if (lassoSelection.selectedCells.size > 0) {\n        ctx.fillStyle = 'rgba(168, 85, 247, 0.2)'; // Purple highlight with transparency\n        \n        lassoSelection.selectedCells.forEach(cellKey => {\n          const [x, y] = cellKey.split(',').map(Number);\n          \n          // Apply move offset if in move mode\n          let displayX = x;\n          let displayY = y;\n          if (moveState) {\n            const totalOffset = getTotalOffset(moveState);\n            displayX = x + totalOffset.x;\n            displayY = y + totalOffset.y;\n          }\n          \n          // Only draw if within canvas bounds\n          if (displayX >= 0 && displayY >= 0 && displayX < width && displayY < height) {\n            ctx.fillRect(\n              Math.round(displayX * effectiveCellWidth + panOffset.x),\n              Math.round(displayY * effectiveCellHeight + panOffset.y),\n              Math.round(effectiveCellWidth),\n              Math.round(effectiveCellHeight)\n            );\n          }\n        });\n\n        // Note: Lasso path border removed for cleaner UX - only show filled selection\n      }\n    }\n\n    // Draw shift+click line preview\n    if (toolState.linePreview.active && toolState.linePreview.points.length > 0) {\n      ctx.fillStyle = 'rgba(168, 85, 247, 0.2)'; // Same purple as lasso selection, doubled opacity\n      \n      toolState.linePreview.points.forEach(({ x, y }) => {\n        // Only draw if within canvas bounds\n        if (x >= 0 && y >= 0 && x < canvasConfig.width && y < canvasConfig.height) {\n          ctx.fillRect(\n            Math.round(x * canvasConfig.effectiveCellWidth + canvasConfig.panOffset.x),\n            Math.round(y * canvasConfig.effectiveCellHeight + canvasConfig.panOffset.y),\n            Math.round(canvasConfig.effectiveCellWidth),\n            Math.round(canvasConfig.effectiveCellHeight)\n          );\n        }\n      });\n    }\n\n    // Draw paste preview overlay\n    if (pasteMode.isActive && pasteMode.preview) {\n      const { position, data, bounds } = pasteMode.preview;\n      \n      // Calculate preview rectangle\n      const previewStartX = position.x + bounds.minX;\n      const previewStartY = position.y + bounds.minY;\n      const previewWidth = bounds.maxX - bounds.minX + 1;\n      const previewHeight = bounds.maxY - bounds.minY + 1;\n\n      // Draw paste preview marquee\n      ctx.strokeStyle = '#A855F7'; // Purple color\n      ctx.lineWidth = 2;\n      ctx.setLineDash([8, 4]);\n      ctx.strokeRect(\n        Math.round(previewStartX * effectiveCellWidth + panOffset.x),\n        Math.round(previewStartY * effectiveCellHeight + panOffset.y),\n        Math.round(previewWidth * effectiveCellWidth),\n        Math.round(previewHeight * effectiveCellHeight)\n      );\n\n      // Add semi-transparent background\n      ctx.fillStyle = 'rgba(168, 85, 247, 0.1)';\n      ctx.fillRect(\n        Math.round(previewStartX * effectiveCellWidth + panOffset.x),\n        Math.round(previewStartY * effectiveCellHeight + panOffset.y),\n        Math.round(previewWidth * effectiveCellWidth),\n        Math.round(previewHeight * effectiveCellHeight)\n      );\n\n      ctx.setLineDash([]);\n\n      // Draw paste content preview with transparency\n      ctx.globalAlpha = 0.85; // Make preview more visible\n      data.forEach((cell, key) => {\n        const [relX, relY] = key.split(',').map(Number);\n        const absoluteX = position.x + relX;\n        const absoluteY = position.y + relY;\n        \n        // Only draw if within canvas bounds\n        if (absoluteX >= 0 && absoluteX < width && absoluteY >= 0 && absoluteY < height) {\n          // Draw the actual cell content\n          drawCell(ctx, absoluteX, absoluteY, {\n            char: cell.char || ' ',\n            color: cell.color || drawingStyles.defaultTextColor,\n            bgColor: cell.bgColor || 'transparent'\n          });\n          \n          // Add a subtle highlight border around preview cells\n          ctx.strokeStyle = 'rgba(168, 85, 247, 0.4)';\n          ctx.lineWidth = 1;\n          ctx.strokeRect(\n            Math.round(absoluteX * effectiveCellWidth + panOffset.x), \n            Math.round(absoluteY * effectiveCellHeight + panOffset.y), \n            Math.round(effectiveCellWidth), \n            Math.round(effectiveCellHeight)\n          );\n        }\n      });\n      ctx.globalAlpha = 1.0;\n    }\n\n    // Draw hover cell outline (subtle outline for current cell under cursor)\n    if (hoveredCell && hoveredCell.x >= 0 && hoveredCell.x < width && hoveredCell.y >= 0 && hoveredCell.y < height) {\n      ctx.strokeStyle = 'rgba(59, 130, 246, 0.5)'; // 50% opacity blue outline for screenshots\n      ctx.lineWidth = 2;\n      ctx.setLineDash([]);\n      ctx.strokeRect(\n        Math.round(hoveredCell.x * effectiveCellWidth + panOffset.x),\n        Math.round(hoveredCell.y * effectiveCellHeight + panOffset.y),\n        Math.round(effectiveCellWidth),\n        Math.round(effectiveCellHeight)\n      );\n    }\n\n    // Draw preview overlay \n    if (isPreviewActive && previewData.size > 0) {\n      // Check if this is an effects preview (should be fully opaque) or other preview (semi-transparent)\n      const isEffectsPreview = isEffectPreviewActive || isTimeEffectPreviewActive;\n      const previewAlpha = isEffectsPreview ? 1.0 : 0.8; // Effects: full opacity, others: semi-transparent\n      \n      previewData.forEach((cell, key) => {\n        const [x, y] = key.split(',').map(Number);\n        \n        // Only draw if within canvas bounds\n        if (x >= 0 && x < canvasConfig.width && y >= 0 && y < canvasConfig.height) {\n          ctx.save();\n          ctx.globalAlpha = previewAlpha;\n          \n          // For effects previews, clear the cell area first to ensure complete replacement\n          if (isEffectsPreview) {\n            const pixelX = Math.round(x * effectiveCellWidth + panOffset.x);\n            const pixelY = Math.round(y * effectiveCellHeight + panOffset.y);\n            const cellWidth = Math.round(effectiveCellWidth);\n            const cellHeight = Math.round(effectiveCellHeight);\n            \n            // Clear the cell area with canvas background\n            ctx.fillStyle = canvasBackgroundColor;\n            ctx.fillRect(pixelX, pixelY, cellWidth, cellHeight);\n          }\n          \n          drawCell(ctx, x, y, cell);\n          \n          ctx.restore();\n        }\n      });\n\n      // Draw purple dotted outline for ASCII Type preview\n      if (activeTool === 'asciitype' && previewOrigin && previewDimensions) {\n        ctx.strokeStyle = '#A855F7'; // Purple color matching other tool overlays\n        ctx.lineWidth = 2;\n        ctx.setLineDash([8, 4]); // Dotted pattern matching paste/selection overlays\n        \n        const outlineX = Math.round(previewOrigin.x * effectiveCellWidth + panOffset.x);\n        const outlineY = Math.round(previewOrigin.y * effectiveCellHeight + panOffset.y);\n        const outlineWidth = Math.round(previewDimensions.width * effectiveCellWidth);\n        const outlineHeight = Math.round(previewDimensions.height * effectiveCellHeight);\n        \n        ctx.strokeRect(outlineX, outlineY, outlineWidth, outlineHeight);\n        ctx.setLineDash([]); // Reset line dash\n      }\n    }\n\n    // Draw text cursor overlay\n    if (textToolState.isTyping && textToolState.cursorVisible && textToolState.cursorPosition) {\n      const { x, y } = textToolState.cursorPosition;\n      \n      // Only draw cursor if within canvas bounds\n      if (x >= 0 && x < width && y >= 0 && y < height) {\n        ctx.fillStyle = '#A855F7'; // Purple color to match other overlays\n        ctx.fillRect(\n          Math.round(x * effectiveCellWidth + panOffset.x),\n          Math.round(y * effectiveCellHeight + panOffset.y),\n          Math.round(effectiveCellWidth),\n          Math.round(effectiveCellHeight)\n        );\n      }\n    }\n\n    // Finish performance measurement\n    const totalCells = width * height;\n    finishCanvasRender(totalCells);\n\n  }, [\n    // Use memoized objects to reduce re-renders\n    canvasConfig,\n    toolState,\n    overlayState,\n    // Keep these individual dependencies for now\n    cells, \n    getCell, \n    drawCell, \n    getTotalOffset,\n    canvasRef,\n    drawingStyles,\n    getEllipsePoints,\n    renderOnionSkins,\n    // Preview store values\n    previewData,\n    isPreviewActive,\n    // Effects preview state\n    isEffectPreviewActive,\n    isTimeEffectPreviewActive,\n    // ASCII Type preview outline state\n    previewOrigin,\n    previewDimensions\n  ]);\n\n  // Throttled render function that uses requestAnimationFrame\n  const scheduleRender = useCallback(() => {\n    scheduleCanvasRender(renderCanvas);\n  }, [renderCanvas]);\n\n  // Optimized render trigger - use scheduled rendering for better performance\n  const triggerRender = useCallback(() => {\n    // Mark that we need a full redraw for now (we can optimize this later)\n    markFullRedraw();\n    scheduleRender();\n  }, [scheduleRender]);\n\n  // Re-render when dependencies change (now throttled)\n  useEffect(() => {\n    triggerRender();\n  }, [triggerRender]);\n\n  // Handle canvas resize with high-DPI setup\n  useEffect(() => {\n    const canvas = canvasRef.current;\n    if (!canvas) return;\n\n    // Setup high-DPI canvas for crisp text rendering\n    setupHighDPICanvas(canvas, canvasWidth, canvasHeight);\n    \n    // Re-render after resize (immediate for resize)\n    renderCanvas();\n  }, [canvasWidth, canvasHeight, renderCanvas]);\n\n  return {\n    renderCanvas,\n    scheduleRender,\n    triggerRender\n  };\n};\n","usedDeprecatedRules":[]},{"filePath":"/Users/cameronfoxly/GitHubRepos/Ascii-Motion/src/hooks/useCanvasSelection.ts","messages":[{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useCallback has a missing dependency: 'setSelectionMode'. Either include it or remove the dependency array.","line":297,"column":6,"nodeType":"ArrayExpression","endLine":301,"endColumn":4,"suggestions":[{"desc":"Update the dependencies array to be: [getGridCoordinatesFromEvent, selectionMode, moveState, mouseButtonDown, selection.active, pendingSelectionStart, setMoveState, updateSelection, updateSelectionPreview, setSelectionMode, setPendingSelectionStart]","fix":{"range":[10075,10279],"text":"[getGridCoordinatesFromEvent, selectionMode, moveState, mouseButtonDown, selection.active, pendingSelectionStart, setMoveState, updateSelection, updateSelectionPreview, setSelectionMode, setPendingSelectionStart]"}}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { useCallback, useRef } from 'react';\nimport { useCanvasContext, useCanvasDimensions } from '../contexts/CanvasContext';\nimport { useCanvasState } from './useCanvasState';\nimport { useCanvasStore } from '../stores/canvasStore';\nimport { useAnimationStore } from '../stores/animationStore';\nimport { useToolStore } from '../stores/toolStore';\nimport type { Cell } from '../types';\nimport { unionSelectionMasks, subtractSelectionMask, createRectSelectionMask } from '../utils/selectionUtils';\n\n/**\n * Hook for handling selection tool behavior\n * Manages selection creation, movement, and drag operations\n */\nexport const useCanvasSelection = () => {\n  const { canvasRef, mouseButtonDown, setMouseButtonDown, setSelectionPreview } = useCanvasContext();\n  const { getGridCoordinates } = useCanvasDimensions();\n  const {\n    selectionMode,\n    moveState,\n    pendingSelectionStart,\n    justCommittedMove,\n    isPointInEffectiveSelection,\n    commitMove,\n    setSelectionMode,\n    setMoveState,\n    setPendingSelectionStart,\n    setJustCommittedMove,\n  } = useCanvasState();\n  \n  const { width, height, cells, getCell } = useCanvasStore();\n  const { currentFrameIndex } = useAnimationStore();\n  const { \n    selection, \n    startSelection, \n    updateSelection, \n    clearSelection, \n    pushCanvasHistory,\n    setSelectionFromMask\n  } = useToolStore();\n\n  const selectionModifierRef = useRef<'replace' | 'add' | 'subtract'>('replace');\n  const baseSelectionMaskRef = useRef<Set<string>>(new Set());\n  const selectionGestureActiveRef = useRef(false);\n  const gestureStartRef = useRef<{ x: number; y: number } | null>(null);\n\n  const clearSelectionPreview = useCallback(() => {\n    setSelectionPreview({\n      active: false,\n      modifier: 'replace',\n      tool: null,\n      baseCells: [],\n      gestureCells: []\n    });\n  }, [setSelectionPreview]);\n\n  const resetSelectionGesture = useCallback(() => {\n    selectionModifierRef.current = 'replace';\n    baseSelectionMaskRef.current = new Set();\n    selectionGestureActiveRef.current = false;\n    gestureStartRef.current = null;\n    clearSelectionPreview();\n  }, [clearSelectionPreview]);\n\n  const beginSelectionPreview = useCallback((modifier: 'replace' | 'add' | 'subtract', start: { x: number; y: number }) => {\n    gestureStartRef.current = start;\n    if (modifier === 'replace') {\n      clearSelectionPreview();\n      return;\n    }\n\n    setSelectionPreview({\n      active: true,\n      modifier,\n      tool: 'select',\n      baseCells: Array.from(baseSelectionMaskRef.current),\n      gestureCells: []\n    });\n  }, [setSelectionPreview, clearSelectionPreview]);\n\n  const updateSelectionPreview = useCallback((endX: number, endY: number) => {\n    if (!selectionGestureActiveRef.current) {\n      return;\n    }\n\n    if (selectionModifierRef.current === 'replace') {\n      clearSelectionPreview();\n      return;\n    }\n\n    const start = gestureStartRef.current;\n    if (!start) {\n      return;\n    }\n\n    const gestureMask = createRectSelectionMask(start, { x: endX, y: endY });\n    setSelectionPreview({\n      active: true,\n      modifier: selectionModifierRef.current,\n      tool: 'select',\n      baseCells: Array.from(baseSelectionMaskRef.current),\n      gestureCells: Array.from(gestureMask)\n    });\n  }, [setSelectionPreview, clearSelectionPreview]);\n\n  const finalizeSelectionGesture = useCallback(() => {\n    if (!selectionGestureActiveRef.current) {\n      return;\n    }\n\n    const currentMask = selection.active ? new Set(selection.selectedCells) : new Set<string>();\n    let nextMask: Set<string>;\n\n    switch (selectionModifierRef.current) {\n      case 'add':\n        nextMask = unionSelectionMasks(baseSelectionMaskRef.current, currentMask);\n        break;\n      case 'subtract':\n        nextMask = subtractSelectionMask(baseSelectionMaskRef.current, currentMask);\n        break;\n      default:\n        nextMask = currentMask;\n        break;\n    }\n\n    setSelectionFromMask(nextMask);\n    resetSelectionGesture();\n  }, [selection, setSelectionFromMask, resetSelectionGesture]);\n\n  // Convert mouse coordinates to grid coordinates\n  const getGridCoordinatesFromEvent = useCallback((event: React.MouseEvent<HTMLCanvasElement>) => {\n    const canvas = canvasRef.current;\n    if (!canvas) return { x: 0, y: 0 };\n\n    const rect = canvas.getBoundingClientRect();\n    const mouseX = event.clientX;\n    const mouseY = event.clientY;\n\n    return getGridCoordinates(mouseX, mouseY, rect, width, height);\n  }, [getGridCoordinates, width, height, canvasRef]);\n\n  // Handle selection tool mouse down\n  const handleSelectionMouseDown = useCallback((event: React.MouseEvent<HTMLCanvasElement>) => {\n    const { x, y } = getGridCoordinatesFromEvent(event);\n    const modifier: 'replace' | 'add' | 'subtract' = event.altKey ? 'subtract' : (event.shiftKey ? 'add' : 'replace');\n    selectionModifierRef.current = modifier;\n\n    const existingMask = selection.active ? new Set(selection.selectedCells) : new Set<string>();\n    \n    // Save current state for undo\n    pushCanvasHistory(new Map(cells), currentFrameIndex, 'Selection action');\n\n    // If there's an uncommitted move and clicking outside selection, commit it first\n    if (moveState && selection.active && !isPointInEffectiveSelection(x, y)) {\n      commitMove();\n      clearSelection();\n      setJustCommittedMove(true);\n      resetSelectionGesture();\n      return;\n    }\n\n    if (justCommittedMove) {\n      // Previous click committed a move, this click starts fresh\n      setJustCommittedMove(false);\n      baseSelectionMaskRef.current = existingMask;\n      selectionGestureActiveRef.current = true;\n      beginSelectionPreview(modifier, { x, y });\n      startSelection(x, y);\n      setPendingSelectionStart({ x, y });\n      setMouseButtonDown(true);\n      return;\n    }\n\n    if (selection.active && isPointInEffectiveSelection(x, y) && modifier === 'replace') {\n      // Click inside existing selection - enter move mode\n      setJustCommittedMove(false);\n      if (moveState) {\n        // Already have a moveState (continuing from arrow key movement) \n        // Adjust startPos to account for existing currentOffset so position doesn't jump\n        const adjustedStartPos = {\n          x: x - moveState.currentOffset.x,\n          y: y - moveState.currentOffset.y\n        };\n        setMoveState({\n          ...moveState,\n          startPos: adjustedStartPos\n        });\n      } else {\n        // First time moving - create new moveState\n        const originalData = new Map<string, Cell>();\n        const originalPositions = new Set<string>();\n\n        selection.selectedCells.forEach((cellKey) => {\n          originalPositions.add(cellKey);\n          const [cx, cy] = cellKey.split(',').map(Number);\n          const cell = getCell(cx, cy);\n          if (cell && cell.char !== ' ') {\n            originalData.set(cellKey, cell);\n          }\n        });\n\n        setMoveState({\n          originalData,\n          originalPositions,\n          startPos: { x, y },\n          baseOffset: { x: 0, y: 0 },\n          currentOffset: { x: 0, y: 0 }\n        });\n      }\n      setSelectionMode('moving');\n      setMouseButtonDown(true);\n      resetSelectionGesture();\n      return;\n    }\n\n    if (selection.active && !isPointInEffectiveSelection(x, y) && modifier === 'replace') {\n      // Click outside existing selection without modifiers - clear selection\n      setJustCommittedMove(false);\n      clearSelection();\n      resetSelectionGesture();\n      return;\n    }\n\n    // Start new selection (add/subtract/replace)\n    setJustCommittedMove(false);\n    baseSelectionMaskRef.current = existingMask;\n    selectionGestureActiveRef.current = true;\n\n    if (pendingSelectionStart && modifier !== 'replace') {\n      // Complete pending anchor selection for additive/subtractive mode\n      beginSelectionPreview(modifier, pendingSelectionStart);\n      startSelection(pendingSelectionStart.x, pendingSelectionStart.y);\n      updateSelection(x, y);\n      updateSelectionPreview(x, y);\n      setPendingSelectionStart(null);\n    } else {\n      beginSelectionPreview(modifier, { x, y });\n      startSelection(x, y);\n      setPendingSelectionStart({ x, y });\n      setMouseButtonDown(true);\n    }\n  }, [\n    getGridCoordinatesFromEvent,\n    selection,\n    pushCanvasHistory,\n    cells,\n    currentFrameIndex,\n    moveState,\n    isPointInEffectiveSelection,\n    commitMove,\n    clearSelection,\n    setJustCommittedMove,\n    beginSelectionPreview,\n    startSelection,\n    setPendingSelectionStart,\n    setMouseButtonDown,\n    setMoveState,\n    setSelectionMode,\n    getCell,\n    updateSelection,\n    pendingSelectionStart,\n    justCommittedMove,\n    resetSelectionGesture,\n    updateSelectionPreview\n  ]);\n\n  // Handle selection tool mouse move\n  const handleSelectionMouseMove = useCallback((event: React.MouseEvent<HTMLCanvasElement>) => {\n    const { x, y } = getGridCoordinatesFromEvent(event);\n\n    if (selectionMode === 'moving' && moveState && mouseButtonDown) {\n      // Only update move position if mouse button is down (mouse-initiated move)\n      // This prevents arrow key-initiated moves from jumping to follow mouse movement\n      const currentDragOffset = {\n        x: x - moveState.startPos.x,\n        y: y - moveState.startPos.y\n      };\n      \n      // Update the current offset for preview\n      setMoveState({\n        ...moveState,\n        currentOffset: currentDragOffset\n      });\n      // Note: Canvas modification happens in renderGrid for preview, actual move on mouse release\n    } else if (mouseButtonDown && selection.active && pendingSelectionStart) {\n      // Mouse button is down and we have a pending selection start - switch to drag mode\n      if (x !== pendingSelectionStart.x || y !== pendingSelectionStart.y) {\n        setSelectionMode('dragging');\n        setPendingSelectionStart(null);\n      }\n      updateSelection(x, y);\n      updateSelectionPreview(x, y);\n    } else if (selectionMode === 'dragging' && selection.active) {\n      // Update selection bounds while dragging\n      updateSelection(x, y);\n      updateSelectionPreview(x, y);\n    }\n  }, [\n    getGridCoordinatesFromEvent, selectionMode, moveState, setMoveState, \n    selection, updateSelection, mouseButtonDown, pendingSelectionStart, setPendingSelectionStart,\n    updateSelectionPreview\n  ]);\n\n  // Handle selection tool mouse up\n  const handleSelectionMouseUp = useCallback(() => {\n    if (selectionMode === 'moving' && moveState) {\n      // Move drag completed - persist the current offset into base offset for continued editing\n      setMoveState({\n        ...moveState,\n        baseOffset: {\n          x: moveState.baseOffset.x + moveState.currentOffset.x,\n          y: moveState.baseOffset.y + moveState.currentOffset.y\n        },\n        currentOffset: { x: 0, y: 0 }\n      });\n      setSelectionMode('none');\n      setMouseButtonDown(false);\n    } else if (selectionMode === 'dragging') {\n      // Drag completed - finish the selection\n      setSelectionMode('none');\n      setMouseButtonDown(false);\n      // Selection remains active with current bounds\n    } else {\n      // Single click completed - clear mouse button state but keep pending selection\n      setMouseButtonDown(false);\n    }\n\n    if (selectionGestureActiveRef.current) {\n      finalizeSelectionGesture();\n    }\n  }, [\n    selectionMode,\n    moveState,\n    setMoveState,\n    setSelectionMode,\n    setMouseButtonDown,\n    finalizeSelectionGesture\n  ]);\n\n  return {\n    handleSelectionMouseDown,\n    handleSelectionMouseMove,\n    handleSelectionMouseUp,\n  };\n};\n","usedDeprecatedRules":[]},{"filePath":"/Users/cameronfoxly/GitHubRepos/Ascii-Motion/src/hooks/useCanvasState.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/cameronfoxly/GitHubRepos/Ascii-Motion/src/hooks/useDrawingTool.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'_isFirstStroke' is assigned a value but never used.","line":137,"column":83,"nodeType":null,"messageId":"unusedVar","endLine":137,"endColumn":97}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { useCallback } from 'react';\nimport { useCanvasStore } from '../stores/canvasStore';\nimport { useToolStore } from '../stores/toolStore';\nimport { useCanvasContext } from '../contexts/CanvasContext';\nimport { calculateBrushCells } from '../utils/brushUtils';\nimport type { Cell } from '../types';\n\n/**\n * Custom hook for handling canvas drawing operations\n */\nexport const useDrawingTool = () => {\n  const { setCell, clearCell, getCell, fillArea } = useCanvasStore();\n  const { \n    activeTool, \n    selectedChar, \n    selectedColor, \n    selectedBgColor,\n    brushSettings,\n    rectangleFilled,\n    paintBucketContiguous,\n    pickFromCell,\n    pencilLastPosition,\n    setPencilLastPosition,\n    toolAffectsChar,\n    toolAffectsColor,\n    toolAffectsBgColor,\n    fillMatchChar,\n    fillMatchColor,\n    fillMatchBgColor\n  } = useToolStore();\n  const { fontMetrics } = useCanvasContext();\n\n  // Helper function to create a cell respecting the tool toggles\n  const createCellWithToggles = useCallback((x: number, y: number): Cell => {\n    const existingCell = getCell(x, y);\n    const newChar = toolAffectsChar ? selectedChar : (existingCell?.char || ' ');\n    \n    // Only apply color data if the cell will have a character (not just a space)\n    const willHaveChar = newChar !== ' ';\n    const hasExistingChar = existingCell?.char && existingCell.char !== ' ';\n    const shouldApplyColors = willHaveChar || hasExistingChar;\n    \n    return {\n      char: newChar,\n      color: (toolAffectsColor && shouldApplyColors) ? selectedColor : (existingCell?.color || '#FFFFFF'),\n      bgColor: (toolAffectsBgColor && shouldApplyColors) ? selectedBgColor : (existingCell?.bgColor || 'transparent')\n    };\n  }, [toolAffectsChar, toolAffectsColor, toolAffectsBgColor, selectedChar, selectedColor, selectedBgColor, getCell]);\n\n  // Helper function to create a cell with all attributes (for shape tools)\n  const createCellWithAllAttributes = useCallback((): Cell => {\n    return {\n      char: selectedChar,\n      color: selectedColor,\n      bgColor: selectedBgColor\n    };\n  }, [selectedChar, selectedColor, selectedBgColor]);\n\n  // Bresenham line algorithm for drawing lines between two points\n  const getLinePoints = useCallback((x0: number, y0: number, x1: number, y1: number) => {\n    const points: { x: number; y: number }[] = [];\n    \n    const dx = Math.abs(x1 - x0);\n    const dy = Math.abs(y1 - y0);\n    const sx = x0 < x1 ? 1 : -1;\n    const sy = y0 < y1 ? 1 : -1;\n    let err = dx - dy;\n    \n    let x = x0;\n    let y = y0;\n    \n    while (true) {\n      points.push({ x, y });\n      \n      if (x === x1 && y === y1) break;\n      \n      const e2 = 2 * err;\n      if (e2 > -dy) {\n        err -= dy;\n        x += sx;\n      }\n      if (e2 < dx) {\n        err += dx;\n        y += sy;\n      }\n    }\n    \n    return points;\n  }, []);\n\n  // Draw a line between two points using the line algorithm\n  const drawLine = useCallback((x0: number, y0: number, x1: number, y1: number) => {\n    const points = getLinePoints(x0, y0, x1, y1);\n    points.forEach(({ x, y }) => {\n      const newCell = createCellWithToggles(x, y);\n      setCell(x, y, newCell);\n    });\n  }, [getLinePoints, setCell, createCellWithToggles]);\n\n  const applyBrushStroke = useCallback((toolKey: 'pencil' | 'eraser', centerX: number, centerY: number) => {\n    const brush = brushSettings[toolKey];\n    const brushCells = calculateBrushCells(\n      centerX,\n      centerY,\n      brush.size,\n      brush.shape,\n      fontMetrics.aspectRatio\n    );\n\n    if (toolKey === 'eraser') {\n      brushCells.forEach(({ x, y }) => {\n        clearCell(x, y);\n      });\n    } else {\n      brushCells.forEach(({ x, y }) => {\n        const newCell = createCellWithToggles(x, y);\n        setCell(x, y, newCell);\n      });\n    }\n  }, [brushSettings, fontMetrics.aspectRatio, clearCell, createCellWithToggles, setCell]);\n\n  const applyBrushLine = useCallback((toolKey: 'pencil' | 'eraser', x0: number, y0: number, x1: number, y1: number) => {\n    const points = getLinePoints(x0, y0, x1, y1);\n    points.forEach(({ x, y }) => {\n      applyBrushStroke(toolKey, x, y);\n    });\n  }, [getLinePoints, applyBrushStroke]);\n\n  const drawBrushLine = useCallback((x0: number, y0: number, x1: number, y1: number) => {\n    applyBrushLine('pencil', x0, y0, x1, y1);\n  }, [applyBrushLine]);\n\n  const eraseBrushLine = useCallback((x0: number, y0: number, x1: number, y1: number) => {\n    applyBrushLine('eraser', x0, y0, x1, y1);\n  }, [applyBrushLine]);\n\n  const drawAtPosition = useCallback((x: number, y: number, isShiftClick = false, _isFirstStroke = false, toolOverride?: string) => {\n    const toolToUse = toolOverride || activeTool;\n    switch (toolToUse) {\n      case 'pencil': {\n        const brushTool: 'pencil' | 'eraser' = 'pencil';\n        if (isShiftClick && pencilLastPosition) {\n          applyBrushLine(brushTool, pencilLastPosition.x, pencilLastPosition.y, x, y);\n        } else {\n          applyBrushStroke(brushTool, x, y);\n        }\n        \n        // Update position for potential shift+click line drawing\n        setPencilLastPosition({ x, y });\n        break;\n      }\n      case 'eraser': {\n        const brushTool: 'pencil' | 'eraser' = 'eraser';\n        if (isShiftClick && pencilLastPosition) {\n          applyBrushLine(brushTool, pencilLastPosition.x, pencilLastPosition.y, x, y);\n        } else {\n          applyBrushStroke(brushTool, x, y);\n        }\n        // Update last position for eraser too\n        setPencilLastPosition({ x, y });\n        break;\n      }\n      case 'eyedropper': {\n        const existingCell = getCell(x, y);\n        if (existingCell) {\n          pickFromCell(existingCell.char, existingCell.color, existingCell.bgColor);\n        }\n        break;\n      }\n      case 'paintbucket': {\n        const newCell = createCellWithToggles(x, y);\n        fillArea(x, y, newCell, paintBucketContiguous, { char: fillMatchChar, color: fillMatchColor, bgColor: fillMatchBgColor });\n        break;\n      }\n    }\n  }, [\n    activeTool,\n    paintBucketContiguous,\n    getCell,\n    fillArea,\n    pickFromCell,\n    pencilLastPosition,\n    setPencilLastPosition,\n    applyBrushStroke,\n    applyBrushLine,\n    createCellWithToggles,\n    fillMatchChar,\n    fillMatchColor,\n    fillMatchBgColor\n  ]);\n\n  const drawRectangle = useCallback((startX: number, startY: number, endX: number, endY: number) => {\n    const minX = Math.min(startX, endX);\n    const maxX = Math.max(startX, endX);\n    const minY = Math.min(startY, endY);\n    const maxY = Math.max(startY, endY);\n\n    for (let y = minY; y <= maxY; y++) {\n      for (let x = minX; x <= maxX; x++) {\n        // For hollow rectangles, only draw border\n        if (!rectangleFilled) {\n          if (x === minX || x === maxX || y === minY || y === maxY) {\n            const newCell = createCellWithAllAttributes();\n            setCell(x, y, newCell);\n          }\n        } else {\n          // For filled rectangles, draw all cells\n          const newCell = createCellWithAllAttributes();\n          setCell(x, y, newCell);\n        }\n      }\n    }\n  }, [rectangleFilled, setCell, createCellWithAllAttributes]);\n\n  // Helper function to get ellipse points using a simpler approach\n  const getEllipsePoints = useCallback((centerX: number, centerY: number, radiusX: number, radiusY: number, filled: boolean = false) => {\n    const points: Array<{ x: number; y: number }> = [];\n    \n    // Calculate bounding box\n    const minX = Math.floor(centerX - radiusX);\n    const maxX = Math.ceil(centerX + radiusX);\n    const minY = Math.floor(centerY - radiusY);\n    const maxY = Math.ceil(centerY + radiusY);\n    \n    if (filled) {\n      // For filled ellipse, check each point within bounding box\n      for (let y = minY; y <= maxY; y++) {\n        for (let x = minX; x <= maxX; x++) {\n          // Check if point is inside ellipse using ellipse equation\n          const dx = x - centerX;\n          const dy = y - centerY;\n          const distance = (dx * dx) / (radiusX * radiusX) + (dy * dy) / (radiusY * radiusY);\n          \n          if (distance <= 1) {\n            points.push({ x: Math.round(x), y: Math.round(y) });\n          }\n        }\n      }\n    } else {\n      // For hollow ellipse, use a simple approach: check points around the perimeter\n      const numPoints = Math.max(Math.ceil(2 * Math.PI * Math.max(radiusX, radiusY)), 20);\n      \n      for (let i = 0; i < numPoints; i++) {\n        const angle = (2 * Math.PI * i) / numPoints;\n        const x = centerX + radiusX * Math.cos(angle);\n        const y = centerY + radiusY * Math.sin(angle);\n        \n        points.push({ x: Math.round(x), y: Math.round(y) });\n      }\n      \n      // Remove duplicates by using a Set\n      const uniquePoints = Array.from(\n        new Set(points.map(p => `${p.x},${p.y}`))\n      ).map(key => {\n        const [x, y] = key.split(',').map(Number);\n        return { x, y };\n      });\n      \n      return uniquePoints;\n    }\n    \n    return points;\n  }, []);\n\n  const drawEllipse = useCallback((startX: number, startY: number, endX: number, endY: number) => {\n    const centerX = (startX + endX) / 2;\n    const centerY = (startY + endY) / 2;\n    const radiusX = Math.abs(endX - startX) / 2;\n    const radiusY = Math.abs(endY - startY) / 2;\n\n    const points = getEllipsePoints(centerX, centerY, radiusX, radiusY, rectangleFilled);\n    \n    // Draw all the ellipse points\n    points.forEach(({ x, y }) => {\n      if (x >= 0 && y >= 0) { // Basic bounds checking\n        const newCell = createCellWithAllAttributes();\n        setCell(x, y, newCell);\n      }\n    });\n  }, [rectangleFilled, setCell, getEllipsePoints, createCellWithAllAttributes]);\n\n  return {\n    drawAtPosition,\n    drawRectangle,\n    drawEllipse,\n    drawLine, // Export for gap-filling in drag operations\n    drawBrushLine, // Export for brush-aware gap-filling\n    eraseBrushLine, // Export for eraser gap-filling\n    getEllipsePoints, // Export for preview rendering\n    getLinePoints, // Export for line preview rendering\n    activeTool\n  };\n};\n","usedDeprecatedRules":[]},{"filePath":"/Users/cameronfoxly/GitHubRepos/Ascii-Motion/src/hooks/useEffectsHistory.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/cameronfoxly/GitHubRepos/Ascii-Motion/src/hooks/useFlipUtilities.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/cameronfoxly/GitHubRepos/Ascii-Motion/src/hooks/useFrameNavigation.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/cameronfoxly/GitHubRepos/Ascii-Motion/src/hooks/useFrameSynchronization.ts","messages":[{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useEffect has missing dependencies: 'height', 'setCanvasData', and 'width'. Either include them or remove the dependency array.","line":153,"column":6,"nodeType":"ArrayExpression","endLine":153,"endColumn":275,"suggestions":[{"desc":"Update the dependencies array to be: [currentFrameIndex, cells, setFrameData, loadFrameToCanvas, isPlaying, isDraggingFrame, isDeletingFrame, moveStateParam, setMoveStateParam, selection.active, lassoSelection.active, magicWandSelection.active, clearSelection, clearLassoSelection, clearMagicWandSelection, setCanvasData, width, height]","fix":{"range":[5378,5647],"text":"[currentFrameIndex, cells, setFrameData, loadFrameToCanvas, isPlaying, isDraggingFrame, isDeletingFrame, moveStateParam, setMoveStateParam, selection.active, lassoSelection.active, magicWandSelection.active, clearSelection, clearLassoSelection, clearMagicWandSelection, setCanvasData, width, height]"}}]},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useEffect has missing dependencies: 'cells', 'currentFrameIndex', 'getCurrentFrame', and 'setFrameData'. Either include them or remove the dependency array.","line":181,"column":6,"nodeType":"ArrayExpression","endLine":181,"endColumn":8,"suggestions":[{"desc":"Update the dependencies array to be: [cells, currentFrameIndex, getCurrentFrame, setFrameData]","fix":{"range":[6767,6769],"text":"[cells, currentFrameIndex, getCurrentFrame, setFrameData]"}}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useEffect, useCallback, useRef } from 'react';\nimport { useCanvasStore } from '../stores/canvasStore';\nimport { useAnimationStore } from '../stores/animationStore';\nimport { useToolStore } from '../stores/toolStore';\nimport type { Cell } from '../types';\n\n/**\n * Hook that manages synchronization between canvas state and animation frames\n * - Auto-saves canvas changes to current frame\n * - Auto-loads frame data when switching frames\n * - Handles frame switching with proper data persistence\n */\nexport const useFrameSynchronization = (\n  moveStateParam?: { \n    originalData: Map<string, Cell>;\n    originalPositions: Set<string>;\n    startPos: { x: number; y: number };\n    baseOffset: { x: number; y: number };\n    currentOffset: { x: number; y: number };\n  } | null,\n  setMoveStateParam?: React.Dispatch<React.SetStateAction<{ \n    originalData: Map<string, Cell>;\n    originalPositions: Set<string>;\n    startPos: { x: number; y: number };\n    baseOffset: { x: number; y: number };\n    currentOffset: { x: number; y: number };\n  } | null>>\n) => {\n  const { cells, setCanvasData, width, height } = useCanvasStore();\n  const { \n    currentFrameIndex, \n    setFrameData, \n    getFrameData, \n    getCurrentFrame,\n    isPlaying,\n    isDraggingFrame,\n    isDeletingFrame\n  } = useAnimationStore();\n  \n  // Get selection state and clearing functions  \n  const { \n    selection,\n    lassoSelection, \n    magicWandSelection,\n    clearSelection,\n    clearLassoSelection,\n    clearMagicWandSelection\n  } = useToolStore();\n  \n  const lastFrameIndexRef = useRef<number>(currentFrameIndex);\n  const lastCellsRef = useRef<Map<string, Cell>>(new Map());\n  const isLoadingFrameRef = useRef<boolean>(false);\n\n  // Auto-save current canvas to current frame whenever canvas changes\n  const saveCurrentCanvasToFrame = useCallback(() => {\n    if (isLoadingFrameRef.current || isPlaying || isDraggingFrame || isDeletingFrame) return; // Don't save during frame loading, playback, dragging, or deletion\n    \n    // Add small delay to prevent race conditions during frame reordering\n    setTimeout(() => {\n      if (isLoadingFrameRef.current || isPlaying || isDraggingFrame || isDeletingFrame) return;\n      \n      const currentCells = new Map(cells);\n      setFrameData(currentFrameIndex, currentCells);\n      lastCellsRef.current = currentCells;\n    }, 50);\n  }, [cells, currentFrameIndex, setFrameData, isPlaying, isDraggingFrame, isDeletingFrame]);\n\n  // Load frame data into canvas when frame changes\n  const loadFrameToCanvas = useCallback((frameIndex: number) => {\n    isLoadingFrameRef.current = true;\n    \n    const frameData = getFrameData(frameIndex);\n    if (frameData) {\n      setCanvasData(frameData);\n    } else {\n      // If frame has no data, clear canvas\n      setCanvasData(new Map());\n    }\n    \n    // Small delay to ensure canvas update completes\n    setTimeout(() => {\n      isLoadingFrameRef.current = false;\n    }, 0);\n  }, [getFrameData, setCanvasData]);\n\n  // Handle frame switching\n  useEffect(() => {\n    const previousFrameIndex = lastFrameIndexRef.current;\n    \n    if (currentFrameIndex !== previousFrameIndex) {\n      let currentCellsToSave = new Map(cells);\n      \n      // Commit any pending move operations to the original frame before clearing state\n      if (moveStateParam && setMoveStateParam) {\n        const totalOffset = {\n          x: moveStateParam.baseOffset.x + moveStateParam.currentOffset.x,\n          y: moveStateParam.baseOffset.y + moveStateParam.currentOffset.y\n        };\n\n        // Create a new canvas data map with the moved cells\n        const newCells = new Map(cells);\n\n        // Clear original positions\n        const originalKeys = moveStateParam.originalPositions ?? new Set(moveStateParam.originalData.keys());\n        originalKeys.forEach((key) => {\n          newCells.delete(key);\n        });\n\n        // Place cells at new positions\n        moveStateParam.originalData.forEach((cell, key) => {\n          const [origX, origY] = key.split(',').map(Number);\n          const newX = origX + totalOffset.x;\n          const newY = origY + totalOffset.y;\n          \n          // Only place if within bounds\n          if (newX >= 0 && newX < width && newY >= 0 && newY < height) {\n            newCells.set(`${newX},${newY}`, cell);\n          }\n        });\n\n        // Update the cells to save with the committed move\n        currentCellsToSave = newCells;\n        \n        // Update canvas data with committed move\n        setCanvasData(newCells);\n        \n        // Clear move state after committing\n        setMoveStateParam(null);\n      }\n      \n      // Clear all active selections when navigating between frames\n      // This prevents selection content from being copied to the new frame\n      if (selection.active) {\n        clearSelection();\n      }\n      if (lassoSelection.active) {\n        clearLassoSelection();\n      }\n      if (magicWandSelection.active) {\n        clearMagicWandSelection();\n      }\n      \n      // Save current canvas (with committed moves) to the frame we're leaving\n      if (!isPlaying && !isLoadingFrameRef.current && !isDraggingFrame && !isDeletingFrame) {\n        setFrameData(previousFrameIndex, currentCellsToSave);\n      }\n      \n      // Load the new frame's data\n      loadFrameToCanvas(currentFrameIndex);\n      \n      lastFrameIndexRef.current = currentFrameIndex;\n    }\n  }, [currentFrameIndex, cells, setFrameData, loadFrameToCanvas, isPlaying, isDraggingFrame, isDeletingFrame, moveStateParam, setMoveStateParam, selection.active, lassoSelection.active, magicWandSelection.active, clearSelection, clearLassoSelection, clearMagicWandSelection]);\n\n  // Auto-save canvas changes to current frame (debounced)\n  useEffect(() => {\n    if (isLoadingFrameRef.current || isPlaying || isDraggingFrame || isDeletingFrame) return;\n    \n    // Check if cells actually changed to avoid unnecessary saves\n    const currentCellsString = JSON.stringify(Array.from(cells.entries()).sort());\n    const lastCellsString = JSON.stringify(Array.from(lastCellsRef.current.entries()).sort());\n    \n    if (currentCellsString !== lastCellsString) {\n      // Longer delay to prevent interference with drag operations\n      const timeoutId = setTimeout(() => {\n        if (!isLoadingFrameRef.current && !isPlaying) {\n          saveCurrentCanvasToFrame();\n        }\n      }, 150);\n      \n      return () => clearTimeout(timeoutId);\n    }\n  }, [cells, saveCurrentCanvasToFrame, isPlaying, isDraggingFrame, isDeletingFrame]);\n\n  // Initialize first frame with current canvas data if empty\n  useEffect(() => {\n    const currentFrame = getCurrentFrame();\n    if (currentFrame && currentFrame.data.size === 0 && cells.size > 0) {\n      setFrameData(currentFrameIndex, new Map(cells));\n    }\n  }, []); // Only run once on mount\n\n  return {\n    saveCurrentCanvasToFrame,\n    loadFrameToCanvas,\n    isLoadingFrame: isLoadingFrameRef.current\n  };\n};\n","usedDeprecatedRules":[]},{"filePath":"/Users/cameronfoxly/GitHubRepos/Ascii-Motion/src/hooks/useGradientFillTool.ts","messages":[{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useCallback has missing dependencies: 'cellHeight' and 'cellWidth'. Either include them or remove the dependency array.","line":206,"column":6,"nodeType":"ArrayExpression","endLine":219,"endColumn":4,"suggestions":[{"desc":"Update the dependencies array to be: [activeTool, canvasWidth, canvasHeight, isApplying, startPoint, endPoint, previewData, setApplying, cellWidth, cellHeight, setPoints, setHoverEndPoint, generatePreview, applyGradient]","fix":{"range":[6082,6299],"text":"[activeTool, canvasWidth, canvasHeight, isApplying, startPoint, endPoint, previewData, setApplying, cellWidth, cellHeight, setPoints, setHoverEndPoint, generatePreview, applyGradient]"}}]},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useCallback has an unnecessary dependency: 'ellipsePoint'. Either exclude it or remove the dependency array.","line":235,"column":6,"nodeType":"ArrayExpression","endLine":235,"endColumn":101,"suggestions":[{"desc":"Update the dependencies array to be: [activeTool, isApplying, startPoint, endPoint, setHoverEndPoint, generatePreview]","fix":{"range":[6971,7066],"text":"[activeTool, isApplying, startPoint, endPoint, setHoverEndPoint, generatePreview]"}}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { useCallback, useEffect } from 'react';\nimport { useCanvasStore } from '../stores/canvasStore';\nimport { useCanvasContext } from '../contexts/CanvasContext';\nimport { useGradientStore, initializeGradientWithCurrentValues } from '../stores/gradientStore';\nimport { useToolStore } from '../stores/toolStore';\nimport { useAnimationStore } from '../stores/animationStore';\nimport { calculateGradientCells } from '../utils/gradientEngine';\nimport { getGradientFillArea } from '../utils/fillArea';\nimport type { CanvasHistoryAction } from '../types';\n\n/**\n * Custom hook for handling gradient fill tool operations\n * Integrates canvas interaction, fill area detection, gradient calculation, and undo/redo\n */\nexport const useGradientFillTool = () => {\n  const { \n    cells,\n    width: canvasWidth,\n    height: canvasHeight,\n    getCell, \n    setCanvasData \n  } = useCanvasStore();\n  \n  const { cellWidth, cellHeight } = useCanvasContext();\n  \n  const { currentFrameIndex } = useAnimationStore();\n  \n  const { \n    activeTool,\n    selectedChar,\n    selectedColor,\n    selectedBgColor,\n    pushToHistory\n  } = useToolStore();\n  \n  const { \n    isApplying, \n    startPoint, \n    endPoint,\n    ellipsePoint,\n    hoverEndPoint,\n    definition, \n    contiguous, \n    matchChar, \n    matchColor, \n    matchBgColor,\n    previewData,\n    setApplying, \n    setPoints, \n    setHoverEndPoint,\n    setPreview,\n    reset: resetGradient\n  } = useGradientStore();\n  \n  const { isOpen } = useGradientStore();\n  \n  // Initialize gradient with current tool values when tool becomes active\n  // Only initialize if there are no session settings (first time using the tool)\n  // Wait for panel to be open to ensure session settings have been restored first\n  useEffect(() => {\n    if (activeTool === 'gradientfill' && isOpen) {\n      const state = useGradientStore.getState();\n      \n      // Only initialize with current tool values if no session settings exist\n      if (!state.sessionSettings) {\n        initializeGradientWithCurrentValues(selectedChar, selectedColor, selectedBgColor);\n      }\n    }\n  }, [activeTool, isOpen, selectedChar, selectedColor, selectedBgColor]);\n\n  // Generate gradient preview\n  const generatePreview = useCallback((start: { x: number; y: number }, end: { x: number; y: number }) => {\n    try {\n      // Find fill area using gradient matching criteria\n      const fillArea = getGradientFillArea(\n        start.x, \n        start.y,\n        { width: canvasWidth, height: canvasHeight, getCell },\n        { contiguous, matchChar, matchColor, matchBgColor }\n      );\n      \n      if (fillArea.size === 0) {\n        setPreview(null);\n        return;\n      }\n      \n      // Calculate gradient cells\n      const cellAspectRatio = cellWidth / cellHeight;\n      const gradientCells = calculateGradientCells({\n        startPoint: start,\n        endPoint: end,\n        ellipsePoint: ellipsePoint || undefined,\n        definition,\n        fillArea,\n        cellAspectRatio\n      });\n      \n      setPreview(gradientCells);\n    } catch (error) {\n      console.error('Error generating gradient preview:', error);\n      setPreview(null);\n    }\n  }, [\n    canvasWidth,\n    canvasHeight,\n    cellWidth,\n    cellHeight,\n    getCell,\n    contiguous,\n    matchChar,\n    matchColor,\n    matchBgColor,\n    definition,\n    ellipsePoint,\n    setPreview\n  ]);\n  \n  // Apply gradient (Enter key or confirmation click)\n  const applyGradient = useCallback(() => {\n    if (!isApplying || !startPoint || !endPoint || !previewData) {\n      console.warn('Cannot apply gradient: missing required state');\n      return;\n    }\n    \n    try {\n      // Store current canvas state for undo\n      const originalCells = new Map(cells);\n      \n      // Apply gradient to canvas\n      const newCells = new Map(cells);\n      previewData.forEach((cell, key) => {\n        if (cell.char === ' ' && cell.color === '#FFFFFF' && cell.bgColor === 'transparent') {\n          // Remove empty cells to save memory\n          newCells.delete(key);\n        } else {\n          newCells.set(key, { ...cell });\n        }\n      });\n      \n      setCanvasData(newCells);\n      \n      // Add to history for undo/redo\n      const historyAction: CanvasHistoryAction = {\n        type: 'canvas_edit',\n        timestamp: Date.now(),\n        description: `Apply ${definition.type} gradient fill (${previewData.size} cells)`,\n        data: {\n          canvasData: originalCells,\n          frameIndex: currentFrameIndex\n        }\n      };\n      \n      pushToHistory(historyAction);\n      \n      // Reset gradient state\n      resetGradient();\n    } catch (error) {\n      console.error('Error applying gradient:', error);\n      // Reset on error to prevent stuck state\n      resetGradient();\n    }\n  }, [\n    isApplying, \n    startPoint, \n    endPoint, \n    previewData, \n    cells, \n    currentFrameIndex,\n    definition.type,\n    setCanvasData, \n    pushToHistory, \n    resetGradient\n  ]);\n\n  // Handle canvas click during gradient application\n  const handleCanvasClick = useCallback((x: number, y: number) => {\n    if (activeTool !== 'gradientfill') return;\n\n    // Ignore clicks on UI elements or outside canvas bounds\n    if (x < 0 || x >= canvasWidth || y < 0 || y >= canvasHeight) return;\n    \n    if (!isApplying) {\n      // First click - start applying gradient\n      setApplying(true);\n      const cellAspectRatio = cellWidth / cellHeight;\n      setPoints({ x, y }, null, cellAspectRatio);\n      setHoverEndPoint({ x, y });\n      return;\n    }\n    \n    if (startPoint && !endPoint) {\n      // Second click - set end point and generate preview\n      const newEndPoint = { x, y };\n      const cellAspectRatio = cellWidth / cellHeight;\n      setPoints(startPoint, newEndPoint, cellAspectRatio);\n      setHoverEndPoint(null);\n      generatePreview(startPoint, newEndPoint);\n      return;\n    }\n    \n    // If we already have both points, treat this as a confirmation click\n    // (unless it's on a control point - that would be handled by drag logic)\n    if (startPoint && endPoint && previewData) {\n      applyGradient();\n    }\n  }, [\n    activeTool, \n    isApplying, \n    startPoint, \n    endPoint, \n    previewData,\n    canvasWidth,\n    canvasHeight,\n    setApplying, \n    setPoints,\n    setHoverEndPoint,\n    generatePreview,\n    applyGradient\n  ]);\n\n  // Handle mouse move for interactive preview updates\n  const handleCanvasMouseMove = useCallback((x: number, y: number) => {\n    if (activeTool !== 'gradientfill' || !isApplying || !startPoint) return;\n    \n    if (!endPoint) {\n      // Still dragging to set the end point - update preview with current mouse position\n      const currentEndPoint = { x, y };\n      setHoverEndPoint(currentEndPoint);\n      generatePreview(startPoint, currentEndPoint);\n    } else {\n      // Both points are set - allow dragging to adjust them\n      // For now, we'll regenerate preview if definition changes\n      // TODO: Add drag detection for start/end point adjustment\n    }\n  }, [activeTool, isApplying, startPoint, endPoint, ellipsePoint, setHoverEndPoint, generatePreview]);\n\n  // Cancel gradient (Escape key)\n  const cancelGradient = useCallback(() => {\n    if (!isApplying) return;\n    resetGradient();\n  }, [isApplying, resetGradient]);\n\n  // Keyboard event handlers\n  useEffect(() => {\n    const handleKeyDown = (event: KeyboardEvent) => {\n      if (activeTool !== 'gradientfill' || !isApplying) return;\n      \n      // Prevent default browser behavior for our handled keys\n      if (event.key === 'Enter' || event.key === 'Escape') {\n        event.preventDefault();\n        event.stopPropagation();\n        \n        if (event.key === 'Enter') {\n          applyGradient();\n        } else if (event.key === 'Escape') {\n          cancelGradient();\n        }\n      }\n    };\n    \n    // Use capture phase to ensure we handle the event before other handlers\n    window.addEventListener('keydown', handleKeyDown, { capture: true });\n    \n    return () => {\n      window.removeEventListener('keydown', handleKeyDown, { capture: true });\n    };\n  }, [activeTool, isApplying, applyGradient, cancelGradient]);\n  \n  // Reset gradient state when switching tools\n  useEffect(() => {\n    if (activeTool !== 'gradientfill') {\n      resetGradient();\n    }\n  }, [activeTool, resetGradient]);\n\n  // Regenerate preview when gradient definition changes (while both points are set)\n  useEffect(() => {\n    const targetEndPoint = endPoint ?? hoverEndPoint;\n    if (activeTool === 'gradientfill' && isApplying && startPoint && targetEndPoint) {\n      generatePreview(startPoint, targetEndPoint);\n    }\n  }, [activeTool, isApplying, startPoint, endPoint, ellipsePoint, hoverEndPoint, definition, contiguous, matchChar, matchColor, matchBgColor, generatePreview]);\n  \n  // Cleanup on unmount\n  useEffect(() => {\n    return () => {\n      resetGradient();\n    };\n  }, [resetGradient]);\n  \n  return {\n    // State\n    isApplying,\n    startPoint,\n    endPoint,\n  hoverEndPoint,\n    previewData,\n    \n    // Actions\n    handleCanvasClick,\n    handleCanvasMouseMove,\n    applyGradient,\n    cancelGradient,\n    \n    // Computed properties\n    canApply: isApplying && startPoint && endPoint && previewData && previewData.size > 0,\n    fillAreaSize: previewData?.size || 0\n  };\n};","usedDeprecatedRules":[]},{"filePath":"/Users/cameronfoxly/GitHubRepos/Ascii-Motion/src/hooks/useHoverPreview.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/cameronfoxly/GitHubRepos/Ascii-Motion/src/hooks/useKeyboardShortcuts.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":23,"column":16,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":23,"endColumn":19,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1081,1084],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1081,1084],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":24,"column":19,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":24,"endColumn":22,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1104,1107],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1104,1107],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-case-declarations","severity":2,"message":"Unexpected lexical declaration in case block.","line":28,"column":7,"nodeType":"VariableDeclaration","messageId":"unexpected","endLine":28,"endColumn":58,"suggestions":[{"messageId":"addBrackets","fix":{"range":[1170,1433],"text":"{ const canvasAction = action as CanvasHistoryAction;\n      canvasStore.setCanvasData(canvasAction.data.canvasData);\n      // Set current frame to match the frame this edit was made in\n      animationStore.setCurrentFrame(canvasAction.data.frameIndex);\n      break; }"},"desc":"Add {} brackets around the case block."}]},{"ruleId":"no-case-declarations","severity":2,"message":"Unexpected lexical declaration in case block.","line":118,"column":7,"nodeType":"VariableDeclaration","messageId":"unexpected","endLine":118,"endColumn":82,"suggestions":[{"messageId":"addBrackets","fix":{"range":[4412,5809],"text":"{ const effectAction = action as import('../types').ApplyEffectHistoryAction;\n      if (isRedo) {\n        // Redo: Re-apply the effect\n        console.log(`Redo: Re-applying ${effectAction.data.effectType} effect`);\n        // Note: For redo, we would need to re-run the effect processing\n        // This is complex because we'd need to re-apply the effect with the same settings\n        // For now, we'll show a message that redo for effects is not yet implemented\n        console.warn('Redo for effects is not yet implemented - would need to re-apply effect');\n      } else {\n        // Undo: Restore previous data\n        if (effectAction.data.applyToTimeline) {\n          // Restore all affected frames\n          if (effectAction.data.previousFramesData) {\n            effectAction.data.previousFramesData.forEach(({ frameIndex, data }) => {\n              animationStore.setFrameData(frameIndex, data);\n            });\n            console.log(`✅ Undo: Restored ${effectAction.data.previousFramesData.length} frames from ${effectAction.data.effectType} effect`);\n          }\n        } else {\n          // Restore single canvas\n          if (effectAction.data.previousCanvasData) {\n            canvasStore.setCanvasData(effectAction.data.previousCanvasData);\n            console.log(`✅ Undo: Restored canvas from ${effectAction.data.effectType} effect`);\n          }\n        }\n      }\n      break; }"},"desc":"Add {} brackets around the case block."}]},{"ruleId":"no-case-declarations","severity":2,"message":"Unexpected lexical declaration in case block.","line":147,"column":7,"nodeType":"VariableDeclaration","messageId":"unexpected","endLine":147,"endColumn":90,"suggestions":[{"messageId":"addBrackets","fix":{"range":[5847,6645],"text":"{ const timeEffectAction = action as import('../types').ApplyTimeEffectHistoryAction;\n      if (isRedo) {\n        // Redo: Re-apply the time effect\n        console.log(`Redo: Re-applying ${timeEffectAction.data.effectType} time effect`);\n        console.warn('Redo for time effects is not yet implemented - would need to re-apply effect');\n      } else {\n        // Undo: Restore previous frame data\n        if (timeEffectAction.data.previousFramesData) {\n          timeEffectAction.data.previousFramesData.forEach(({ frameIndex, data }) => {\n            animationStore.setFrameData(frameIndex, data);\n          });\n          console.log(`✅ Undo: Restored ${timeEffectAction.data.previousFramesData.length} frames from ${timeEffectAction.data.effectType} time effect`);\n        }\n      }\n      break; }"},"desc":"Add {} brackets around the case block."}]},{"ruleId":"no-case-declarations","severity":2,"message":"Unexpected lexical declaration in case block.","line":164,"column":7,"nodeType":"VariableDeclaration","messageId":"unexpected","endLine":164,"endColumn":91,"suggestions":[{"messageId":"addBrackets","fix":{"range":[6685,7540],"text":"{ const durationsAction = action as import('../types').SetFrameDurationsHistoryAction;\n      if (isRedo) {\n        // Redo: Re-apply the new duration to all affected frames\n        durationsAction.data.affectedFrameIndices.forEach(frameIndex => {\n          animationStore.updateFrameDuration(frameIndex, durationsAction.data.newDuration);\n        });\n        console.log(`✅ Redo: Applied duration ${durationsAction.data.newDuration}ms to ${durationsAction.data.affectedFrameIndices.length} frames`);\n      } else {\n        // Undo: Restore previous durations\n        durationsAction.data.previousDurations.forEach(({ frameIndex, duration }) => {\n          animationStore.updateFrameDuration(frameIndex, duration);\n        });\n        console.log(`✅ Undo: Restored durations for ${durationsAction.data.previousDurations.length} frames`);\n      }\n      break; }"},"desc":"Add {} brackets around the case block."}]},{"ruleId":"no-case-declarations","severity":2,"message":"Unexpected lexical declaration in case block.","line":181,"column":7,"nodeType":"VariableDeclaration","messageId":"unexpected","endLine":181,"endColumn":92,"suggestions":[{"messageId":"addBrackets","fix":{"range":[7579,8357],"text":"{ const deleteRangeAction = action as import('../types').DeleteFrameRangeHistoryAction;\n      if (isRedo) {\n        // Redo: Re-delete the frames\n        animationStore.removeFrameRange(deleteRangeAction.data.frameIndices);\n        console.log(`✅ Redo: Deleted ${deleteRangeAction.data.frameIndices.length} frames`);\n      } else {\n        // Undo: Restore snapshot prior to deletion\n        const { previousFrames, previousCurrentFrame, previousSelection } = deleteRangeAction.data;\n\n        animationStore.replaceFrames(\n          previousFrames,\n          previousCurrentFrame,\n          previousSelection.length > 0 ? previousSelection : undefined\n        );\n\n        console.log(`✅ Undo: Restored ${deleteRangeAction.data.frames.length} deleted frames`);\n      }\n      break; }"},"desc":"Add {} brackets around the case block."}]},{"ruleId":"no-case-declarations","severity":2,"message":"Unexpected lexical declaration in case block.","line":231,"column":7,"nodeType":"VariableDeclaration","messageId":"unexpected","endLine":231,"endColumn":89,"suggestions":[{"messageId":"addBrackets","fix":{"range":[9299,10348],"text":"{ const deleteAllAction = action as import('../types').DeleteAllFramesHistoryAction;\n      if (isRedo) {\n        // Redo: Clear all frames again\n        animationStore.clearAllFrames();\n        console.log('✅ Redo: Cleared all frames');\n      } else {\n        // Undo: Restore all deleted frames\n        deleteAllAction.data.frames.forEach((frame, index) => {\n          if (index === 0) {\n            // Replace the default frame created by clearAllFrames\n            animationStore.setFrameData(0, frame.data);\n            animationStore.updateFrameName(0, frame.name);\n            animationStore.updateFrameDuration(0, frame.duration);\n          } else {\n            // Add additional frames\n            animationStore.addFrame(index, frame.data, frame.duration);\n            animationStore.updateFrameName(index, frame.name);\n          }\n        });\n        \n        animationStore.setCurrentFrame(deleteAllAction.data.previousCurrentFrame);\n        console.log(`✅ Undo: Restored ${deleteAllAction.data.frames.length} frames`);\n      }\n      break; }"},"desc":"Add {} brackets around the case block."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":308,"column":63,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":308,"endColumn":66,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[12440,12443],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[12440,12443],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useCallback has missing dependencies: 'activeTool', 'adjustBrushSize', 'deleteFrameRange', 'duplicateFrameRange', 'flipHorizontal', 'flipVertical', 'navigateCharacterPaletteCharacters', 'navigateFirst', 'navigateLast', 'navigatePaletteColor', 'selectedFrameIndices', and 'swapForegroundBackground'. Either include them or remove the dependency array.","line":1012,"column":6,"nodeType":"ArrayExpression","endLine":1061,"endColumn":4,"suggestions":[{"desc":"Update the dependencies array to be: [pasteMode.isActive, textToolState.isTyping, blockBrowserShortcut, showSaveProjectDialog, showOpenProjectDialog, selection, activeTool, lassoSelection.active, lassoSelection.selectedCells, magicWandSelection.active, magicWandSelection.selectedCells, clearSelection, clearLassoSelection, clearMagicWandSelection, pushCanvasHistory, cells, currentFrameIndex, setCanvasData, navigateCharacterPaletteCharacters, canNavigate, navigateFirst, navigateLast, navigatePaletteColor, flipHorizontal, flipVertical, toggleOnionSkin, adjustBrushSize, zoomIn, zoomOut, navigatePrevious, navigateNext, swapForegroundBackground, setActiveTool, frames.length, selectedFrameIndices, deleteFrameRange, removeFrame, startSelection, updateSelection, width, height, addFrame, duplicateFrameRange, duplicateFrame, copyMagicWandSelection, copyLassoSelection, copySelection, commitPaste, startPasteFromClipboard, canRedo, redo, handleHistoryAction, canUndo, undo]","fix":{"range":[35787,36772],"text":"[pasteMode.isActive, textToolState.isTyping, blockBrowserShortcut, showSaveProjectDialog, showOpenProjectDialog, selection, activeTool, lassoSelection.active, lassoSelection.selectedCells, magicWandSelection.active, magicWandSelection.selectedCells, clearSelection, clearLassoSelection, clearMagicWandSelection, pushCanvasHistory, cells, currentFrameIndex, setCanvasData, navigateCharacterPaletteCharacters, canNavigate, navigateFirst, navigateLast, navigatePaletteColor, flipHorizontal, flipVertical, toggleOnionSkin, adjustBrushSize, zoomIn, zoomOut, navigatePrevious, navigateNext, swapForegroundBackground, setActiveTool, frames.length, selectedFrameIndices, deleteFrameRange, removeFrame, startSelection, updateSelection, width, height, addFrame, duplicateFrameRange, duplicateFrame, copyMagicWandSelection, copyLassoSelection, copySelection, commitPaste, startPasteFromClipboard, canRedo, redo, handleHistoryAction, canUndo, undo]"}}]}],"suppressedMessages":[],"errorCount":9,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { useEffect, useCallback } from 'react';\nimport { useCanvasStore } from '../stores/canvasStore';\nimport { useToolStore } from '../stores/toolStore';\nimport { useAnimationStore } from '../stores/animationStore';\nimport { useCanvasContext } from '../contexts/CanvasContext';\nimport { getToolForHotkey } from '../constants/hotkeys';\nimport { useZoomControls } from '../components/features/ZoomControls';\nimport { useFrameNavigation } from './useFrameNavigation';\nimport { useAnimationHistory } from './useAnimationHistory';\nimport { usePaletteStore } from '../stores/paletteStore';\nimport { useCharacterPaletteStore } from '../stores/characterPaletteStore';\nimport { useFlipUtilities } from './useFlipUtilities';\nimport { useProjectFileActions } from './useProjectFileActions';\nimport { ANSI_COLORS } from '../constants/colors';\nimport type { AnyHistoryAction, CanvasHistoryAction, FrameId } from '../types';\n\n/**\n * Helper function to process different types of history actions\n */\nconst processHistoryAction = (\n  action: AnyHistoryAction, \n  isRedo: boolean,\n  canvasStore: any,\n  animationStore: any\n) => {\n  switch (action.type) {\n    case 'canvas_edit':\n      const canvasAction = action as CanvasHistoryAction;\n      canvasStore.setCanvasData(canvasAction.data.canvasData);\n      // Set current frame to match the frame this edit was made in\n      animationStore.setCurrentFrame(canvasAction.data.frameIndex);\n      break;\n      \n    case 'add_frame':\n      if (isRedo) {\n        // Redo: Re-add the frame\n        animationStore.addFrame(action.data.frameIndex, action.data.canvasData);\n      } else {\n        // Undo: Remove the frame that was added\n        animationStore.removeFrame(action.data.frameIndex);\n        animationStore.setCurrentFrame(action.data.previousCurrentFrame);\n      }\n      break;\n      \n    case 'duplicate_frame':\n      if (isRedo) {\n        // Redo: Re-duplicate the frame\n        animationStore.duplicateFrame(action.data.originalIndex);\n      } else {\n        // Undo: Remove the duplicated frame\n        animationStore.removeFrame(action.data.newIndex);\n        animationStore.setCurrentFrame(action.data.previousCurrentFrame);\n      }\n      break;\n      \n    case 'delete_frame':\n      if (isRedo) {\n        // Redo: Re-delete the frame\n        animationStore.removeFrame(action.data.frameIndex);\n      } else {\n        // Undo: Re-add the deleted frame\n        const deletedFrame = action.data.frame;\n        \n        // Add frame at the correct position\n        animationStore.addFrame(action.data.frameIndex, deletedFrame.data);\n        \n        // Update the frame properties to match the deleted frame\n        animationStore.updateFrameName(action.data.frameIndex, deletedFrame.name);\n        animationStore.updateFrameDuration(action.data.frameIndex, deletedFrame.duration);\n        \n        // Restore previous current frame\n        animationStore.setCurrentFrame(action.data.previousCurrentFrame);\n      }\n      break;\n      \n    case 'reorder_frames':\n      if (isRedo) {\n        // Redo: Re-perform the reorder\n        animationStore.reorderFrames(action.data.fromIndex, action.data.toIndex);\n      } else {\n        // Undo: Reverse the reorder\n        animationStore.reorderFrames(action.data.toIndex, action.data.fromIndex);\n        animationStore.setCurrentFrame(action.data.previousCurrentFrame);\n      }\n      break;\n      \n    case 'update_duration':\n      if (isRedo) {\n        // Redo: Apply new duration\n        animationStore.updateFrameDuration(action.data.frameIndex, action.data.newDuration);\n      } else {\n        // Undo: Restore old duration\n        animationStore.updateFrameDuration(action.data.frameIndex, action.data.oldDuration);\n      }\n      break;\n      \n    case 'update_name':\n      if (isRedo) {\n        // Redo: Apply new name\n        animationStore.updateFrameName(action.data.frameIndex, action.data.newName);\n      } else {\n        // Undo: Restore old name\n        animationStore.updateFrameName(action.data.frameIndex, action.data.oldName);\n      }\n      break;\n      \n    case 'navigate_frame':\n      if (isRedo) {\n        // Redo: Go to the new frame index\n        animationStore.setCurrentFrame(action.data.newFrameIndex);\n      } else {\n        // Undo: Go back to the previous frame index\n        animationStore.setCurrentFrame(action.data.previousFrameIndex);\n      }\n      break;\n      \n    case 'apply_effect':\n      const effectAction = action as import('../types').ApplyEffectHistoryAction;\n      if (isRedo) {\n        // Redo: Re-apply the effect\n        console.log(`Redo: Re-applying ${effectAction.data.effectType} effect`);\n        // Note: For redo, we would need to re-run the effect processing\n        // This is complex because we'd need to re-apply the effect with the same settings\n        // For now, we'll show a message that redo for effects is not yet implemented\n        console.warn('Redo for effects is not yet implemented - would need to re-apply effect');\n      } else {\n        // Undo: Restore previous data\n        if (effectAction.data.applyToTimeline) {\n          // Restore all affected frames\n          if (effectAction.data.previousFramesData) {\n            effectAction.data.previousFramesData.forEach(({ frameIndex, data }) => {\n              animationStore.setFrameData(frameIndex, data);\n            });\n            console.log(`✅ Undo: Restored ${effectAction.data.previousFramesData.length} frames from ${effectAction.data.effectType} effect`);\n          }\n        } else {\n          // Restore single canvas\n          if (effectAction.data.previousCanvasData) {\n            canvasStore.setCanvasData(effectAction.data.previousCanvasData);\n            console.log(`✅ Undo: Restored canvas from ${effectAction.data.effectType} effect`);\n          }\n        }\n      }\n      break;\n\n    case 'apply_time_effect':\n      const timeEffectAction = action as import('../types').ApplyTimeEffectHistoryAction;\n      if (isRedo) {\n        // Redo: Re-apply the time effect\n        console.log(`Redo: Re-applying ${timeEffectAction.data.effectType} time effect`);\n        console.warn('Redo for time effects is not yet implemented - would need to re-apply effect');\n      } else {\n        // Undo: Restore previous frame data\n        if (timeEffectAction.data.previousFramesData) {\n          timeEffectAction.data.previousFramesData.forEach(({ frameIndex, data }) => {\n            animationStore.setFrameData(frameIndex, data);\n          });\n          console.log(`✅ Undo: Restored ${timeEffectAction.data.previousFramesData.length} frames from ${timeEffectAction.data.effectType} time effect`);\n        }\n      }\n      break;\n\n    case 'set_frame_durations':\n      const durationsAction = action as import('../types').SetFrameDurationsHistoryAction;\n      if (isRedo) {\n        // Redo: Re-apply the new duration to all affected frames\n        durationsAction.data.affectedFrameIndices.forEach(frameIndex => {\n          animationStore.updateFrameDuration(frameIndex, durationsAction.data.newDuration);\n        });\n        console.log(`✅ Redo: Applied duration ${durationsAction.data.newDuration}ms to ${durationsAction.data.affectedFrameIndices.length} frames`);\n      } else {\n        // Undo: Restore previous durations\n        durationsAction.data.previousDurations.forEach(({ frameIndex, duration }) => {\n          animationStore.updateFrameDuration(frameIndex, duration);\n        });\n        console.log(`✅ Undo: Restored durations for ${durationsAction.data.previousDurations.length} frames`);\n      }\n      break;\n\n    case 'delete_frame_range':\n      const deleteRangeAction = action as import('../types').DeleteFrameRangeHistoryAction;\n      if (isRedo) {\n        // Redo: Re-delete the frames\n        animationStore.removeFrameRange(deleteRangeAction.data.frameIndices);\n        console.log(`✅ Redo: Deleted ${deleteRangeAction.data.frameIndices.length} frames`);\n      } else {\n        // Undo: Restore snapshot prior to deletion\n        const { previousFrames, previousCurrentFrame, previousSelection } = deleteRangeAction.data;\n\n        animationStore.replaceFrames(\n          previousFrames,\n          previousCurrentFrame,\n          previousSelection.length > 0 ? previousSelection : undefined\n        );\n\n        console.log(`✅ Undo: Restored ${deleteRangeAction.data.frames.length} deleted frames`);\n      }\n      break;\n\n    case 'duplicate_frame_range': {\n      const duplicateRangeAction = action as import('../types').DuplicateFrameRangeHistoryAction;\n      const {\n        previousFrames,\n        newFrames,\n        previousSelection,\n        newSelection,\n        previousCurrentFrame,\n        newCurrentFrame,\n        originalFrameIndices\n      } = duplicateRangeAction.data;\n\n      if (isRedo) {\n        animationStore.replaceFrames(\n          newFrames,\n          newCurrentFrame,\n          newSelection.length > 0 ? newSelection : undefined\n        );\n        console.log(`🔁 Redo: Duplicated ${originalFrameIndices.length} frame(s)`);\n      } else {\n        animationStore.replaceFrames(\n          previousFrames,\n          previousCurrentFrame,\n          previousSelection.length > 0 ? previousSelection : undefined\n        );\n        console.log(`↩️ Undo: Removed duplicated frames`);\n      }\n      break;\n    }\n\n    case 'delete_all_frames':\n      const deleteAllAction = action as import('../types').DeleteAllFramesHistoryAction;\n      if (isRedo) {\n        // Redo: Clear all frames again\n        animationStore.clearAllFrames();\n        console.log('✅ Redo: Cleared all frames');\n      } else {\n        // Undo: Restore all deleted frames\n        deleteAllAction.data.frames.forEach((frame, index) => {\n          if (index === 0) {\n            // Replace the default frame created by clearAllFrames\n            animationStore.setFrameData(0, frame.data);\n            animationStore.updateFrameName(0, frame.name);\n            animationStore.updateFrameDuration(0, frame.duration);\n          } else {\n            // Add additional frames\n            animationStore.addFrame(index, frame.data, frame.duration);\n            animationStore.updateFrameName(index, frame.name);\n          }\n        });\n        \n        animationStore.setCurrentFrame(deleteAllAction.data.previousCurrentFrame);\n        console.log(`✅ Undo: Restored ${deleteAllAction.data.frames.length} frames`);\n      }\n      break;\n\n    case 'reorder_frame_range': {\n      const reorderRangeAction = action as import('../types').ReorderFrameRangeHistoryAction;\n      const {\n        frameIndices,\n        targetIndex,\n        previousCurrentFrame,\n        newCurrentFrame,\n        movedFrameIds,\n        previousSelectionFrameIds,\n        newSelectionFrameIds\n      } = reorderRangeAction.data;\n\n      const findIndicesForIds = (ids: FrameId[]) => {\n        const { frames } = useAnimationStore.getState();\n        return ids\n          .map((id) => frames.findIndex((frame) => frame.id === id))\n          .filter((idx) => idx >= 0)\n          .sort((a, b) => a - b);\n      };\n\n      const setSelectionByIds = (ids: FrameId[]) => {\n        if (ids.length === 0) {\n          useAnimationStore.setState({ selectedFrameIndices: new Set<number>() });\n          return;\n        }\n        const indices = findIndicesForIds(ids);\n        if (indices.length === 0) return;\n        useAnimationStore.setState({ selectedFrameIndices: new Set(indices) });\n      };\n\n      if (isRedo) {\n        const currentPositions = findIndicesForIds(movedFrameIds);\n        if (currentPositions.length === movedFrameIds.length) {\n          animationStore.reorderFrameRange(currentPositions, targetIndex);\n        }\n        setSelectionByIds(newSelectionFrameIds);\n        useAnimationStore.getState().setCurrentFrameOnly(newCurrentFrame);\n        console.log(`🔁 Redo: Reordered ${movedFrameIds.length} frame(s)`);\n      } else {\n        const currentPositions = findIndicesForIds(movedFrameIds);\n        if (currentPositions.length === movedFrameIds.length) {\n          const originalTarget = Math.min(...frameIndices);\n          animationStore.reorderFrameRange(currentPositions, originalTarget);\n        }\n        setSelectionByIds(previousSelectionFrameIds);\n        useAnimationStore.getState().setCurrentFrameOnly(previousCurrentFrame);\n        console.log(`↩️ Undo: Restored ${movedFrameIds.length} frame(s) to original positions`);\n      }\n      break;\n    }\n      \n    default:\n      console.warn('Unknown history action type:', (action as any).type);\n  }\n};\n\n/**\n * Custom hook for handling keyboard shortcuts\n * \n * Frame Navigation:\n * - Comma (,) - Previous frame\n * - Period (.) - Next frame\n * \n * Frame Management:\n * - Ctrl+N - Add new frame after current frame\n * - Ctrl+Delete - Delete current frame (if more than one frame exists)\n * \n * Other shortcuts:\n * - Tool hotkeys (P, E, G, M, L, W, etc.)\n * - Canvas operations (Cmd/Ctrl+A, C, V, Z)\n * - Zoom (+/-, =)\n */\nexport const useKeyboardShortcuts = () => {\n  const { cells, setCanvasData, width, height } = useCanvasStore();\n  const { startPasteMode, commitPaste, pasteMode } = useCanvasContext();\n  const { toggleOnionSkin, currentFrameIndex, frames, selectedFrameIndices } = useAnimationStore();\n  const { zoomIn, zoomOut } = useZoomControls();\n  const { showSaveProjectDialog, showOpenProjectDialog } = useProjectFileActions();\n  \n  // Frame navigation and management hooks\n  const { navigateNext, navigatePrevious, navigateFirst, navigateLast, canNavigate } = useFrameNavigation();\n  const { addFrame, removeFrame, duplicateFrame, duplicateFrameRange, deleteFrameRange } = useAnimationHistory();\n  \n  // Flip utilities for Shift+H and Shift+V\n  const { flipHorizontal, flipVertical } = useFlipUtilities();\n\n  // Helper function to handle different types of history actions\n  const handleHistoryAction = useCallback((action: AnyHistoryAction, isRedo: boolean) => {\n    processHistoryAction(action, isRedo, { setCanvasData }, useAnimationStore.getState());\n  }, [setCanvasData]);\n  const { \n    selection, \n    lassoSelection,\n    magicWandSelection,\n    copySelection, \n    copyLassoSelection,\n    copyMagicWandSelection,\n    pasteSelection,\n    clearSelection,\n    clearLassoSelection,\n    clearMagicWandSelection,\n    startSelection,\n    updateSelection,\n    undo,\n    redo,\n    canUndo,\n    canRedo,\n    pushCanvasHistory,\n    activeTool,\n    setActiveTool,\n    hasClipboard,\n    hasLassoClipboard,\n    hasMagicWandClipboard,\n    getClipboardOriginalPosition,\n    getLassoClipboardOriginalPosition,\n    getMagicWandClipboardOriginalPosition,\n    textToolState\n  } = useToolStore();\n\n  const startPasteFromClipboard = useCallback(() => {\n    const {\n      activeClipboardType,\n      clipboard,\n      lassoClipboard,\n      magicWandClipboard,\n      getClipboardOriginalPosition: getRectOrigin,\n      getLassoClipboardOriginalPosition: getLassoOrigin,\n      getMagicWandClipboardOriginalPosition: getMagicOrigin\n    } = useToolStore.getState();\n\n    const priority: Array<'magicwand' | 'lasso' | 'rectangle'> = [];\n    if (activeClipboardType) {\n      priority.push(activeClipboardType);\n    }\n    priority.push('magicwand', 'lasso', 'rectangle');\n\n    const seen = new Set<string>();\n\n    const ensureStarted = (origin: { x: number; y: number } | null | undefined) => {\n      const fallbackPosition = origin || { x: 0, y: 0 };\n      return startPasteMode(fallbackPosition);\n    };\n\n    for (const type of priority) {\n      if (seen.has(type)) {\n        continue;\n      }\n      seen.add(type);\n\n      switch (type) {\n        case 'magicwand': {\n          if (magicWandClipboard && magicWandClipboard.size > 0) {\n            if (ensureStarted(getMagicOrigin())) {\n              return true;\n            }\n          }\n          break;\n        }\n        case 'lasso': {\n          if (lassoClipboard && lassoClipboard.size > 0) {\n            if (ensureStarted(getLassoOrigin())) {\n              return true;\n            }\n          }\n          break;\n        }\n        case 'rectangle': {\n          if (clipboard && clipboard.size > 0) {\n            if (ensureStarted(getRectOrigin())) {\n              return true;\n            }\n          }\n          break;\n        }\n      }\n    }\n\n    return false;\n  }, [startPasteMode]);\n\n  // Helper function to swap foreground/background colors\n  const swapForegroundBackground = useCallback(() => {\n    const { selectedColor, selectedBgColor, setSelectedColor, setSelectedBgColor } = useToolStore.getState();\n    const { addRecentColor } = usePaletteStore.getState();\n    \n    const tempColor = selectedColor;\n    \n    // Handle edge case: never allow transparent as foreground color\n    if (selectedBgColor === 'transparent' || selectedBgColor === ANSI_COLORS.transparent) {\n      // Background becomes current foreground color\n      setSelectedBgColor(tempColor);\n      // Foreground stays the same (no transparent characters allowed)\n    } else {\n      // Normal swap\n      setSelectedColor(selectedBgColor);\n      setSelectedBgColor(tempColor);\n    }\n    \n    // Add both colors to recent colors (only if they're not transparent)\n    if (selectedBgColor !== 'transparent' && selectedBgColor !== ANSI_COLORS.transparent) {\n      addRecentColor(selectedBgColor);\n    }\n    if (tempColor !== 'transparent' && tempColor !== ANSI_COLORS.transparent) {\n      addRecentColor(tempColor);\n    }\n  }, []);\n\n  // Helper function to navigate palette colors\n  const navigatePaletteColor = useCallback((direction: 'previous' | 'next') => {\n    const { getActiveColors, selectedColorId, setSelectedColor: setSelectedColorId } = usePaletteStore.getState();\n    const { setSelectedColor, setSelectedBgColor } = useToolStore.getState();\n    \n    // Determine if we're in background tab context by checking the active tab in the ColorPicker\n    // Look for the active background tab using multiple strategies\n    let isBackgroundTab = false;\n    \n    // Strategy 1: Look for Radix UI tabs trigger with various attribute combinations\n    const backgroundTabQueries = [\n      'button[data-state=\"active\"][data-value=\"bg\"]',\n      '[data-state=\"active\"][value=\"bg\"]', \n      'button[aria-selected=\"true\"][value=\"bg\"]',\n      '[role=\"tab\"][aria-selected=\"true\"][value=\"bg\"]',\n      '[data-radix-collection-item][data-state=\"active\"][value=\"bg\"]'\n    ];\n    \n    for (const query of backgroundTabQueries) {\n      if (document.querySelector(query)) {\n        isBackgroundTab = true;\n        break;\n      }\n    }\n    \n    // Strategy 2: If no direct match, look for any tab with \"BG\" text content that's active\n    if (!isBackgroundTab) {\n      const activeTabs = document.querySelectorAll('[data-state=\"active\"], [aria-selected=\"true\"]');\n      isBackgroundTab = Array.from(activeTabs).some(tab => \n        tab.textContent?.includes('BG') || tab.textContent?.includes('Background')\n      );\n    }\n    \n    const activeColors = getActiveColors();\n    if (activeColors.length === 0) return;\n    \n    // Filter colors based on context (foreground = no transparent, background = include transparent)\n    const availableColors = isBackgroundTab \n      ? [{ id: 'transparent', value: 'transparent', name: 'Transparent' }, ...activeColors.filter(c => c.value !== 'transparent' && c.value !== ANSI_COLORS.transparent)]\n      : activeColors.filter(c => c.value !== 'transparent' && c.value !== ANSI_COLORS.transparent);\n      \n    if (availableColors.length === 0) return;\n    \n    let newIndex = 0;\n    \n    if (selectedColorId) {\n      // Find current index\n      const currentIndex = availableColors.findIndex(c => c.id === selectedColorId);\n      if (currentIndex !== -1) {\n        // Navigate with loop-around\n        if (direction === 'next') {\n          newIndex = (currentIndex + 1) % availableColors.length;\n        } else {\n          newIndex = currentIndex === 0 ? availableColors.length - 1 : currentIndex - 1;\n        }\n      }\n    }\n    // If no selection, default to first color (newIndex = 0)\n    \n    const newColor = availableColors[newIndex];\n    setSelectedColorId(newColor.id);\n    \n    // Set the drawing color\n    if (isBackgroundTab) {\n      setSelectedBgColor(newColor.value);\n    } else {\n      setSelectedColor(newColor.value);\n    }\n    \n    // Add to recent colors if not transparent\n    if (newColor.value !== 'transparent' && newColor.value !== ANSI_COLORS.transparent) {\n      const { addRecentColor } = usePaletteStore.getState();\n      addRecentColor(newColor.value);\n    }\n  }, []);\n\n  const adjustBrushSize = useCallback((direction: 'decrease' | 'increase') => {\n    const { activeTool, brushSettings, setBrushSize } = useToolStore.getState();\n    if (activeTool !== 'pencil' && activeTool !== 'eraser') {\n      return;\n    }\n\n    const currentSize = brushSettings[activeTool].size;\n    const delta = direction === 'increase' ? 1 : -1;\n    const newSize = Math.max(1, Math.min(20, currentSize + delta));\n\n    if (newSize !== currentSize) {\n      setBrushSize(newSize, activeTool);\n    }\n  }, []);\n\n  const navigateCharacterPaletteCharacters = useCallback((direction: 'previous' | 'next') => {\n    const { activePalette } = useCharacterPaletteStore.getState();\n    const { selectedChar, setSelectedChar } = useToolStore.getState();\n\n    const characters = activePalette?.characters ?? [];\n    if (characters.length === 0) {\n      return;\n    }\n\n    const total = characters.length;\n    const currentIndex = selectedChar ? characters.findIndex(char => char === selectedChar) : -1;\n\n    let targetIndex: number;\n    if (direction === 'next') {\n      targetIndex = currentIndex === -1 ? 0 : (currentIndex + 1) % total;\n    } else {\n      targetIndex = currentIndex === -1 ? total - 1 : (currentIndex - 1 + total) % total;\n    }\n\n    const nextCharacter = characters[targetIndex];\n    if (typeof nextCharacter === 'string' && nextCharacter.length > 0) {\n      setSelectedChar(nextCharacter);\n    }\n  }, []);\n\n  const blockBrowserShortcut = useCallback((event: KeyboardEvent) => {\n    event.preventDefault();\n    event.stopPropagation();\n    if (typeof event.stopImmediatePropagation === 'function') {\n      event.stopImmediatePropagation();\n    }\n    (event as unknown as { returnValue?: boolean }).returnValue = false;\n  }, []);\n\n  const handleKeyDown = useCallback((event: KeyboardEvent) => {\n    // If any modal dialog is open, disable all keyboard shortcuts\n    // Check for shadcn/ui dialogs that are actually open and visible\n    const openDialogs = Array.from(document.querySelectorAll('[role=\"dialog\"]')).filter(dialog => {\n      const style = window.getComputedStyle(dialog);\n      return style.display !== 'none' && style.visibility !== 'hidden' && style.opacity !== '0';\n    });\n    \n    if (openDialogs.length > 0) {\n      return;\n    }\n\n    const isModifierPressed = event.metaKey || event.ctrlKey;\n    const normalizedKey = typeof event.key === 'string' ? event.key.toLowerCase() : '';\n\n    if (isModifierPressed && !event.altKey && !event.shiftKey) {\n      if (normalizedKey === 's') {\n        blockBrowserShortcut(event);\n        showSaveProjectDialog();\n        return;\n      }\n\n      if (normalizedKey === 'o') {\n        blockBrowserShortcut(event);\n        showOpenProjectDialog();\n        return;\n      }\n    }\n\n    // If paste mode is active, let paste mode handle its own keyboard events (except Ctrl/Cmd+V to commit)\n    if (pasteMode.isActive && !(isModifierPressed && normalizedKey === 'v')) {\n      return;\n    }\n\n    // If any input field is focused, block specific canvas hotkeys that conflict with typing\n    // But allow text editing shortcuts (Cmd+A, arrow keys, etc.) to work normally\n    const activeElement = document.activeElement as HTMLElement;\n    const isInputFocused = activeElement && (\n      activeElement.tagName === 'INPUT' ||\n      activeElement.tagName === 'TEXTAREA' ||\n      activeElement.contentEditable === 'true' ||\n      activeElement.getAttribute('role') === 'textbox'\n    );\n    \n    if (isInputFocused) {\n      // Allow all modifier-based shortcuts (Cmd+A, Cmd+C, etc.) - these are text editing commands\n      if (isModifierPressed) {\n        return; // Let the input field handle text editing shortcuts\n      }\n      \n      // Allow navigation keys that are essential for text editing\n      const allowedKeys = [\n        'Escape', 'Tab', 'Enter', 'Backspace', 'Delete',\n        'ArrowLeft', 'ArrowRight', 'ArrowUp', 'ArrowDown',\n        'Home', 'End', 'PageUp', 'PageDown'\n      ];\n      \n      if (allowedKeys.includes(event.key)) {\n        // For Escape, still handle our canvas logic after the input handles it\n        if (event.key === 'Escape') {\n          // Don't return yet - let canvas logic handle Escape below\n        } else {\n          return; // Let the input field handle navigation keys\n        }\n      } else {\n        // Block tool hotkeys and other single-key shortcuts that conflict with typing\n        // This includes letters (b, p, e, etc.), numbers, space, etc.\n        return;\n      }\n    }\n\n    // If text tool is actively typing, only allow Escape and modifier-based shortcuts\n    // This prevents conflicts with single-key tool hotkeys and the space bar\n    if (textToolState.isTyping && !isModifierPressed && event.key !== 'Escape') {\n      return; // Let the text tool handle all other keys\n    }\n\n    // Handle Escape key (without modifier)\n    if (event.key === 'Escape') {\n      // Let CanvasGrid handle Escape when selection tool is active (for move commits)\n      if (selection.active && activeTool !== 'select') {\n        event.preventDefault();\n        clearSelection();\n      }\n      if (lassoSelection.active && activeTool !== 'lasso') {\n        event.preventDefault();\n        clearLassoSelection();\n      }\n      if (magicWandSelection.active && activeTool !== 'magicwand') {\n        event.preventDefault();\n        clearMagicWandSelection();\n      }\n      const animationStore = useAnimationStore.getState();\n      if (animationStore.selectedFrameIndices.size > 1) {\n        animationStore.clearSelection();\n      }\n      return;\n    }\n\n    // Handle Delete/Backspace key (without modifier) - Clear selected cells\n    if ((event.key === 'Delete' || event.key === 'Backspace') && !isModifierPressed) {\n      // Check if any selection is active and clear the selected cells\n      if (magicWandSelection.active && magicWandSelection.selectedCells.size > 0) {\n        event.preventDefault();\n        \n        // Save current state for undo\n        pushCanvasHistory(new Map(cells), currentFrameIndex, 'Delete magic wand selection');\n        \n        // Clear all selected cells\n        const newCells = new Map(cells);\n        magicWandSelection.selectedCells.forEach(cellKey => {\n          newCells.delete(cellKey);\n        });\n        setCanvasData(newCells);\n        \n        // Clear the selection after deleting content\n        clearMagicWandSelection();\n        return;\n      }\n      \n      if (lassoSelection.active && lassoSelection.selectedCells.size > 0) {\n        event.preventDefault();\n        \n        // Save current state for undo\n        pushCanvasHistory(new Map(cells), currentFrameIndex, 'Delete lasso selection');\n        \n        // Clear all selected cells\n        const newCells = new Map(cells);\n        lassoSelection.selectedCells.forEach(cellKey => {\n          newCells.delete(cellKey);\n        });\n        setCanvasData(newCells);\n        \n        // Clear the selection after deleting content\n        clearLassoSelection();\n        return;\n      }\n      \n      if (selection.active) {\n        event.preventDefault();\n        \n        // Save current state for undo\n        pushCanvasHistory(new Map(cells), currentFrameIndex, 'Delete rectangular selection');\n        \n        // Clear all cells in rectangular selection\n        const newCells = new Map(cells);\n        const { start, end } = selection;\n        const minX = Math.min(start.x, end.x);\n        const maxX = Math.max(start.x, end.x);\n        const minY = Math.min(start.y, end.y);\n        const maxY = Math.max(start.y, end.y);\n        \n        for (let y = minY; y <= maxY; y++) {\n          for (let x = minX; x <= maxX; x++) {\n            const cellKey = `${x},${y}`;\n            newCells.delete(cellKey);\n          }\n        }\n        setCanvasData(newCells);\n        \n        // Clear the selection after deleting content\n        clearSelection();\n        return;\n      }\n    }\n\n    const isBracketLeft = event.code === 'BracketLeft' || event.key === '[' || event.key === '{';\n    const isBracketRight = event.code === 'BracketRight' || event.key === ']' || event.key === '}';\n\n    if (isModifierPressed && !event.altKey && !event.shiftKey) {\n      if (isBracketLeft) {\n        event.preventDefault();\n        navigateCharacterPaletteCharacters('previous');\n        return;\n      }\n\n      if (isBracketRight) {\n        event.preventDefault();\n        navigateCharacterPaletteCharacters('next');\n        return;\n      }\n    }\n\n    // Handle shift-modified hotkeys (first/last frame, palette colors, flip utilities, onion skinning)\n    if (event.shiftKey && !event.metaKey && !event.ctrlKey && !event.altKey) {\n      const isShiftComma = event.key === '<' || event.code === 'Comma';\n      const isShiftPeriod = event.key === '>' || event.code === 'Period';\n\n      if (canNavigate && isShiftComma) {\n        event.preventDefault();\n        navigateFirst();\n        return;\n      }\n\n      if (canNavigate && isShiftPeriod) {\n        event.preventDefault();\n        navigateLast();\n        return;\n      }\n\n      if (isBracketLeft) {\n        event.preventDefault();\n        navigatePaletteColor('previous');\n        return;\n      }\n\n      if (isBracketRight) {\n        event.preventDefault();\n        navigatePaletteColor('next');\n        return;\n      }\n\n      if (event.key === 'H' || event.key === 'h') {\n        event.preventDefault();\n        flipHorizontal();\n        return;\n      }\n      if (event.key === 'V' || event.key === 'v') {\n        event.preventDefault();\n        flipVertical();\n        return;\n      }\n      if (event.key === 'O' || event.key === 'o') {\n        event.preventDefault();\n        toggleOnionSkin();\n        return;\n      }\n    }\n\n    // Handle tool hotkeys (single key presses for tool switching)\n    // Only process if no modifier keys are pressed and key is a valid tool hotkey\n    if (!event.metaKey && !event.ctrlKey && !event.altKey && !event.shiftKey) {\n      if (isBracketLeft) {\n        event.preventDefault();\n        adjustBrushSize('decrease');\n        return;\n      }\n\n      if (isBracketRight) {\n        event.preventDefault();\n        adjustBrushSize('increase');\n        return;\n      }\n\n      // Handle zoom hotkeys\n      if (event.key === '+' || event.key === '=') {\n        event.preventDefault();\n        zoomIn();\n        return;\n      }\n      if (event.key === '-') {\n        event.preventDefault();\n        zoomOut();\n        return;\n      }\n      \n      // Handle frame navigation shortcuts (comma and period keys)\n      if (event.key === ',' && canNavigate) {\n        event.preventDefault();\n        navigatePrevious();\n        return;\n      }\n      if (event.key === '.' && canNavigate) {\n        event.preventDefault();\n        navigateNext();\n        return;\n      }\n      \n      // Handle color hotkeys\n      if (event.key === 'x') {\n        // Swap foreground/background colors using existing logic\n        event.preventDefault();\n        swapForegroundBackground();\n        return;\n      }\n      \n      if (event.key === '[') {\n        // Previous palette color\n        event.preventDefault();\n        navigatePaletteColor('previous');\n        return;\n      }\n      \n      if (event.key === ']') {\n        // Next palette color\n        event.preventDefault();\n        navigatePaletteColor('next');\n        return;\n      }\n      \n      const targetTool = getToolForHotkey(event.key);\n      if (targetTool) {\n        event.preventDefault();\n        setActiveTool(targetTool);\n        return;\n      }\n    }\n\n    // Check for modifier keys (Cmd on Mac, Ctrl on Windows/Linux)\n    if (!isModifierPressed) return;\n    \n    // Handle Ctrl+Delete or Ctrl+Backspace for frame deletion (before the switch statement)\n    if ((event.key === 'Delete' || event.key === 'Backspace') && isModifierPressed) {\n      if (frames.length > 1) {\n        event.preventDefault();\n        \n        // Check if multiple frames are selected\n        const selectedFrames = Array.from(selectedFrameIndices).sort((a, b) => a - b);\n        \n        if (selectedFrames.length > 1) {\n          // Batch delete all selected frames\n          deleteFrameRange(selectedFrames);\n        } else {\n          // Single frame delete\n          removeFrame(currentFrameIndex);\n        }\n      }\n      return;\n    }\n\n    switch (normalizedKey) {\n      case 'n':\n        // Ctrl+N = Add new frame after current frame\n        if (!event.shiftKey) {\n          event.preventDefault();\n          addFrame(currentFrameIndex + 1);\n        }\n        break;\n        \n      case 'd':\n        // Ctrl+D = Duplicate current frame\n        if (!event.shiftKey) {\n          event.preventDefault();\n          const selectedFrames = Array.from(selectedFrameIndices).sort((a, b) => a - b);\n          if (selectedFrames.length > 1) {\n            duplicateFrameRange(selectedFrames);\n          } else {\n            duplicateFrame(currentFrameIndex);\n          }\n        }\n        break;\n\n        \n      case 'a':\n        // Select All - activate selection tool and select entire canvas\n        event.preventDefault();\n        \n        // Switch to selection tool if not already active\n        if (activeTool !== 'select') {\n          setActiveTool('select');\n        }\n        \n        // Clear any existing selections\n        clearSelection();\n        clearLassoSelection();\n        clearMagicWandSelection();\n        \n        // Create a selection that covers the entire canvas\n        // Canvas coordinates go from 0,0 to width-1,height-1\n        startSelection(0, 0);\n        updateSelection(width - 1, height - 1);\n        break;\n        \n      case 'c':\n        // Copy selection (prioritize magic wand, then lasso, then rectangular)\n        if (magicWandSelection.active) {\n          event.preventDefault();\n          copyMagicWandSelection(cells);\n        } else if (lassoSelection.active) {\n          event.preventDefault();\n          copyLassoSelection(cells);\n        } else if (selection.active) {\n          event.preventDefault();\n          copySelection(cells);\n        }\n        break;\n        \n      case 'v':\n        // Enhanced paste with preview mode\n        event.preventDefault();\n        \n        // If already in paste mode, commit the paste\n        if (pasteMode.isActive) {\n          const pastedData = commitPaste();\n          if (pastedData) {\n            // Save current state for undo\n            pushCanvasHistory(new Map(cells), currentFrameIndex, 'Paste lasso selection');\n            \n            // Merge pasted data with current canvas\n            const newCells = new Map(cells);\n            pastedData.forEach((cell, key) => {\n              newCells.set(key, cell);\n            });\n            \n            setCanvasData(newCells);\n          }\n        } else {\n          startPasteFromClipboard();\n        }\n        break;\n        \n      case 'z':\n        // Undo/Redo with enhanced history support\n        if (event.shiftKey) {\n          // Shift+Cmd+Z = Redo\n          if (canRedo()) {\n            event.preventDefault();\n            const redoAction = redo();\n            if (redoAction) {\n              handleHistoryAction(redoAction, true);\n            }\n          }\n        } else {\n          // Cmd+Z = Undo\n          if (canUndo()) {\n            event.preventDefault();\n            const undoAction = undo();\n            if (undoAction) {\n              handleHistoryAction(undoAction, false);\n            }\n          }\n        }\n        break;\n    }\n  }, [\n    cells, \n    width,\n    height,\n    selection, \n    lassoSelection,\n    magicWandSelection,\n    copySelection, \n    copyLassoSelection,\n    copyMagicWandSelection,\n    pasteSelection, \n    clearSelection,\n    clearLassoSelection,\n    clearMagicWandSelection,\n    startSelection,\n    updateSelection,\n    pushCanvasHistory, \n    setCanvasData,\n    undo,\n    redo,\n    canUndo,\n    canRedo,\n    handleHistoryAction,\n    startPasteMode,\n    commitPaste,\n    pasteMode,\n    hasClipboard,\n    hasLassoClipboard,\n    hasMagicWandClipboard,\n  getClipboardOriginalPosition,\n  getLassoClipboardOriginalPosition,\n  getMagicWandClipboardOriginalPosition,\n  startPasteFromClipboard,\n    textToolState,\n    setActiveTool,\n    toggleOnionSkin,\n    currentFrameIndex,\n    frames,\n    zoomIn,\n    zoomOut,\n    navigateNext,\n    navigatePrevious,\n    canNavigate,\n    addFrame,\n    removeFrame,\n    duplicateFrame,\n    showSaveProjectDialog,\n    showOpenProjectDialog,\n    blockBrowserShortcut\n  ]);\n\n  const handleShortcutKeyPress = useCallback((event: KeyboardEvent) => {\n    if ((event.metaKey || event.ctrlKey) && !event.altKey && !event.shiftKey) {\n      const normalizedKey = typeof event.key === 'string' ? event.key.toLowerCase() : '';\n      if (normalizedKey === 's' || normalizedKey === 'o') {\n        blockBrowserShortcut(event);\n      }\n    }\n  }, [blockBrowserShortcut]);\n\n  useEffect(() => {\n    if (typeof window === 'undefined') {\n      return;\n    }\n\n    window.addEventListener('keydown', handleKeyDown, true);\n    window.addEventListener('keypress', handleShortcutKeyPress, true);\n    return () => {\n      window.removeEventListener('keydown', handleKeyDown, true);\n      window.removeEventListener('keypress', handleShortcutKeyPress, true);\n    };\n  }, [handleKeyDown, handleShortcutKeyPress]);\n\n  return {\n    // Expose functions for UI buttons\n    copySelection: () => {\n      if (magicWandSelection.active) {\n        copyMagicWandSelection(cells);\n      } else if (lassoSelection.active) {\n        copyLassoSelection(cells);\n      } else if (selection.active) {\n        copySelection(cells);\n      }\n    },\n    pasteSelection: () => {\n      // If already in paste mode, commit the paste\n      if (pasteMode.isActive) {\n        const pastedData = commitPaste();\n        if (pastedData) {\n          pushCanvasHistory(new Map(cells), currentFrameIndex, 'Paste selection');\n          const newCells = new Map(cells);\n          pastedData.forEach((cell, key) => {\n            newCells.set(key, cell);\n          });\n          setCanvasData(newCells);\n        }\n      } else {\n        startPasteFromClipboard();\n      }\n    }\n  };\n};\n","usedDeprecatedRules":[]},{"filePath":"/Users/cameronfoxly/GitHubRepos/Ascii-Motion/src/hooks/useLayoutState.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/cameronfoxly/GitHubRepos/Ascii-Motion/src/hooks/useMemoizedGrid.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/cameronfoxly/GitHubRepos/Ascii-Motion/src/hooks/useOnionSkinRenderer.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/cameronfoxly/GitHubRepos/Ascii-Motion/src/hooks/useOptimizedRender.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/cameronfoxly/GitHubRepos/Ascii-Motion/src/hooks/usePasteMode.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":6,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":6,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[219,222],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[219,222],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":89,"column":76,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":89,"endColumn":79,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2389,2392],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2389,2392],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":224,"column":40,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":224,"endColumn":43,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5985,5988],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5985,5988],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-case-declarations","severity":2,"message":"Unexpected lexical declaration in case block.","line":285,"column":11,"nodeType":"VariableDeclaration","messageId":"unexpected","endLine":285,"endColumn":27,"suggestions":[{"messageId":"addBrackets","fix":{"range":[7541,8588],"text":"{ event.preventDefault();\n          event.stopPropagation();\n          \n          // Calculate arrow direction offset\n          let offsetX = 0;\n          let offsetY = 0;\n          \n          switch (event.key) {\n            case 'ArrowUp':\n              offsetY = -1;\n              break;\n            case 'ArrowDown':\n              offsetY = 1;\n              break;\n            case 'ArrowLeft':\n              offsetX = -1;\n              break;\n            case 'ArrowRight':\n              offsetX = 1;\n              break;\n          }\n          \n          // Update paste preview position\n          setPasteMode(prev => {\n            if (!prev.preview) return prev;\n            \n            const newPosition = {\n              x: prev.preview.position.x + offsetX,\n              y: prev.preview.position.y + offsetY\n            };\n            \n            return {\n              ...prev,\n              preview: {\n                ...prev.preview,\n                position: newPosition\n              }\n            };\n          });\n          break; }"},"desc":"Add {} brackets around the case block."}]},{"ruleId":"no-case-declarations","severity":2,"message":"Unexpected lexical declaration in case block.","line":286,"column":11,"nodeType":"VariableDeclaration","messageId":"unexpected","endLine":286,"endColumn":27,"suggestions":[{"messageId":"addBrackets","fix":{"range":[7541,8588],"text":"{ event.preventDefault();\n          event.stopPropagation();\n          \n          // Calculate arrow direction offset\n          let offsetX = 0;\n          let offsetY = 0;\n          \n          switch (event.key) {\n            case 'ArrowUp':\n              offsetY = -1;\n              break;\n            case 'ArrowDown':\n              offsetY = 1;\n              break;\n            case 'ArrowLeft':\n              offsetX = -1;\n              break;\n            case 'ArrowRight':\n              offsetX = 1;\n              break;\n          }\n          \n          // Update paste preview position\n          setPasteMode(prev => {\n            if (!prev.preview) return prev;\n            \n            const newPosition = {\n              x: prev.preview.position.x + offsetX,\n              y: prev.preview.position.y + offsetY\n            };\n            \n            return {\n              ...prev,\n              preview: {\n                ...prev.preview,\n                position: newPosition\n              }\n            };\n          });\n          break; }"},"desc":"Add {} brackets around the case block."}]}],"suppressedMessages":[],"errorCount":5,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { useCallback, useEffect, useState } from 'react';\nimport { useToolStore } from '../stores/toolStore';\nimport { useCanvasStore } from '../stores/canvasStore';\n\nexport interface PastePreview {\n  data: Map<string, any>;\n  position: { x: number; y: number };\n  bounds: {\n    minX: number;\n    maxX: number;\n    minY: number;\n    maxY: number;\n  };\n}\n\nexport interface PasteModeState {\n  isActive: boolean;\n  preview: PastePreview | null;\n  isDragging: boolean;\n  dragOffset?: { x: number; y: number };\n  isPlaced: boolean; // Tracks if the preview has been \"placed\" by user interaction\n}\n\n/**\n * Hook for managing enhanced paste mode with visual preview and positioning\n */\nexport const usePasteMode = () => {\n  const { \n    hasClipboard, \n    clipboard, \n    lassoClipboard, \n    hasLassoClipboard, \n    magicWandClipboard,\n    hasMagicWandClipboard,\n    clearSelection, \n    clearLassoSelection,\n    clearMagicWandSelection,\n    activeClipboardType\n  } = useToolStore();\n  const { cells, setCanvasData } = useCanvasStore();\n  const [pasteMode, setPasteMode] = useState<PasteModeState>({\n    isActive: false,\n    preview: null,\n    isDragging: false,\n    isPlaced: false\n  });\n\n  // Get the active clipboard data (prioritize magic wand, then lasso, then regular clipboard)\n  const getActiveClipboard = useCallback(() => {\n    const priority: Array<'magicwand' | 'lasso' | 'rectangle'> = [];\n    if (activeClipboardType) {\n      priority.push(activeClipboardType);\n    }\n    priority.push('magicwand', 'lasso', 'rectangle');\n\n    const seen = new Set<string>();\n\n    for (const type of priority) {\n      if (seen.has(type)) {\n        continue;\n      }\n      seen.add(type);\n\n      switch (type) {\n        case 'magicwand':\n          if (hasMagicWandClipboard() && magicWandClipboard) {\n            return magicWandClipboard;\n          }\n          break;\n        case 'lasso':\n          if (hasLassoClipboard() && lassoClipboard) {\n            return lassoClipboard;\n          }\n          break;\n        case 'rectangle':\n          if (clipboard) {\n            return clipboard;\n          }\n          break;\n      }\n    }\n\n    return null;\n  }, [activeClipboardType, hasMagicWandClipboard, magicWandClipboard, hasLassoClipboard, lassoClipboard, clipboard]);\n\n  /**\n   * Calculate bounds of clipboard data\n   */\n  const calculateClipboardBounds = useCallback((clipboardData: Map<string, any>) => {\n    if (!clipboardData || clipboardData.size === 0) {\n      return { minX: 0, maxX: 0, minY: 0, maxY: 0 };\n    }\n\n    const coords = Array.from(clipboardData.keys()).map(key => {\n      const [x, y] = key.split(',').map(Number);\n      return { x, y };\n    });\n\n    const minX = Math.min(...coords.map(c => c.x));\n    const maxX = Math.max(...coords.map(c => c.x));\n    const minY = Math.min(...coords.map(c => c.y));\n    const maxY = Math.max(...coords.map(c => c.y));\n\n    return { minX, maxX, minY, maxY };\n  }, []);\n\n  /**\n   * Start paste mode - show preview at specified position\n   */\n  const startPasteMode = useCallback((initialPosition: { x: number; y: number }) => {\n    if (!hasClipboard() && !hasLassoClipboard() && !hasMagicWandClipboard()) {\n      return false;\n    }\n\n    const activeClipboard = getActiveClipboard();\n    if (!activeClipboard) {\n      return false;\n    }\n\n    // Clear any existing selections when entering paste mode\n    clearSelection();\n    clearLassoSelection();\n    clearMagicWandSelection();\n\n    const bounds = calculateClipboardBounds(activeClipboard);\n    \n    setPasteMode({\n      isActive: true,\n      preview: {\n        data: new Map(activeClipboard),\n        position: initialPosition,\n        bounds\n      },\n      isDragging: false,\n      dragOffset: undefined,\n      isPlaced: false\n    });\n\n    return true;\n  }, [hasClipboard, hasLassoClipboard, hasMagicWandClipboard, getActiveClipboard, clearSelection, clearLassoSelection, clearMagicWandSelection, calculateClipboardBounds]);\n\n  /**\n   * Update paste preview position\n   */\n  const updatePastePosition = useCallback((mousePosition: { x: number; y: number }) => {\n    setPasteMode(prev => {\n      if (!prev.isActive || !prev.preview) return prev;\n\n      // When dragging, apply the drag offset to maintain relative positioning\n      if (prev.isDragging && prev.dragOffset) {\n        const newPosition = {\n          x: mousePosition.x - prev.dragOffset.x,\n          y: mousePosition.y - prev.dragOffset.y\n        };\n\n        return {\n          ...prev,\n          preview: {\n            ...prev.preview,\n            position: newPosition\n          }\n        };\n      }\n\n      // When not dragging, don't update position (preview stays where it was placed)\n      return prev;\n    });\n  }, []);\n\n  /**\n   * Start dragging the paste preview\n   */\n  const startPasteDrag = useCallback((clickPosition: { x: number; y: number }) => {\n    setPasteMode(prev => {\n      if (!prev.isActive || !prev.preview) return prev;\n      \n      // Calculate offset between click position and current preview position\n      const dragOffset = {\n        x: clickPosition.x - prev.preview.position.x,\n        y: clickPosition.y - prev.preview.position.y\n      };\n      \n      return {\n        ...prev,\n        isDragging: true,\n        dragOffset\n      };\n    });\n  }, []);\n\n  /**\n   * Stop dragging the paste preview\n   */\n  const stopPasteDrag = useCallback(() => {\n    setPasteMode(prev => ({\n      ...prev,\n      isDragging: false,\n      dragOffset: undefined\n    }));\n  }, []);\n\n  /**\n   * Cancel paste mode without committing\n   */\n  const cancelPasteMode = useCallback(() => {\n    setPasteMode({\n      isActive: false,\n      preview: null,\n      isDragging: false,\n      dragOffset: undefined,\n      isPlaced: false\n    });\n  }, []);\n\n  /**\n   * Commit paste at current preview position\n   */\n  const commitPaste = useCallback(() => {\n    if (!pasteMode.isActive || !pasteMode.preview) {\n      return null;\n    }\n\n    const { data, position } = pasteMode.preview;\n    const pastedData = new Map<string, any>();\n\n    // Transform clipboard data to absolute positions\n    data.forEach((cell, relativeKey) => {\n      const [relX, relY] = relativeKey.split(',').map(Number);\n      const absoluteKey = `${position.x + relX},${position.y + relY}`;\n      pastedData.set(absoluteKey, cell);\n    });\n\n    // Clear paste mode\n    cancelPasteMode();\n\n    return pastedData;\n  }, [pasteMode, cancelPasteMode]);\n\n  /**\n   * Commit paste and apply to canvas - used for keyboard shortcuts\n   */\n  const commitPasteToCanvas = useCallback(() => {\n    if (!pasteMode.isActive || !pasteMode.preview) {\n      return false;\n    }\n\n    const pastedData = commitPaste();\n    if (pastedData) {\n      // Apply the paste to canvas\n      const currentCells = new Map(cells);\n      pastedData.forEach((cell, key) => {\n        currentCells.set(key, cell);\n      });\n      setCanvasData(currentCells);\n      return true;\n    }\n    return false;\n  }, [pasteMode, commitPaste, cells, setCanvasData]);\n\n  /**\n   * Handle keyboard shortcuts for paste mode\n   */\n  useEffect(() => {\n    const handleKeyDown = (event: KeyboardEvent) => {\n      if (!pasteMode.isActive || !pasteMode.preview) return;\n\n      switch (event.key) {\n        case 'Escape':\n          event.preventDefault();\n          cancelPasteMode();\n          break;\n        case 'Enter':\n          event.preventDefault();\n          // Commit paste and apply to canvas\n          commitPasteToCanvas();\n          break;\n        case 'ArrowUp':\n        case 'ArrowDown':\n        case 'ArrowLeft':\n        case 'ArrowRight':\n          event.preventDefault();\n          event.stopPropagation();\n          \n          // Calculate arrow direction offset\n          let offsetX = 0;\n          let offsetY = 0;\n          \n          switch (event.key) {\n            case 'ArrowUp':\n              offsetY = -1;\n              break;\n            case 'ArrowDown':\n              offsetY = 1;\n              break;\n            case 'ArrowLeft':\n              offsetX = -1;\n              break;\n            case 'ArrowRight':\n              offsetX = 1;\n              break;\n          }\n          \n          // Update paste preview position\n          setPasteMode(prev => {\n            if (!prev.preview) return prev;\n            \n            const newPosition = {\n              x: prev.preview.position.x + offsetX,\n              y: prev.preview.position.y + offsetY\n            };\n            \n            return {\n              ...prev,\n              preview: {\n                ...prev.preview,\n                position: newPosition\n              }\n            };\n          });\n          break;\n      }\n    };\n\n    window.addEventListener('keydown', handleKeyDown);\n    return () => window.removeEventListener('keydown', handleKeyDown);\n  }, [pasteMode.isActive, pasteMode.preview, cancelPasteMode, commitPasteToCanvas]);\n\n  return {\n    // State\n    pasteMode,\n    isInPasteMode: pasteMode.isActive,\n    pastePreview: pasteMode.preview,\n    isPasteDragging: pasteMode.isDragging,\n\n    // Actions\n    startPasteMode,\n    updatePastePosition,\n    startPasteDrag,\n    stopPasteDrag,\n    cancelPasteMode,\n    commitPaste\n  };\n};\n","usedDeprecatedRules":[]},{"filePath":"/Users/cameronfoxly/GitHubRepos/Ascii-Motion/src/hooks/useProjectFileActions.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/cameronfoxly/GitHubRepos/Ascii-Motion/src/hooks/useTextTool.ts","messages":[{"ruleId":"prefer-const","severity":2,"message":"'targetX' is never reassigned. Use 'const' instead.","line":159,"column":9,"nodeType":"Identifier","messageId":"useConst","endLine":159,"endColumn":16,"fix":{"range":[5977,5997],"text":"const targetX = x - 1;"}},{"ruleId":"prefer-const","severity":2,"message":"'targetY' is never reassigned. Use 'const' instead.","line":160,"column":9,"nodeType":"Identifier","messageId":"useConst","endLine":160,"endColumn":16,"fix":{"range":[6002,6018],"text":"const targetY = y;"}}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":2,"fixableWarningCount":0,"source":"import { useCallback, useEffect, useRef } from 'react';\nimport { useToolStore } from '../stores/toolStore';\nimport { useCanvasStore } from '../stores/canvasStore';\nimport { useAnimationStore } from '../stores/animationStore';\n\n/**\n * Text Tool Hook - Handles text input functionality\n * \n * Features:\n * - Click to place cursor and start typing\n * - Arrow key navigation with boundary constraints\n * - Enter key for new lines (moves to line start)\n * - Backspace with line boundary stopping\n * - Word-based undo batching\n * - Purple blinking cursor animation\n * - Clipboard paste support with overwrite behavior\n */\nexport const useTextTool = () => {\n  const { textToolState, startTyping, stopTyping, setCursorPosition, setCursorVisible, setTextBuffer, commitWord, pushCanvasHistory } = useToolStore();\n  const { width, height, setCell, getCell, cells } = useCanvasStore();\n  const { currentFrameIndex } = useAnimationStore();\n  const { selectedColor, selectedBgColor } = useToolStore();\n  \n  const blinkTimerRef = useRef<NodeJS.Timeout | null>(null);\n  const wordBoundaryChars = useRef(new Set([' ', '\\t', '\\n', '.', ',', ';', ':', '!', '?', '\"', \"'\", '(', ')', '[', ']', '{', '}', '<', '>', '/', '\\\\', '|', '@', '#', '$', '%', '^', '&', '*', '+', '=', '-', '_', '~', '`']));\n\n  // Helper function to create a cell with all attributes for text tool\n  const createTextCellWithAllAttributes = useCallback((newChar: string): { char: string, color: string, bgColor: string } => {\n    // Only apply color data if the character is not just a space\n    const shouldApplyColors = newChar !== ' ';\n    \n    return {\n      char: newChar,\n      color: shouldApplyColors ? selectedColor : '#FFFFFF',\n      bgColor: shouldApplyColors ? selectedBgColor : 'transparent'\n    };\n  }, [selectedColor, selectedBgColor]);\n\n  // Cursor blink animation\n  useEffect(() => {\n    if (textToolState.isTyping && textToolState.cursorPosition) {\n      // Clear any existing timer\n      if (blinkTimerRef.current) {\n        clearInterval(blinkTimerRef.current);\n      }\n      \n      // Start blinking animation (500ms interval)\n      blinkTimerRef.current = setInterval(() => {\n        setCursorVisible(!textToolState.cursorVisible);\n      }, 500);\n      \n      return () => {\n        if (blinkTimerRef.current) {\n          clearInterval(blinkTimerRef.current);\n        }\n      };\n    }\n  }, [textToolState.isTyping, textToolState.cursorPosition, setCursorVisible, textToolState.cursorVisible]);\n\n  // Reset cursor to visible when moving\n  const resetCursorBlink = useCallback(() => {\n    setCursorVisible(true);\n    if (blinkTimerRef.current) {\n      clearInterval(blinkTimerRef.current);\n      blinkTimerRef.current = setInterval(() => {\n        setCursorVisible(!textToolState.cursorVisible);\n      }, 500);\n    }\n  }, [setCursorVisible, textToolState.cursorVisible]);\n\n  // Check if character is a word boundary\n  const isWordBoundary = useCallback((char: string) => {\n    return wordBoundaryChars.current.has(char);\n  }, []);\n\n  // Commit current word to undo stack\n  const commitCurrentWord = useCallback(() => {\n    if (textToolState.textBuffer.length > 0) {\n      pushCanvasHistory(cells, currentFrameIndex);\n      commitWord();\n    }\n  }, [textToolState.textBuffer.length, pushCanvasHistory, commitWord, cells, currentFrameIndex]);\n\n  // Move cursor with boundary constraints\n  const moveCursor = useCallback((deltaX: number, deltaY: number) => {\n    if (!textToolState.cursorPosition) return;\n\n    const { x, y } = textToolState.cursorPosition;\n    let newX = x + deltaX;\n    let newY = y + deltaY;\n\n    // Boundary constraints - stop at edges\n    newX = Math.max(0, Math.min(width - 1, newX));\n    newY = Math.max(0, Math.min(height - 1, newY));\n\n    // Don't move if we're at the boundary\n    if (newX !== x + deltaX || newY !== y + deltaY) {\n      return; // Hit boundary, don't move\n    }\n\n    setCursorPosition(newX, newY);\n    resetCursorBlink();\n  }, [textToolState.cursorPosition, width, height, setCursorPosition, resetCursorBlink]);\n\n  // Insert character at cursor position\n  const insertCharacter = useCallback((char: string) => {\n    if (!textToolState.cursorPosition) return;\n\n    const { x, y } = textToolState.cursorPosition;\n    \n    // Check if character causes word boundary - commit current word if so\n    if (isWordBoundary(char)) {\n      commitCurrentWord();\n    }\n\n    // Insert character using selected colors\n    const newCell = createTextCellWithAllAttributes(char);\n    setCell(x, y, newCell);\n\n    // Add to text buffer for undo batching\n    setTextBuffer(textToolState.textBuffer + char);\n\n    // Move cursor right, respecting canvas boundaries\n    const newX = x + 1;\n    if (newX < width) {\n      setCursorPosition(newX, y);\n      resetCursorBlink();\n    }\n    // If at right edge, don't move cursor (content extends beyond canvas)\n  }, [textToolState.cursorPosition, textToolState.textBuffer, isWordBoundary, commitCurrentWord, setCell, setTextBuffer, width, setCursorPosition, resetCursorBlink, createTextCellWithAllAttributes]);\n\n  // Handle Enter key - move to next line at line start\n  const handleEnter = useCallback(() => {\n    if (!textToolState.cursorPosition) return;\n\n    const { y } = textToolState.cursorPosition;\n    const newY = y + 1;\n\n    // Commit current word\n    commitCurrentWord();\n\n    // Move to next line at lineStartX, respecting boundaries\n    if (newY < height) {\n      setCursorPosition(textToolState.lineStartX, newY);\n      resetCursorBlink();\n    }\n    // If at bottom edge, don't move cursor\n  }, [textToolState.cursorPosition, textToolState.lineStartX, height, commitCurrentWord, setCursorPosition, resetCursorBlink]);\n\n  // Handle Backspace - delete previous character with line boundary stopping\n  const handleBackspace = useCallback(() => {\n    if (!textToolState.cursorPosition) return;\n\n    const { x, y } = textToolState.cursorPosition;\n    \n    // Can't backspace at position (0, 0)\n    if (x === 0 && y === 0) return;\n\n    let targetX = x - 1;\n    let targetY = y;\n\n    // If at beginning of line, stop (don't wrap to previous line)\n    if (x === 0) {\n      return;\n    }\n\n    // Get the character we're about to delete\n    const cellToDelete = getCell(targetX, targetY);\n    \n    // If deleting a word boundary character, commit current word\n    if (cellToDelete && isWordBoundary(cellToDelete.char)) {\n      commitCurrentWord();\n    }\n\n    // Clear the cell\n    const newCell = createTextCellWithAllAttributes(' ');\n    setCell(targetX, targetY, newCell);\n\n    // Move cursor to deleted position\n    setCursorPosition(targetX, targetY);\n    resetCursorBlink();\n\n    // Update text buffer (remove last character)\n    const newBuffer = textToolState.textBuffer.slice(0, -1);\n    setTextBuffer(newBuffer);\n  }, [textToolState.cursorPosition, textToolState.textBuffer, getCell, isWordBoundary, commitCurrentWord, setCell, setCursorPosition, resetCursorBlink, setTextBuffer, createTextCellWithAllAttributes]);\n\n  // Handle clipboard paste\n  const handlePaste = useCallback(async () => {\n    if (!textToolState.cursorPosition) return;\n\n    try {\n      const clipboardText = await navigator.clipboard.readText();\n      if (!clipboardText) return;\n\n      const { x: startX, y: startY } = textToolState.cursorPosition;\n      let currentX = startX;\n      let currentY = startY;\n\n      // Commit current word before pasting\n      commitCurrentWord();\n\n      // Process each character in clipboard\n      for (const char of clipboardText) {\n        if (char === '\\n' || char === '\\r') {\n          // Handle line breaks - move to next line at lineStartX\n          currentY++;\n          currentX = textToolState.lineStartX;\n          \n          // Stop if we reach bottom boundary\n          if (currentY >= height) break;\n        } else {\n          // Insert character if within bounds\n          if (currentX < width && currentY < height) {\n            const newCell = createTextCellWithAllAttributes(char);\n            setCell(currentX, currentY, newCell);\n            currentX++;\n          }\n          // Continue processing even if beyond width (content extends beyond canvas)\n        }\n      }\n\n      // Position cursor at end of pasted content\n      if (currentY < height) {\n        const finalX = Math.min(currentX, width - 1);\n        setCursorPosition(finalX, currentY);\n        resetCursorBlink();\n      }\n\n      // Commit paste as single undo operation\n      pushCanvasHistory(cells, currentFrameIndex);\n\n    } catch (error) {\n      console.error('Failed to read clipboard:', error);\n    }\n  }, [textToolState.cursorPosition, textToolState.lineStartX, width, height, commitCurrentWord, setCell, setCursorPosition, resetCursorBlink, pushCanvasHistory, cells, currentFrameIndex, createTextCellWithAllAttributes]);\n\n  // Click to place cursor\n  const handleTextToolClick = useCallback((x: number, y: number) => {\n    // Commit current word if switching positions\n    if (textToolState.isTyping) {\n      commitCurrentWord();\n    }\n\n    startTyping(x, y);\n    resetCursorBlink();\n  }, [textToolState.isTyping, commitCurrentWord, startTyping, resetCursorBlink]);\n\n  // Handle keyboard input\n  const handleTextToolKeyDown = useCallback((event: KeyboardEvent) => {\n    if (!textToolState.isTyping) return;\n\n    // Prevent default for keys we handle\n    const handledKeys = ['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', 'Enter', 'Backspace', 'Escape'];\n    if (handledKeys.includes(event.key)) {\n      event.preventDefault();\n    }\n\n    switch (event.key) {\n      case 'ArrowLeft':\n        moveCursor(-1, 0);\n        break;\n      case 'ArrowRight':\n        moveCursor(1, 0);\n        break;\n      case 'ArrowUp':\n        moveCursor(0, -1);\n        break;\n      case 'ArrowDown':\n        moveCursor(0, 1);\n        break;\n      case 'Enter':\n        handleEnter();\n        break;\n      case 'Backspace':\n        handleBackspace();\n        break;\n      case 'Escape':\n        commitCurrentWord();\n        stopTyping();\n        break;\n      default:\n        // Handle regular character input\n        if (event.key.length === 1 && !event.ctrlKey && !event.metaKey) {\n          event.preventDefault();\n          insertCharacter(event.key);\n        }\n        // Handle Ctrl/Cmd+V for paste\n        else if ((event.ctrlKey || event.metaKey) && event.key === 'v') {\n          event.preventDefault();\n          handlePaste();\n        }\n        break;\n    }\n  }, [textToolState.isTyping, moveCursor, handleEnter, handleBackspace, commitCurrentWord, stopTyping, insertCharacter, handlePaste]);\n\n  // Cleanup on unmount\n  useEffect(() => {\n    return () => {\n      if (blinkTimerRef.current) {\n        clearInterval(blinkTimerRef.current);\n      }\n    };\n  }, []);\n\n  return {\n    // State\n    isTyping: textToolState.isTyping,\n    cursorPosition: textToolState.cursorPosition,\n    cursorVisible: textToolState.cursorVisible,\n    textBuffer: textToolState.textBuffer,\n    \n    // Actions\n    handleTextToolClick,\n    handleTextToolKeyDown,\n    commitCurrentWord,\n    \n    // Utilities\n    isWordBoundary\n  };\n};\n","usedDeprecatedRules":[]},{"filePath":"/Users/cameronfoxly/GitHubRepos/Ascii-Motion/src/hooks/useTimeEffectsHistory.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/cameronfoxly/GitHubRepos/Ascii-Motion/src/hooks/useToolBehavior.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/cameronfoxly/GitHubRepos/Ascii-Motion/src/lib/figletClient.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/cameronfoxly/GitHubRepos/Ascii-Motion/src/lib/utils.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/cameronfoxly/GitHubRepos/Ascii-Motion/src/main.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/cameronfoxly/GitHubRepos/Ascii-Motion/src/stores/animationStore.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/cameronfoxly/GitHubRepos/Ascii-Motion/src/stores/asciiTypeStore.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/cameronfoxly/GitHubRepos/Ascii-Motion/src/stores/canvasStore.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/cameronfoxly/GitHubRepos/Ascii-Motion/src/stores/characterPaletteStore.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/cameronfoxly/GitHubRepos/Ascii-Motion/src/stores/effectsStore.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":89,"column":48,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":89,"endColumn":51,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3072,3075],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3072,3075],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Effects Store - Zustand store for managing effects system state\n * \n * Features:\n * - Effects panel state (open/closed, active effect)\n * - Effect settings for all supported effects\n * - Canvas analysis caching for performance\n * - Timeline targeting toggle\n * - Integration with existing stores for apply/preview operations\n */\n\nimport { create } from 'zustand';\nimport type { \n  EffectType, \n  LevelsEffectSettings, \n  HueSaturationEffectSettings, \n  RemapColorsEffectSettings, \n  RemapCharactersEffectSettings,\n  CanvasAnalysis\n} from '../types/effects';\nimport { \n  DEFAULT_LEVELS_SETTINGS,\n  DEFAULT_HUE_SATURATION_SETTINGS,\n  DEFAULT_REMAP_COLORS_SETTINGS,\n  DEFAULT_REMAP_CHARACTERS_SETTINGS,\n  CANVAS_ANALYSIS\n} from '../constants/effectsDefaults';\nimport { useCanvasStore } from './canvasStore';\nimport { usePreviewStore } from './previewStore';\nimport { processEffect } from '../utils/effectsProcessing';\n\nexport interface EffectsState {\n  // UI State\n  isOpen: boolean;                           // Main effects panel visibility\n  activeEffect: EffectType | null;           // Currently open effect panel\n  applyToTimeline: boolean;                  // Timeline vs canvas targeting\n  \n  // Effect Settings State\n  levelsSettings: LevelsEffectSettings;\n  hueSaturationSettings: HueSaturationEffectSettings;\n  remapColorsSettings: RemapColorsEffectSettings;\n  remapCharactersSettings: RemapCharactersEffectSettings;\n  \n  // Canvas Analysis State\n  canvasAnalysis: CanvasAnalysis | null;     // Cached analysis results\n  isAnalyzing: boolean;                      // Analysis in progress\n  \n  // Preview State\n  isPreviewActive: boolean;                  // Live preview enabled\n  previewEffect: EffectType | null;          // Effect being previewed\n  \n  // Error State\n  lastError: string | null;                  // Last error message\n  \n  // Actions - Panel Management\n  openEffectPanel: (effect: EffectType) => void;\n  closeEffectPanel: () => void;\n  setApplyToTimeline: (apply: boolean) => void;\n  \n  // Actions - Effect Settings\n  updateLevelsSettings: (settings: Partial<LevelsEffectSettings>) => void;\n  updateHueSaturationSettings: (settings: Partial<HueSaturationEffectSettings>) => void;\n  updateRemapColorsSettings: (settings: Partial<RemapColorsEffectSettings>) => void;\n  updateRemapCharactersSettings: (settings: Partial<RemapCharactersEffectSettings>) => void;\n  resetEffectSettings: (effect: EffectType) => void;\n  \n  // Actions - Canvas Analysis\n  analyzeCanvas: () => Promise<void>;\n  clearAnalysisCache: () => void;\n  getUniqueColors: () => string[];\n  getUniqueCharacters: () => string[];\n  \n  // Actions - Preview Management\n  startPreview: (effect: EffectType) => void;\n  stopPreview: () => void;\n  updatePreview: () => Promise<void>;\n  \n  // Actions - Effect Application\n  applyEffect: (effect: EffectType) => Promise<boolean>;\n  \n  // Actions - Error Management\n  clearError: () => void;\n  \n  // Utility Actions\n  reset: () => void;\n}\n\n// Canvas hash generation for cache invalidation\nconst generateCanvasHash = (cells: Map<string, any>, frameCount: number): string => {\n  // Simple hash based on cell count, first few cells, and frame count\n  const cellCount = cells.size;\n  const firstCells = Array.from(cells.entries()).slice(0, 10);\n  const hashData = `${cellCount}-${frameCount}-${JSON.stringify(firstCells)}`;\n  \n  // Simple hash function\n  let hash = 0;\n  for (let i = 0; i < hashData.length; i++) {\n    const char = hashData.charCodeAt(i);\n    hash = ((hash << 5) - hash) + char;\n    hash = hash & hash; // Convert to 32-bit integer\n  }\n  return Math.abs(hash).toString(36);\n};\n\nexport const useEffectsStore = create<EffectsState>((set, get) => ({\n  // Initial state\n  isOpen: false,\n  activeEffect: null,\n  applyToTimeline: false,\n  \n  // Default effect settings\n  levelsSettings: { ...DEFAULT_LEVELS_SETTINGS },\n  hueSaturationSettings: { ...DEFAULT_HUE_SATURATION_SETTINGS },\n  remapColorsSettings: { ...DEFAULT_REMAP_COLORS_SETTINGS },\n  remapCharactersSettings: { ...DEFAULT_REMAP_CHARACTERS_SETTINGS },\n  \n  // Analysis state\n  canvasAnalysis: null,\n  isAnalyzing: false,\n  \n  // Preview state\n  isPreviewActive: false,\n  previewEffect: null,\n  \n  // Error state\n  lastError: null,\n  \n  // Panel Management Actions\n  openEffectPanel: (effect: EffectType) => {\n    set({ \n      isOpen: true, \n      activeEffect: effect \n    });\n    \n    // Analyze canvas when opening any effect\n    get().analyzeCanvas();\n  },\n  \n  closeEffectPanel: () => {\n    // Stop any active preview when closing\n    if (get().isPreviewActive) {\n      get().stopPreview();\n    }\n    \n    set({ \n      isOpen: false, \n      activeEffect: null \n    });\n  },\n  \n  setApplyToTimeline: (apply: boolean) => {\n    set({ applyToTimeline: apply });\n  },\n  \n  // Effect Settings Actions\n  updateLevelsSettings: (settings: Partial<LevelsEffectSettings>) => {\n    set(state => ({\n      levelsSettings: { ...state.levelsSettings, ...settings }\n    }));\n  },\n  \n  updateHueSaturationSettings: (settings: Partial<HueSaturationEffectSettings>) => {\n    set(state => ({\n      hueSaturationSettings: { ...state.hueSaturationSettings, ...settings }\n    }));\n  },\n  \n  updateRemapColorsSettings: (settings: Partial<RemapColorsEffectSettings>) => {\n    set(state => ({\n      remapColorsSettings: { ...state.remapColorsSettings, ...settings }\n    }));\n  },\n  \n  updateRemapCharactersSettings: (settings: Partial<RemapCharactersEffectSettings>) => {\n    set(state => ({\n      remapCharactersSettings: { ...state.remapCharactersSettings, ...settings }\n    }));\n  },\n  \n  resetEffectSettings: (effect: EffectType) => {\n    switch (effect) {\n      case 'levels':\n        set({ levelsSettings: { ...DEFAULT_LEVELS_SETTINGS } });\n        break;\n      case 'hue-saturation':\n        set({ hueSaturationSettings: { ...DEFAULT_HUE_SATURATION_SETTINGS } });\n        break;\n      case 'remap-colors':\n        set({ remapColorsSettings: { ...DEFAULT_REMAP_COLORS_SETTINGS } });\n        break;\n      case 'remap-characters':\n        set({ remapCharactersSettings: { ...DEFAULT_REMAP_CHARACTERS_SETTINGS } });\n        break;\n    }\n  },\n  \n  // Canvas Analysis Actions\n  analyzeCanvas: async () => {\n    // Avoid concurrent analysis\n    if (get().isAnalyzing) return;\n    \n    set({ isAnalyzing: true });\n    \n    try {\n      // Import stores dynamically to avoid circular dependencies\n      const { useCanvasStore } = await import('../stores/canvasStore');\n      const { useAnimationStore } = await import('../stores/animationStore');\n      \n      const canvasStore = useCanvasStore.getState();\n      const animationStore = useAnimationStore.getState();\n      \n      const { cells } = canvasStore;\n      const { frames } = animationStore;\n      \n      // Generate hash for cache invalidation\n      const canvasHash = generateCanvasHash(cells, frames.length);\n      \n      // Check if analysis is still valid\n      const currentAnalysis = get().canvasAnalysis;\n      if (currentAnalysis && \n          currentAnalysis.canvasHash === canvasHash &&\n          (Date.now() - currentAnalysis.analysisTimestamp) < CANVAS_ANALYSIS.CACHE_EXPIRY_MS) {\n        set({ isAnalyzing: false });\n        return;\n      }\n      \n      // Analyze canvas for unique colors and characters\n      const uniqueColors = new Set<string>();\n      const uniqueCharacters = new Set<string>();\n      const colorFrequency: Record<string, number> = {};\n      const characterFrequency: Record<string, number> = {};\n      \n      // Analyze current canvas\n      cells.forEach(cell => {\n        // Track colors\n        if (cell.color && cell.color !== 'transparent') {\n          uniqueColors.add(cell.color);\n          colorFrequency[cell.color] = (colorFrequency[cell.color] || 0) + 1;\n        }\n        if (cell.bgColor && cell.bgColor !== 'transparent') {\n          uniqueColors.add(cell.bgColor);\n          colorFrequency[cell.bgColor] = (colorFrequency[cell.bgColor] || 0) + 1;\n        }\n        \n        // Track characters\n        if (cell.char && cell.char.trim()) {\n          uniqueCharacters.add(cell.char);\n          characterFrequency[cell.char] = (characterFrequency[cell.char] || 0) + 1;\n        }\n      });\n      \n      // If applying to timeline, analyze all frames\n      if (get().applyToTimeline) {\n        frames.forEach(frame => {\n          frame.data.forEach(cell => {\n            // Same analysis for timeline frames\n            if (cell.color && cell.color !== 'transparent') {\n              uniqueColors.add(cell.color);\n              colorFrequency[cell.color] = (colorFrequency[cell.color] || 0) + 1;\n            }\n            if (cell.bgColor && cell.bgColor !== 'transparent') {\n              uniqueColors.add(cell.bgColor);\n              colorFrequency[cell.bgColor] = (colorFrequency[cell.bgColor] || 0) + 1;\n            }\n            if (cell.char && cell.char.trim()) {\n              uniqueCharacters.add(cell.char);\n              characterFrequency[cell.char] = (characterFrequency[cell.char] || 0) + 1;\n            }\n          });\n        });\n      }\n      \n      // Create analysis results\n      const analysis: CanvasAnalysis = {\n        // Basic unique values\n        uniqueColors: Array.from(uniqueColors).slice(0, CANVAS_ANALYSIS.MAX_UNIQUE_ITEMS),\n        uniqueCharacters: Array.from(uniqueCharacters).slice(0, CANVAS_ANALYSIS.MAX_UNIQUE_ITEMS),\n        \n        // Frequency data (original simple format)\n        colorFrequency,\n        characterFrequency,\n        \n        // Extended frequency data (sorted arrays) - add these for compatibility\n        colorsByFrequency: Object.entries(colorFrequency)\n          .map(([color, count]) => ({ color, count }))\n          .sort((a, b) => b.count - a.count),\n        charactersByFrequency: Object.entries(characterFrequency)\n          .map(([char, count]) => ({ char, count }))\n          .sort((a, b) => b.count - a.count),\n        \n        // Distribution data with percentages\n        colorDistribution: Object.entries(colorFrequency)\n          .map(([color, count]) => ({ \n            color, \n            count, \n            percentage: cells.size > 0 ? (count / cells.size) * 100 : 0 \n          }))\n          .sort((a, b) => b.count - a.count),\n        characterDistribution: Object.entries(characterFrequency)\n          .map(([char, count]) => ({ \n            char, \n            count, \n            percentage: cells.size > 0 ? (count / cells.size) * 100 : 0 \n          }))\n          .sort((a, b) => b.count - a.count),\n        \n        // Cross-reference mappings - simplified for now\n        colorToCharMap: {},\n        charToColorMap: {},\n        \n        // Canvas statistics\n        totalCells: cells.size,\n        filledCells: cells.size, // Simplified - all cells with data are filled\n        fillPercentage: 100,\n        \n        // Color analysis - simplified for now\n        colorBrightnessStats: {\n          brightest: '',\n          darkest: '',\n          averageBrightness: 0,\n          brightColors: [],\n          darkColors: []\n        },\n        \n        // Metadata\n        canvasHash,\n        frameCount: frames.length,\n        analysisTimestamp: Date.now()\n      };\n      \n      set({ \n        canvasAnalysis: analysis,\n        isAnalyzing: false \n      });\n      \n    } catch (error) {\n      console.error('Canvas analysis failed:', error);\n      set({ isAnalyzing: false });\n    }\n  },\n  \n  clearAnalysisCache: () => {\n    set({ canvasAnalysis: null });\n  },\n  \n  getUniqueColors: () => {\n    return get().canvasAnalysis?.uniqueColors || [];\n  },\n  \n  getUniqueCharacters: () => {\n    return get().canvasAnalysis?.uniqueCharacters || [];\n  },\n  \n  // Preview Management Actions\n  startPreview: (effect: EffectType) => {\n    const { updatePreview } = get();\n    set({ \n      isPreviewActive: true, \n      previewEffect: effect \n    });\n    \n    // Generate and show preview immediately\n    updatePreview().catch(error => {\n      console.error('Initial preview generation failed:', error);\n    });\n  },\n  \n  stopPreview: () => {\n    set({ \n      isPreviewActive: false, \n      previewEffect: null \n    });\n    \n    // Clear preview from previewStore\n    const previewStore = usePreviewStore.getState();\n    previewStore.clearPreview();\n  },\n  \n  // Generate and update preview\n  updatePreview: async () => {\n    const state = get();\n    if (!state.isPreviewActive || !state.previewEffect) return;\n    \n    try {\n      const canvasStore = useCanvasStore.getState();\n      const previewStore = usePreviewStore.getState();\n      \n      // Get current canvas data\n      const currentCells = canvasStore.cells;\n      \n      // Get effect settings\n      let effectSettings;\n      switch (state.previewEffect) {\n        case 'levels':\n          effectSettings = state.levelsSettings;\n          break;\n        case 'hue-saturation':\n          effectSettings = state.hueSaturationSettings;\n          break;\n        case 'remap-colors':\n          effectSettings = state.remapColorsSettings;\n          break;\n        case 'remap-characters':\n          effectSettings = state.remapCharactersSettings;\n          break;\n        default:\n          return;\n      }\n      \n      // Process effect on current canvas data (await the async function)\n      const result = await processEffect(\n        state.previewEffect,\n        currentCells, \n        effectSettings,\n        canvasStore.width,\n        canvasStore.height\n      );\n      \n      // Update preview store with processed cells if successful\n      if (result.success && result.processedCells) {\n        previewStore.setPreviewData(result.processedCells);\n      } else {\n        console.error('Preview processing failed:', result);\n        previewStore.clearPreview();\n      }\n      \n    } catch (error) {\n      console.error('Preview generation error:', error);\n      set({ lastError: error instanceof Error ? error.message : 'Preview generation failed' });\n    }\n  },\n  \n  // Effect Application Actions\n  applyEffect: async (effect: EffectType): Promise<boolean> => {\n    try {\n      const state = get();\n      \n      // Clear any previous errors\n      state.clearError();\n      \n      // Stop preview if active\n      if (state.isPreviewActive) {\n        state.stopPreview();\n      }\n\n      // Get effect settings\n      const getEffectSettings = () => {\n        switch (effect) {\n          case 'levels':\n            return state.levelsSettings;\n          case 'hue-saturation':\n            return state.hueSaturationSettings;\n          case 'remap-colors':\n            return state.remapColorsSettings;\n          case 'remap-characters':\n            return state.remapCharactersSettings;\n          default:\n            throw new Error(`Unknown effect type: ${effect}`);\n        }\n      };\n\n      const settings = getEffectSettings();\n\n      // Import processing engine dynamically\n      const { processEffect, processEffectOnFrames } = await import('../utils/effectsProcessing');\n\n      if (state.applyToTimeline) {\n        // Apply to entire timeline\n        const { useAnimationStore } = await import('./animationStore');\n        const { useCanvasStore } = await import('./canvasStore');\n        \n        const animationStore = useAnimationStore.getState();\n        const canvasStore = useCanvasStore.getState();\n        \n        console.log(`Applying ${effect} effect to ${animationStore.frames.length} frames...`);\n        \n        const result = await processEffectOnFrames(\n          effect,\n          animationStore.frames,\n          settings,\n          canvasStore.width,\n          canvasStore.height,\n          (frameIndex, totalFrames) => {\n            console.log(`Processing frame ${frameIndex + 1}/${totalFrames}`);\n          }\n        );\n\n        if (result.errors.length > 0) {\n          console.warn('Effect processing had errors:', result.errors);\n        }\n\n        // Update animation store with processed frames\n        // Use the set function directly to update frames\n        useAnimationStore.setState((state) => ({\n          ...state,\n          frames: result.processedFrames\n        }));\n\n        // Sync the canvas with the processed current frame\n        const updatedAnimationStore = useAnimationStore.getState();\n        const currentFrame = updatedAnimationStore.frames[updatedAnimationStore.currentFrameIndex];\n        if (currentFrame) {\n          const { useCanvasStore } = await import('./canvasStore');\n          const canvasStore = useCanvasStore.getState();\n          canvasStore.setCanvasData(currentFrame.data);\n        }\n\n        console.log(`✅ Applied ${effect} to timeline: ${result.totalAffectedCells} cells modified in ${result.processingTime.toFixed(2)}ms`);\n        \n      } else {\n        // Apply to current canvas only\n        const { useCanvasStore } = await import('./canvasStore');\n        const canvasStore = useCanvasStore.getState();\n        \n        console.log(`Applying ${effect} effect to current canvas...`);\n        \n        const result = await processEffect(\n          effect,\n          canvasStore.cells,\n          settings,\n          canvasStore.width,\n          canvasStore.height\n        );\n\n        if (result.success && result.processedCells) {\n          // Update canvas store with processed cells\n          const { setCanvasData } = canvasStore;\n          setCanvasData(result.processedCells);\n          \n          console.log(`✅ Applied ${effect} to canvas: ${result.affectedCells} cells modified in ${result.processingTime.toFixed(2)}ms`);\n        } else {\n          throw new Error(result.error || 'Effect processing failed');\n        }\n      }\n\n      // Clear analysis cache since canvas changed\n      state.clearAnalysisCache();\n      \n      // Close panel after successful application\n      state.closeEffectPanel();\n      \n      return true;\n    } catch (error) {\n      console.error(`Failed to apply ${effect} effect:`, error);\n      set(state => ({ ...state, lastError: `Failed to apply effect: ${error instanceof Error ? error.message : 'Unknown error'}` }));\n      return false;\n    }\n  },\n  \n  // Utility Actions\n  clearError: () => {\n    set({ lastError: null });\n  },\n  \n  reset: () => {\n    set({\n      isOpen: false,\n      activeEffect: null,\n      applyToTimeline: false,\n      levelsSettings: { ...DEFAULT_LEVELS_SETTINGS },\n      hueSaturationSettings: { ...DEFAULT_HUE_SATURATION_SETTINGS },\n      remapColorsSettings: { ...DEFAULT_REMAP_COLORS_SETTINGS },\n      remapCharactersSettings: { ...DEFAULT_REMAP_CHARACTERS_SETTINGS },\n      canvasAnalysis: null,\n      isAnalyzing: false,\n      isPreviewActive: false,\n      previewEffect: null,\n      lastError: null\n    });\n  }\n}));","usedDeprecatedRules":[]},{"filePath":"/Users/cameronfoxly/GitHubRepos/Ascii-Motion/src/stores/exportStore.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/cameronfoxly/GitHubRepos/Ascii-Motion/src/stores/gradientStore.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/cameronfoxly/GitHubRepos/Ascii-Motion/src/stores/importStore.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/cameronfoxly/GitHubRepos/Ascii-Motion/src/stores/paletteStore.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/cameronfoxly/GitHubRepos/Ascii-Motion/src/stores/previewStore.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/cameronfoxly/GitHubRepos/Ascii-Motion/src/stores/timeEffectsStore.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":261,"column":36,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":261,"endColumn":39,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7735,7738],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7735,7738],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Time Effects Store\n * \n * Zustand store for managing time-based effects state, dialog visibility,\n * and preview system. Follows the established effectsStore pattern.\n */\n\nimport { create } from 'zustand';\nimport type { \n  WaveWarpSettings, \n  WiggleSettings, \n  FrameRangeSettings,\n  TimeEffectType \n} from '../types/timeEffects';\nimport { \n  DEFAULT_WAVE_WARP_SETTINGS, \n  DEFAULT_WIGGLE_SETTINGS \n} from '../constants/timeEffects';\nimport { useAnimationStore } from './animationStore';\nimport { useCanvasStore } from './canvasStore';\nimport { usePreviewStore } from './previewStore';\nimport { \n  applyWaveWarpToFrame, \n  applyWiggleToFrame, \n  calculateAccumulatedTime \n} from '../utils/timeEffectsProcessing';\n\ninterface TimeEffectsState {\n  // ==========================================\n  // Dialog Visibility State\n  // ==========================================\n  isWaveWarpDialogOpen: boolean;\n  isWiggleDialogOpen: boolean;\n  isSetDurationDialogOpen: boolean;\n  isAddFramesDialogOpen: boolean;\n  \n  // ==========================================\n  // Effect Settings (Persisted)\n  // ==========================================\n  waveWarpSettings: WaveWarpSettings;\n  wiggleSettings: WiggleSettings;\n  \n  // ==========================================\n  // Frame Range Control (Shared across effects)\n  // ==========================================\n  frameRange: FrameRangeSettings;\n  \n  // ==========================================\n  // Preview System\n  // ==========================================\n  isPreviewActive: boolean;\n  previewEffect: TimeEffectType | null;\n  \n  // ==========================================\n  // Actions - Dialog Management\n  // ==========================================\n  openWaveWarpDialog: () => void;\n  closeWaveWarpDialog: () => void;\n  openWiggleDialog: () => void;\n  closeWiggleDialog: () => void;\n  openSetDurationDialog: () => void;\n  closeSetDurationDialog: () => void;\n  openAddFramesDialog: () => void;\n  closeAddFramesDialog: () => void;\n  \n  // ==========================================\n  // Actions - Settings Updates\n  // ==========================================\n  updateWaveWarpSettings: (settings: Partial<WaveWarpSettings>) => void;\n  updateWiggleSettings: (settings: Partial<WiggleSettings>) => void;\n  updateFrameRange: (range: Partial<FrameRangeSettings>) => void;\n  resetWaveWarpSettings: () => void;\n  resetWiggleSettings: () => void;\n  \n  // ==========================================\n  // Actions - Preview Management\n  // ==========================================\n  startPreview: (effectType: TimeEffectType) => void;\n  stopPreview: () => void;\n  updatePreview: () => void; // Manually trigger preview update\n}\n\nexport const useTimeEffectsStore = create<TimeEffectsState>((set, get) => ({\n  // ==========================================\n  // Initial State\n  // ==========================================\n  isWaveWarpDialogOpen: false,\n  isWiggleDialogOpen: false,\n  isSetDurationDialogOpen: false,\n  isAddFramesDialogOpen: false,\n  \n  waveWarpSettings: { ...DEFAULT_WAVE_WARP_SETTINGS },\n  wiggleSettings: { ...DEFAULT_WIGGLE_SETTINGS },\n  \n  frameRange: {\n    applyToAll: true,\n    startFrame: 0,\n    endFrame: 0\n  },\n  \n  isPreviewActive: false,\n  previewEffect: null,\n  \n  // ==========================================\n  // Dialog Management Actions\n  // ==========================================\n  \n  openWaveWarpDialog: () => {\n    // Initialize frame range when dialog opens\n    const frames = useAnimationStore.getState().frames;\n    \n    set({ \n      isWaveWarpDialogOpen: true,\n      frameRange: {\n        applyToAll: true,\n        startFrame: 0,\n        endFrame: frames.length - 1\n      }\n    });\n  },\n  \n  closeWaveWarpDialog: () => {\n    const { stopPreview } = get();\n    stopPreview();\n    set({ isWaveWarpDialogOpen: false });\n  },\n  \n  openWiggleDialog: () => {\n    // Initialize frame range when dialog opens\n    const frames = useAnimationStore.getState().frames;\n    \n    set({ \n      isWiggleDialogOpen: true,\n      frameRange: {\n        applyToAll: true,\n        startFrame: 0,\n        endFrame: frames.length - 1\n      }\n    });\n  },\n  \n  closeWiggleDialog: () => {\n    const { stopPreview } = get();\n    stopPreview();\n    set({ isWiggleDialogOpen: false });\n  },\n  \n  openSetDurationDialog: () => set({ isSetDurationDialogOpen: true }),\n  closeSetDurationDialog: () => set({ isSetDurationDialogOpen: false }),\n  \n  openAddFramesDialog: () => set({ isAddFramesDialogOpen: true }),\n  closeAddFramesDialog: () => set({ isAddFramesDialogOpen: false }),\n  \n  // ==========================================\n  // Settings Update Actions\n  // ==========================================\n  \n  updateWaveWarpSettings: (settings) => {\n    set((state) => ({\n      waveWarpSettings: { ...state.waveWarpSettings, ...settings }\n    }));\n    \n    // Auto-update preview if active\n    if (get().isPreviewActive && get().previewEffect === 'wave-warp') {\n      get().updatePreview();\n    }\n  },\n  \n  updateWiggleSettings: (settings) => {\n    set((state) => ({\n      wiggleSettings: { ...state.wiggleSettings, ...settings }\n    }));\n    \n    // Auto-update preview if active\n    if (get().isPreviewActive && get().previewEffect === 'wiggle') {\n      get().updatePreview();\n    }\n  },\n  \n  updateFrameRange: (range) => {\n    set((state) => ({\n      frameRange: { ...state.frameRange, ...range }\n    }));\n  },\n  \n  resetWaveWarpSettings: () => {\n    set({ waveWarpSettings: { ...DEFAULT_WAVE_WARP_SETTINGS } });\n    \n    // Update preview if active\n    if (get().isPreviewActive && get().previewEffect === 'wave-warp') {\n      get().updatePreview();\n    }\n  },\n  \n  resetWiggleSettings: () => {\n    set({ wiggleSettings: { ...DEFAULT_WIGGLE_SETTINGS } });\n    \n    // Update preview if active\n    if (get().isPreviewActive && get().previewEffect === 'wiggle') {\n      get().updatePreview();\n    }\n  },\n  \n  // ==========================================\n  // Preview Management Actions\n  // ==========================================\n  \n  startPreview: (effectType) => {\n    console.log('[TimeEffects Store] startPreview called with:', effectType);\n    set({ \n      isPreviewActive: true, \n      previewEffect: effectType \n    });\n    \n    // Trigger initial preview\n    get().updatePreview();\n  },\n  \n  stopPreview: () => {\n    console.log('[TimeEffects Store] stopPreview called');\n    // Clear preview from canvas via previewStore\n    try {\n      usePreviewStore.getState().clearPreview();\n    } catch (error) {\n      console.warn('Preview store not available:', error);\n    }\n    \n    set({ isPreviewActive: false, previewEffect: null });\n  },\n  \n  updatePreview: () => {\n    const state = get();\n    \n    console.log('[TimeEffects Store] updatePreview called, state:', {\n      isPreviewActive: state.isPreviewActive,\n      previewEffect: state.previewEffect\n    });\n    \n    if (!state.isPreviewActive || !state.previewEffect) {\n      console.log('[TimeEffects Store] Preview not active or no effect type');\n      return;\n    }\n    \n    try {\n      // Use imported stores and utilities\n      const animationStore = useAnimationStore.getState();\n      const canvasStore = useCanvasStore.getState();\n      const previewStore = usePreviewStore.getState();\n      \n      const { currentFrameIndex, frames } = animationStore;\n      const { width: canvasWidth, height: canvasHeight } = canvasStore;\n      \n      // Get current frame data\n      const currentFrameData = frames[currentFrameIndex]?.data;\n      if (!currentFrameData) return;\n      \n      // Calculate accumulated time for current frame\n      const accumulatedTime = calculateAccumulatedTime(frames, currentFrameIndex);\n      \n      // Apply effect based on type\n      let previewData: Map<string, any> | null = null;\n      \n      console.log('[TimeEffects Store] Applying effect:', state.previewEffect, 'to frame', currentFrameIndex);\n      console.log('[TimeEffects Store] Frame data size:', currentFrameData.size, 'accumulated time:', accumulatedTime);\n      \n      if (state.previewEffect === 'wave-warp') {\n        previewData = applyWaveWarpToFrame(\n          currentFrameData,\n          canvasWidth,\n          canvasHeight,\n          state.waveWarpSettings,\n          accumulatedTime\n        );\n        console.log('[TimeEffects Store] Wave warp result:', previewData?.size || 0, 'cells');\n      } else if (state.previewEffect === 'wiggle') {\n        previewData = applyWiggleToFrame(\n          currentFrameData,\n          canvasWidth,\n          canvasHeight,\n          state.wiggleSettings,\n          accumulatedTime\n        );\n      }\n      \n      // Update preview on canvas\n      if (previewData) {\n        console.log('[TimeEffects Store] Setting preview data:', previewData.size, 'cells');\n        previewStore.setPreviewData(previewData);\n      } else {\n        console.log('[TimeEffects Store] No preview data generated');\n      }\n    } catch (error) {\n      console.error('Failed to update preview:', error);\n    }\n  }\n}));\n","usedDeprecatedRules":[]},{"filePath":"/Users/cameronfoxly/GitHubRepos/Ascii-Motion/src/stores/toolStore.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":40,"column":26,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":40,"endColumn":29,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1159,1162],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1159,1162],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":45,"column":31,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":45,"endColumn":34,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1370,1373],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1370,1373],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":49,"column":35,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":49,"endColumn":38,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1528,1531],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1528,1531],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":130,"column":41,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":130,"endColumn":44,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4599,4602],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4599,4602],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":133,"column":67,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":133,"endColumn":70,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4816,4819],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4816,4819],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":136,"column":43,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":136,"endColumn":46,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4898,4901],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4898,4901],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":137,"column":57,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":137,"endColumn":60,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4969,4972],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4969,4972],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":144,"column":48,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":144,"endColumn":51,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5316,5319],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5316,5319],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":145,"column":74,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":145,"endColumn":77,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5404,5407],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5404,5407],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":150,"column":52,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":150,"endColumn":55,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5617,5620],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5617,5620],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":151,"column":78,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":151,"endColumn":81,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5709,5712],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5709,5712],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":166,"column":47,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":166,"endColumn":50,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6281,6284],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6281,6284],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":561,"column":41,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":561,"endColumn":44,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[16685,16688],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[16685,16688],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":592,"column":66,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":592,"endColumn":69,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[17449,17452],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[17449,17452],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":616,"column":43,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":616,"endColumn":46,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[18046,18049],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[18046,18049],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":627,"column":40,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":627,"endColumn":43,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[18320,18323],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[18320,18323],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":656,"column":38,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":656,"endColumn":41,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[19282,19285],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[19282,19285],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":683,"column":40,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":683,"endColumn":43,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[20044,20047],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[20044,20047],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":724,"column":48,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":724,"endColumn":51,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[21227,21230],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[21227,21230],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":731,"column":40,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":731,"endColumn":43,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[21418,21421],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[21418,21421],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":770,"column":40,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":770,"endColumn":43,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[22774,22777],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[22774,22777],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":790,"column":52,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":790,"endColumn":55,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[23342,23345],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[23342,23345],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":796,"column":40,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":796,"endColumn":43,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[23540,23543],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[23540,23543],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":839,"column":39,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":839,"endColumn":42,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[25106,25109],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[25106,25109],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":884,"column":47,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":884,"endColumn":50,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[26500,26503],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[26500,26503],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":25,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { create } from 'zustand';\nimport type { Tool, ToolState, Selection, LassoSelection, MagicWandSelection, TextToolState, AnyHistoryAction, CanvasHistoryAction, BrushShape, BrushSettings } from '../types';\nimport { DEFAULT_COLORS } from '../constants';\nimport { \n  rectangularSelectionToText, \n  lassoSelectionToText, \n  magicWandSelectionToText, \n  writeToOSClipboard \n} from '../utils/clipboardUtils';\nimport { \n  createRectSelectionMask,\n  updateSelectionFromMask,\n  getBoundsFromMask\n} from '../utils/selectionUtils';\nimport { useAsciiTypeStore } from './asciiTypeStore';\n\ninterface ToolStoreState extends ToolState {\n  // Rectangular selection state\n  selection: Selection;\n  \n  // Lasso selection state\n  lassoSelection: LassoSelection;\n  \n  // Magic wand selection state\n  magicWandSelection: MagicWandSelection;\n  \n  // Text tool state\n  textToolState: TextToolState;\n  \n  // Pencil tool state for line drawing\n  pencilLastPosition: { x: number; y: number } | null;\n  \n  // Shift+click line preview state\n  linePreview: {\n    active: boolean;\n    points: { x: number; y: number }[];\n  };\n  \n  // Clipboard for copy/paste\n  clipboard: Map<string, any> | null;\n  clipboardOriginalPosition: { x: number; y: number } | null;\n  activeClipboardType: 'rectangle' | 'lasso' | 'magicwand' | null;\n  \n  // Lasso clipboard for copy/paste\n  lassoClipboard: Map<string, any> | null;\n  lassoClipboardOriginalPosition: { x: number; y: number } | null;\n  \n  // Magic wand clipboard for copy/paste\n  magicWandClipboard: Map<string, any> | null;\n  magicWandClipboardOriginalPosition: { x: number; y: number } | null;\n  \n  // Enhanced history for undo/redo\n  historyStack: AnyHistoryAction[];\n  historyPosition: number; // Current position in history stack (-1 = no history)\n  maxHistorySize: number;\n  \n  // Animation playback state\n  isPlaybackMode: boolean;\n  \n  // Actions\n  setActiveTool: (tool: Tool) => void;\n  setSelectedChar: (char: string) => void;\n  setSelectedColor: (color: string) => void;\n  setSelectedBgColor: (color: string) => void;\n  setBrushSize: (size: number, tool?: 'pencil' | 'eraser') => void;\n  setBrushShape: (shape: BrushShape, tool?: 'pencil' | 'eraser') => void;\n  getBrushSettings: (tool?: 'pencil' | 'eraser') => BrushSettings;\n  setRectangleFilled: (filled: boolean) => void;\n  setPaintBucketContiguous: (contiguous: boolean) => void;\n  setMagicWandContiguous: (contiguous: boolean) => void;\n  \n  // Tool behavior toggles\n  toolAffectsChar: boolean;\n  toolAffectsColor: boolean;\n  toolAffectsBgColor: boolean;\n\n  // Paint bucket match criteria (Selects same:)\n  fillMatchChar: boolean;\n  fillMatchColor: boolean;\n  fillMatchBgColor: boolean;\n\n  // Magic wand match criteria (Selects same:)\n  magicMatchChar: boolean;\n  magicMatchColor: boolean;\n  magicMatchBgColor: boolean;\n  \n  // Eyedropper behavior toggles\n  eyedropperPicksChar: boolean;\n  eyedropperPicksColor: boolean;\n  eyedropperPicksBgColor: boolean;\n  \n  // Actions for toggles\n  setToolAffectsChar: (enabled: boolean) => void;\n  setToolAffectsColor: (enabled: boolean) => void;\n  setToolAffectsBgColor: (enabled: boolean) => void;\n  setFillMatchChar: (enabled: boolean) => void;\n  setFillMatchColor: (enabled: boolean) => void;\n  setFillMatchBgColor: (enabled: boolean) => void;\n  setMagicMatchChar: (enabled: boolean) => void;\n  setMagicMatchColor: (enabled: boolean) => void;\n  setMagicMatchBgColor: (enabled: boolean) => void;\n  setEyedropperPicksChar: (enabled: boolean) => void;\n  setEyedropperPicksColor: (enabled: boolean) => void;\n  setEyedropperPicksBgColor: (enabled: boolean) => void;\n  \n  // Eyedropper functionality\n  pickFromCell: (char: string, color: string, bgColor: string) => void;\n  \n  // Pencil tool actions\n  setPencilLastPosition: (position: { x: number; y: number } | null) => void;\n  setLinePreview: (points: { x: number; y: number }[]) => void;\n  clearLinePreview: () => void;\n  \n  // Rectangular selection actions\n  startSelection: (x: number, y: number) => void;\n  updateSelection: (x: number, y: number) => void;\n  clearSelection: () => void;\n  setSelectionFromMask: (mask: Set<string>) => void;\n  \n  // Lasso selection actions\n  startLassoSelection: () => void;\n  addLassoPoint: (x: number, y: number) => void;\n  updateLassoSelectedCells: (selectedCells: Set<string>) => void;\n  setLassoPath: (path: { x: number; y: number }[]) => void;\n  finalizeLassoSelection: () => void;\n  clearLassoSelection: () => void;\n  setLassoSelectionFromMask: (mask: Set<string>, path?: { x: number; y: number }[]) => void;\n  \n  // Magic wand selection actions\n  startMagicWandSelection: (targetCell: any, selectedCells: Set<string>) => void;\n  updateMagicWandSelectedCells: (selectedCells: Set<string>) => void;\n  clearMagicWandSelection: () => void;\n  setMagicWandSelectionFromMask: (mask: Set<string>, targetCell?: any) => void;\n  \n  // Clipboard actions\n  copySelection: (canvasData: Map<string, any>) => void;\n  pasteSelection: (x: number, y: number) => Map<string, any> | null;\n  hasClipboard: () => boolean;\n  getActiveClipboardType: () => 'rectangle' | 'lasso' | 'magicwand' | null;\n  getActiveClipboardOriginalPosition: () => { x: number; y: number } | null;\n  getClipboardOriginalPosition: () => { x: number; y: number } | null;\n  \n  // Lasso clipboard actions\n  copyLassoSelection: (canvasData: Map<string, any>) => void;\n  pasteLassoSelection: (offsetX: number, offsetY: number) => Map<string, any> | null;\n  hasLassoClipboard: () => boolean;\n  getLassoClipboardOriginalPosition: () => { x: number; y: number } | null;\n  \n  // Magic wand clipboard actions\n  copyMagicWandSelection: (canvasData: Map<string, any>) => void;\n  pasteMagicWandSelection: (offsetX: number, offsetY: number) => Map<string, any> | null;\n  hasMagicWandClipboard: () => boolean;\n  getMagicWandClipboardOriginalPosition: () => { x: number; y: number } | null;\n  \n  // Text tool actions\n  startTyping: (x: number, y: number) => void;\n  stopTyping: () => void;\n  setCursorPosition: (x: number, y: number) => void;\n  setCursorVisible: (visible: boolean) => void;\n  setTextBuffer: (buffer: string) => void;\n  setLineStartX: (x: number) => void;\n  commitWord: () => void;\n  \n  // Enhanced history actions\n  pushToHistory: (action: AnyHistoryAction) => void;\n  pushCanvasHistory: (canvasData: Map<string, any>, frameIndex: number, description?: string) => void;\n  undo: () => AnyHistoryAction | undefined;\n  redo: () => AnyHistoryAction | undefined;\n  clearHistory: () => void;\n  canUndo: () => boolean;\n  canRedo: () => boolean;\n  \n  // Playback mode actions\n  setPlaybackMode: (enabled: boolean) => void;\n}\n\nconst createEmptySelection = (): Selection => ({\n  start: { x: 0, y: 0 },\n  end: { x: 0, y: 0 },\n  active: false,\n  selectedCells: new Set<string>(),\n  shape: 'rectangle'\n});\n\nconst buildSelectionFromMask = (mask: Set<string>): Selection => {\n  if (mask.size === 0) {\n    return createEmptySelection();\n  }\n\n  const { start, end, selectedCells, shape } = updateSelectionFromMask(mask);\n  return {\n    start,\n    end,\n    selectedCells,\n    shape,\n    active: true\n  };\n};\n\nexport const useToolStore = create<ToolStoreState>((set, get) => ({\n  // Initial state\n  activeTool: 'pencil',\n  selectedChar: '@',\n  selectedColor: DEFAULT_COLORS[2], // White (moved from index 1 to 2)\n  selectedBgColor: DEFAULT_COLORS[0], // Transparent\n  brushSettings: {\n    pencil: {\n      size: 1,\n      shape: 'circle' as BrushShape,\n    },\n    eraser: {\n      size: 1,\n      shape: 'circle' as BrushShape,\n    }\n  },\n  rectangleFilled: false,\n  paintBucketContiguous: true, // Default to contiguous fill\n  magicWandContiguous: true, // Default to contiguous selection\n  \n  // Tool behavior toggles - all enabled by default\n  toolAffectsChar: true,\n  toolAffectsColor: true,\n  toolAffectsBgColor: true,\n\n  // Paint bucket matching criteria (Selects same:) - all enabled by default\n  fillMatchChar: true,\n  fillMatchColor: true,\n  fillMatchBgColor: true,\n\n  // Magic wand matching criteria (Selects same:) - all enabled by default\n  magicMatchChar: true,\n  magicMatchColor: true,\n  magicMatchBgColor: true,\n  \n  // Eyedropper behavior toggles - all enabled by default\n  eyedropperPicksChar: true,\n  eyedropperPicksColor: true,\n  eyedropperPicksBgColor: true,\n  \n  // Animation playback state\n  isPlaybackMode: false,\n  \n  // Pencil tool state\n  pencilLastPosition: null,\n  \n  // Shift+click line preview state\n  linePreview: {\n    active: false,\n    points: []\n  },\n  \n  // Rectangular selection state\n  selection: createEmptySelection(),\n  \n  // Lasso selection state\n  lassoSelection: {\n    path: [],\n    selectedCells: new Set<string>(),\n    active: false,\n    isDrawing: false\n  },\n  \n  // Magic wand selection state\n  magicWandSelection: {\n    selectedCells: new Set<string>(),\n    targetCell: null,\n    active: false,\n    contiguous: true\n  },\n  \n  // Text tool state\n  textToolState: {\n    isTyping: false,\n    cursorPosition: null,\n    cursorVisible: true,\n    textBuffer: '',\n    lineStartX: 0\n  },\n  \n  // Clipboard state\n  clipboard: null,\n  clipboardOriginalPosition: null,\n  activeClipboardType: null,\n  \n  // Lasso clipboard state\n  lassoClipboard: null,\n  lassoClipboardOriginalPosition: null,\n  \n  // Magic wand clipboard state\n  magicWandClipboard: null,\n  magicWandClipboardOriginalPosition: null,\n  \n  // Enhanced history for undo/redo\n  historyStack: [],\n  historyPosition: -1,\n  maxHistorySize: 50,\n\n  // Tool actions\n  setActiveTool: (tool: Tool) => {\n    set({ activeTool: tool });\n    const asciiStore = useAsciiTypeStore.getState();\n    if (tool === 'asciitype') {\n      asciiStore.openPanel();\n    } else {\n      asciiStore.closePanel();\n    }\n    // Clear line preview when switching tools\n    get().clearLinePreview();\n    // Clear selections when switching tools (except select/lasso/magicwand tools)\n    if (tool !== 'select') {\n      get().clearSelection();\n    }\n    if (tool !== 'lasso') {\n      get().clearLassoSelection();\n    }\n    if (tool !== 'magicwand') {\n      get().clearMagicWandSelection();\n    }\n    // Clear pencil last position when switching tools\n    if (tool !== 'pencil') {\n      get().setPencilLastPosition(null);\n    }\n    // Stop typing when switching away from text tool\n    if (tool !== 'text') {\n      get().stopTyping();\n    }\n  },\n\n  setSelectedChar: (char: string) => set({ selectedChar: char }),\n  setSelectedColor: (color: string) => set({ selectedColor: color }),\n  setSelectedBgColor: (color: string) => set({ selectedBgColor: color }),\n  setBrushSize: (size: number, tool?: 'pencil' | 'eraser') => {\n    const clampedSize = Math.max(1, Math.min(20, size));\n    const targetTool = tool ?? (get().activeTool === 'eraser' ? 'eraser' : 'pencil');\n\n    set((state) => ({\n      brushSettings: {\n        ...state.brushSettings,\n        [targetTool]: {\n          ...state.brushSettings[targetTool],\n          size: clampedSize,\n        }\n      }\n    }));\n  },\n  setBrushShape: (shape: BrushShape, tool?: 'pencil' | 'eraser') => {\n    const targetTool = tool ?? (get().activeTool === 'eraser' ? 'eraser' : 'pencil');\n\n    set((state) => ({\n      brushSettings: {\n        ...state.brushSettings,\n        [targetTool]: {\n          ...state.brushSettings[targetTool],\n          shape,\n        }\n      }\n    }));\n  },\n  getBrushSettings: (tool?: 'pencil' | 'eraser') => {\n    const targetTool = tool ?? (get().activeTool === 'eraser' ? 'eraser' : 'pencil');\n    const { brushSettings } = get();\n    return brushSettings[targetTool];\n  },\n  setRectangleFilled: (filled: boolean) => set({ rectangleFilled: filled }),\n  setPaintBucketContiguous: (contiguous: boolean) => set({ paintBucketContiguous: contiguous }),\n  setMagicWandContiguous: (contiguous: boolean) => set({ magicWandContiguous: contiguous }),\n\n  // Tool behavior toggle actions\n  setToolAffectsChar: (enabled: boolean) => set({ toolAffectsChar: enabled }),\n  setToolAffectsColor: (enabled: boolean) => set({ toolAffectsColor: enabled }),\n  setToolAffectsBgColor: (enabled: boolean) => set({ toolAffectsBgColor: enabled }),\n  // Paint bucket matching criteria setters\n  setFillMatchChar: (enabled: boolean) => set({ fillMatchChar: enabled }),\n  setFillMatchColor: (enabled: boolean) => set({ fillMatchColor: enabled }),\n  setFillMatchBgColor: (enabled: boolean) => set({ fillMatchBgColor: enabled }),\n  // Magic wand matching criteria setters\n  setMagicMatchChar: (enabled: boolean) => set({ magicMatchChar: enabled }),\n  setMagicMatchColor: (enabled: boolean) => set({ magicMatchColor: enabled }),\n  setMagicMatchBgColor: (enabled: boolean) => set({ magicMatchBgColor: enabled }),\n  \n  // Eyedropper behavior toggle actions\n  setEyedropperPicksChar: (enabled: boolean) => set({ eyedropperPicksChar: enabled }),\n  setEyedropperPicksColor: (enabled: boolean) => set({ eyedropperPicksColor: enabled }),\n  setEyedropperPicksBgColor: (enabled: boolean) => set({ eyedropperPicksBgColor: enabled }),\n\n  // Eyedropper functionality\n  pickFromCell: (char: string, color: string, bgColor: string) => {\n    const { eyedropperPicksChar, eyedropperPicksColor, eyedropperPicksBgColor } = get();\n    \n    const updates: Partial<ToolStoreState> = {};\n    \n    // Only pick character if toggle is enabled\n    if (eyedropperPicksChar) {\n      updates.selectedChar = char;\n    }\n    \n    // Only pick color data if the cell has a character (not just a space) and toggle is enabled\n    const hasChar = char !== ' ';\n    if (eyedropperPicksColor && hasChar) {\n      updates.selectedColor = color;\n    }\n    if (eyedropperPicksBgColor && hasChar) {\n      updates.selectedBgColor = bgColor;\n    }\n    \n    if (Object.keys(updates).length > 0) {\n      set(updates);\n    }\n  },\n\n  // Pencil tool actions\n  setPencilLastPosition: (position: { x: number; y: number } | null) => {\n    set({ pencilLastPosition: position });\n  },\n\n  setLinePreview: (points: { x: number; y: number }[]) => {\n    set({ \n      linePreview: {\n        active: points.length > 0,\n        points\n      }\n    });\n  },\n\n  clearLinePreview: () => {\n    set({ \n      linePreview: {\n        active: false,\n        points: []\n      }\n    });\n  },\n\n  // Selection actions\n  startSelection: (x: number, y: number) => {\n    const mask = createRectSelectionMask({ x, y }, { x, y });\n    set({\n      selection: {\n        start: { x, y },\n        end: { x, y },\n        active: true,\n        selectedCells: mask,\n        shape: 'rectangle'\n      }\n    });\n  },\n\n  updateSelection: (x: number, y: number) => {\n    set((state) => {\n      if (!state.selection.active) {\n        return {};\n      }\n\n      const mask = createRectSelectionMask(state.selection.start, { x, y });\n      return {\n        selection: {\n          ...state.selection,\n          end: { x, y },\n          selectedCells: mask,\n          shape: 'rectangle'\n        }\n      };\n    });\n  },\n\n  clearSelection: () => {\n    set({\n      selection: createEmptySelection()\n    });\n  },\n\n  setSelectionFromMask: (mask: Set<string>) => {\n    set({\n      selection: buildSelectionFromMask(mask)\n    });\n  },\n\n  // Lasso selection actions\n  startLassoSelection: () => {\n    set({\n      lassoSelection: {\n        path: [],\n        selectedCells: new Set<string>(),\n        active: true,\n        isDrawing: true\n      }\n    });\n  },\n\n  addLassoPoint: (x: number, y: number) => {\n    set((state) => ({\n      lassoSelection: {\n        ...state.lassoSelection,\n        path: [...state.lassoSelection.path, { x, y }]\n      }\n    }));\n  },\n\n  updateLassoSelectedCells: (selectedCells: Set<string>) => {\n    set((state) => ({\n      lassoSelection: {\n        ...state.lassoSelection,\n        selectedCells: new Set(selectedCells)\n      }\n    }));\n  },\n\n  setLassoPath: (path: { x: number; y: number }[]) => {\n    set((state) => ({\n      lassoSelection: {\n        ...state.lassoSelection,\n        path\n      }\n    }));\n  },\n\n  finalizeLassoSelection: () => {\n    set((state) => ({\n      lassoSelection: {\n        ...state.lassoSelection,\n        isDrawing: false\n      }\n    }));\n  },\n\n  clearLassoSelection: () => {\n    set({\n      lassoSelection: {\n        path: [],\n        selectedCells: new Set<string>(),\n        active: false,\n        isDrawing: false\n      }\n    });\n  },\n\n  setLassoSelectionFromMask: (mask: Set<string>, path: { x: number; y: number }[] = []) => {\n    if (mask.size === 0) {\n      set({\n        lassoSelection: {\n          path: [],\n          selectedCells: new Set<string>(),\n          active: false,\n          isDrawing: false\n        }\n      });\n      return;\n    }\n\n    set({\n      lassoSelection: {\n        path,\n        selectedCells: new Set(mask),\n        active: true,\n        isDrawing: false\n      }\n    });\n  },\n\n  // Magic wand selection actions\n  startMagicWandSelection: (targetCell: any, selectedCells: Set<string>) => {\n    set({\n      magicWandSelection: {\n        selectedCells: new Set(selectedCells),\n        targetCell: targetCell,\n        active: true,\n        contiguous: get().magicWandContiguous\n      }\n    });\n  },\n\n  updateMagicWandSelectedCells: (selectedCells: Set<string>) => {\n    set((state) => ({\n      magicWandSelection: {\n        ...state.magicWandSelection,\n        selectedCells: new Set(selectedCells)\n      }\n    }));\n  },\n\n  clearMagicWandSelection: () => {\n    set({\n      magicWandSelection: {\n        selectedCells: new Set<string>(),\n        targetCell: null,\n        active: false,\n        contiguous: get().magicWandContiguous\n      }\n    });\n  },\n\n  setMagicWandSelectionFromMask: (mask: Set<string>, targetCell: any = null) => {\n    if (mask.size === 0) {\n      set({\n        magicWandSelection: {\n          selectedCells: new Set<string>(),\n          targetCell: null,\n          active: false,\n          contiguous: get().magicWandContiguous\n        }\n      });\n      return;\n    }\n\n    set((state) => ({\n      magicWandSelection: {\n        selectedCells: new Set(mask),\n        targetCell: targetCell ?? state.magicWandSelection.targetCell,\n        active: true,\n        contiguous: state.magicWandSelection.contiguous\n      }\n    }));\n  },\n\n  // Clipboard actions\n  copySelection: (canvasData: Map<string, any>) => {\n    const { selection } = get();\n    if (!selection.active || selection.selectedCells.size === 0) {\n      return;\n    }\n\n    const bounds = getBoundsFromMask(selection.selectedCells);\n    if (!bounds) {\n      return;\n    }\n\n    const copiedData = new Map<string, any>();\n    selection.selectedCells.forEach((key) => {\n      const cell = canvasData.get(key);\n      if (!cell) {\n        return;\n      }\n      const [x, y] = key.split(',').map(Number);\n      const relativeKey = `${x - bounds.minX},${y - bounds.minY}`;\n      copiedData.set(relativeKey, cell);\n    });\n\n    set({ \n      clipboard: copiedData,\n      clipboardOriginalPosition: { x: bounds.minX, y: bounds.minY },\n      activeClipboardType: 'rectangle'\n    });\n    \n    // Also copy to OS clipboard as text\n    const textForClipboard = rectangularSelectionToText(canvasData, selection.selectedCells);\n    if (textForClipboard.trim() !== '') {\n      writeToOSClipboard(textForClipboard).catch(error => {\n        console.warn('Failed to copy to OS clipboard:', error);\n      });\n    }\n  },\n\n  pasteSelection: (x: number, y: number) => {\n    const { activeClipboardType, clipboard, lassoClipboard, magicWandClipboard } = get();\n\n    let sourceClipboard: Map<string, any> | null = null;\n    switch (activeClipboardType) {\n      case 'magicwand':\n        sourceClipboard = magicWandClipboard ?? null;\n        break;\n      case 'lasso':\n        sourceClipboard = lassoClipboard ?? null;\n        break;\n      case 'rectangle':\n        sourceClipboard = clipboard ?? null;\n        break;\n    }\n\n    if (!sourceClipboard) {\n      if (magicWandClipboard && magicWandClipboard.size > 0) {\n        sourceClipboard = magicWandClipboard;\n      } else if (lassoClipboard && lassoClipboard.size > 0) {\n        sourceClipboard = lassoClipboard;\n      } else if (clipboard && clipboard.size > 0) {\n        sourceClipboard = clipboard;\n      }\n    }\n\n    if (!sourceClipboard) {\n      return null;\n    }\n\n    const pastedData = new Map<string, any>();\n    \n    sourceClipboard.forEach((cell, relativeKey) => {\n      const [relX, relY] = relativeKey.split(',').map(Number);\n      const absoluteKey = `${x + relX},${y + relY}`;\n      pastedData.set(absoluteKey, cell);\n    });\n\n    return pastedData;\n  },\n\n  hasClipboard: () => {\n    const state = get();\n    return (state.clipboard !== null && state.clipboard!.size > 0) || \n           (state.lassoClipboard !== null && state.lassoClipboard!.size > 0) ||\n           (state.magicWandClipboard !== null && state.magicWandClipboard!.size > 0);\n  },\n\n  getActiveClipboardType: () => {\n    return get().activeClipboardType;\n  },\n\n  getActiveClipboardOriginalPosition: () => {\n    const state = get();\n    switch (state.activeClipboardType) {\n      case 'magicwand':\n        return state.magicWandClipboardOriginalPosition;\n      case 'lasso':\n        return state.lassoClipboardOriginalPosition;\n      case 'rectangle':\n        return state.clipboardOriginalPosition;\n      default:\n        return null;\n    }\n  },\n\n  getClipboardOriginalPosition: () => {\n    return get().clipboardOriginalPosition;\n  },\n\n  // Lasso clipboard actions\n  copyLassoSelection: (canvasData: Map<string, any>) => {\n    const { lassoSelection } = get();\n    \n    if (!lassoSelection.active || lassoSelection.selectedCells.size === 0) {\n      return;\n    }\n\n    const copiedData = new Map<string, any>();\n    \n    // Find bounds of the selected cells to create relative coordinates\n    const cellCoords = Array.from(lassoSelection.selectedCells).map(key => {\n      const [x, y] = key.split(',').map(Number);\n      return { x, y };\n    });\n    \n    const minX = Math.min(...cellCoords.map(c => c.x));\n    const minY = Math.min(...cellCoords.map(c => c.y));\n    \n    // Copy only the selected cells with relative coordinates\n    lassoSelection.selectedCells.forEach(key => {\n      const [x, y] = key.split(',').map(Number);\n      const relativeKey = `${x - minX},${y - minY}`;\n      if (canvasData.has(key)) {\n        copiedData.set(relativeKey, canvasData.get(key));\n      }\n    });\n\n    set({ \n      lassoClipboard: copiedData,\n      lassoClipboardOriginalPosition: { x: minX, y: minY },\n      activeClipboardType: 'lasso'\n    });\n    \n    // Also copy to OS clipboard as text\n    const textForClipboard = lassoSelectionToText(canvasData, lassoSelection.selectedCells);\n    if (textForClipboard.trim() !== '') {\n      writeToOSClipboard(textForClipboard).catch(error => {\n        console.warn('Failed to copy lasso selection to OS clipboard:', error);\n      });\n    }\n  },\n\n  pasteLassoSelection: (offsetX: number, offsetY: number) => {\n    const { lassoClipboard } = get();\n    if (!lassoClipboard) return null;\n\n    const pastedData = new Map<string, any>();\n    \n    lassoClipboard.forEach((cell, relativeKey) => {\n      const [relX, relY] = relativeKey.split(',').map(Number);\n      const absoluteKey = `${offsetX + relX},${offsetY + relY}`;\n      pastedData.set(absoluteKey, cell);\n    });\n\n    return pastedData;\n  },\n\n  hasLassoClipboard: () => {\n    return get().lassoClipboard !== null && get().lassoClipboard!.size > 0;\n  },\n\n  getLassoClipboardOriginalPosition: () => {\n    return get().lassoClipboardOriginalPosition;\n  },\n\n  // Magic wand clipboard actions\n  copyMagicWandSelection: (canvasData: Map<string, any>) => {\n    const { magicWandSelection } = get();\n    if (!magicWandSelection.active || magicWandSelection.selectedCells.size === 0) {\n      return;\n    }\n\n    const copiedData = new Map<string, any>();\n    \n    // Find bounds of the selected cells to create relative coordinates (consistent with other clipboard types)\n    const cellCoords = Array.from(magicWandSelection.selectedCells).map(key => {\n      const [x, y] = key.split(',').map(Number);\n      return { x, y };\n    });\n    \n    const minX = Math.min(...cellCoords.map(c => c.x));\n    const minY = Math.min(...cellCoords.map(c => c.y));\n    \n    // Copy selected cells with relative coordinates\n    const selectedArray = Array.from(magicWandSelection.selectedCells);\n    for (const cellKey of selectedArray) {\n      const [x, y] = cellKey.split(',').map(Number);\n      const relativeKey = `${x - minX},${y - minY}`;\n      const cell = canvasData.get(cellKey);\n      if (cell) {\n        copiedData.set(relativeKey, { ...cell });\n      }\n    }\n    \n    set({ \n      magicWandClipboard: copiedData,\n      magicWandClipboardOriginalPosition: { x: minX, y: minY },\n      activeClipboardType: 'magicwand'\n    });\n    \n    // Also copy to OS clipboard as text\n    const textForClipboard = magicWandSelectionToText(canvasData, magicWandSelection.selectedCells);\n    if (textForClipboard.trim() !== '') {\n      writeToOSClipboard(textForClipboard).catch(error => {\n        console.warn('Failed to copy magic wand selection to OS clipboard:', error);\n      });\n    }\n  },\n\n  pasteMagicWandSelection: (offsetX: number, offsetY: number) => {\n    const { magicWandClipboard } = get();\n    if (!magicWandClipboard || magicWandClipboard.size === 0) {\n      return null;\n    }\n\n    const pasteData = new Map<string, any>();\n    \n    // Apply offset to each cell position (now using relative coordinates like other clipboard types)\n    magicWandClipboard.forEach((cell, relativeKey) => {\n      const [relX, relY] = relativeKey.split(',').map(Number);\n      const absoluteKey = `${offsetX + relX},${offsetY + relY}`;\n      pasteData.set(absoluteKey, { ...cell });\n    });\n    \n    return pasteData;\n  },\n\n  hasMagicWandClipboard: () => {\n    return get().magicWandClipboard !== null && get().magicWandClipboard!.size > 0;\n  },\n\n  getMagicWandClipboardOriginalPosition: () => {\n    return get().magicWandClipboardOriginalPosition;\n  },\n\n  // Enhanced history actions\n  pushToHistory: (action: AnyHistoryAction) => {\n    set((state) => {\n      const newHistoryStack = [...state.historyStack];\n      \n      // If we're not at the end of history, truncate everything after current position\n      if (state.historyPosition < newHistoryStack.length - 1) {\n        newHistoryStack.splice(state.historyPosition + 1);\n      }\n      \n      // Add new action to history\n      newHistoryStack.push(action);\n      \n      // Limit history size\n      if (newHistoryStack.length > state.maxHistorySize) {\n        newHistoryStack.shift();\n      }\n      \n      return {\n        historyStack: newHistoryStack,\n        historyPosition: newHistoryStack.length - 1\n      };\n    });\n  },\n\n  pushCanvasHistory: (canvasData: Map<string, any>, frameIndex: number, description: string = 'Canvas edit') => {\n    const action: CanvasHistoryAction = {\n      type: 'canvas_edit',\n      timestamp: Date.now(),\n      description,\n      data: {\n        canvasData: new Map(canvasData),\n        frameIndex\n      }\n    };\n    get().pushToHistory(action);\n  },\n\n  undo: () => {\n    const { historyStack, historyPosition } = get();\n    \n    if (historyPosition < 0) return undefined;\n    \n    const action = historyStack[historyPosition];\n    \n    set({\n      historyPosition: historyPosition - 1\n    });\n    \n    return action;\n  },\n\n  redo: () => {\n    const { historyStack, historyPosition } = get();\n    \n    if (historyPosition >= historyStack.length - 1) return undefined;\n    \n    const nextPosition = historyPosition + 1;\n    const action = historyStack[nextPosition];\n    \n    set({\n      historyPosition: nextPosition\n    });\n    \n    return action;\n  },\n\n  clearHistory: () => {\n    set({\n      historyStack: [],\n      historyPosition: -1\n    });\n  },\n\n  canUndo: () => get().historyPosition >= 0,\n  canRedo: () => {\n    const { historyStack, historyPosition } = get();\n    return historyPosition < historyStack.length - 1;\n  },\n  \n  // Text tool actions\n  startTyping: (x: number, y: number) => {\n    set({\n      textToolState: {\n        ...get().textToolState,\n        isTyping: true,\n        cursorPosition: { x, y },\n        cursorVisible: true,\n        textBuffer: '',\n        lineStartX: x\n      }\n    });\n  },\n\n  stopTyping: () => {\n    set({\n      textToolState: {\n        ...get().textToolState,\n        isTyping: false,\n        cursorPosition: null,\n        cursorVisible: true,\n        textBuffer: ''\n      }\n    });\n  },\n\n  setCursorPosition: (x: number, y: number) => {\n    set({\n      textToolState: {\n        ...get().textToolState,\n        cursorPosition: { x, y },\n        cursorVisible: true // Reset blink on move\n      }\n    });\n  },\n\n  setCursorVisible: (visible: boolean) => {\n    set({\n      textToolState: {\n        ...get().textToolState,\n        cursorVisible: visible\n      }\n    });\n  },\n\n  setTextBuffer: (buffer: string) => {\n    set({\n      textToolState: {\n        ...get().textToolState,\n        textBuffer: buffer\n      }\n    });\n  },\n\n  setLineStartX: (x: number) => {\n    set({\n      textToolState: {\n        ...get().textToolState,\n        lineStartX: x\n      }\n    });\n  },\n\n  commitWord: () => {\n    // Clear the text buffer after committing a word for undo\n    set({\n      textToolState: {\n        ...get().textToolState,\n        textBuffer: ''\n      }\n    });\n  },\n\n  // Playback mode actions\n  setPlaybackMode: (enabled: boolean) => {\n    set({ isPlaybackMode: enabled });\n  }\n}));\n","usedDeprecatedRules":[]},{"filePath":"/Users/cameronfoxly/GitHubRepos/Ascii-Motion/src/types/effects.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/cameronfoxly/GitHubRepos/Ascii-Motion/src/types/export.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/cameronfoxly/GitHubRepos/Ascii-Motion/src/types/index.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":222,"column":35,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":222,"endColumn":38,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5132,5135],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5132,5135],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":229,"column":37,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":229,"endColumn":40,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5364,5367],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5364,5367],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":386,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":386,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9512,9515],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9512,9515],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// Core ASCII Motion types\n\nexport type FrameId = string & { __brand: 'FrameId' };\nexport type ProjectId = string & { __brand: 'ProjectId' };\n\nexport interface Cell {\n  char: string;\n  color: string;\n  bgColor: string;\n}\n\nexport interface Frame {\n  id: FrameId;\n  name: string;\n  duration: number; // in milliseconds\n  data: Map<string, Cell>; // key: \"x,y\"\n  thumbnail?: string; // base64 image data URL\n}\n\nexport interface Animation {\n  frames: Frame[];\n  currentFrameIndex: number;\n  isPlaying: boolean;\n  frameRate: number; // fps for display reference\n  totalDuration: number; // calculated from frame durations\n  looping: boolean;\n}\n\nexport interface Canvas {\n  width: number;\n  height: number;\n  cells: Map<string, Cell>; // current frame data, key: \"x,y\"\n}\n\nexport interface Project {\n  id: ProjectId;\n  name: string;\n  created: string;\n  modified: string;\n  canvas: {\n    width: number;\n    height: number;\n  };\n  animation: {\n    frames: Frame[];\n    settings: {\n      defaultFrameDuration: number;\n      onionSkinning: {\n        enabled: boolean;\n        framesBefore: number;\n        framesAfter: number;\n        opacity: number;\n      };\n    };\n  };\n}\n\nexport type Tool = \n  | 'pencil' \n  | 'eraser' \n  | 'paintbucket' \n  | 'select' \n  | 'lasso'\n  | 'magicwand'\n  | 'rectangle' \n  | 'ellipse'\n  | 'eyedropper'\n  | 'line'\n  | 'text'\n  | 'asciitype'\n  | 'brush'\n  | 'gradientfill'\n  | 'fliphorizontal'\n  | 'flipvertical';\n\nexport type BrushShape = 'circle' | 'square' | 'horizontal' | 'vertical';\n\nexport interface BrushSettings {\n  size: number;\n  shape: BrushShape;\n}\n\nexport interface ToolState {\n  activeTool: Tool;\n  selectedChar: string;\n  selectedColor: string;\n  selectedBgColor: string;\n  brushSettings: {\n    pencil: BrushSettings;\n    eraser: BrushSettings;\n  };\n  rectangleFilled: boolean;\n  paintBucketContiguous: boolean;\n  magicWandContiguous: boolean;\n}\n\nexport type SelectionShape = 'rectangle' | 'custom';\n\nexport interface Selection {\n  start: { x: number; y: number };\n  end: { x: number; y: number };\n  active: boolean;\n  selectedCells: Set<string>;\n  shape: SelectionShape;\n}\n\nexport interface LassoSelection {\n  path: { x: number; y: number }[];\n  selectedCells: Set<string>; // Cell keys \"x,y\" that are inside the polygon\n  active: boolean;\n  isDrawing: boolean; // Currently drawing the lasso path\n}\n\nexport interface MagicWandSelection {\n  selectedCells: Set<string>; // Cell keys \"x,y\" that match the target criteria\n  targetCell: Cell | null; // The original clicked cell (for matching criteria)\n  active: boolean;\n  contiguous: boolean; // Whether to select only connected matching cells\n}\n\nexport interface TextToolState {\n  isTyping: boolean;\n  cursorPosition: { x: number; y: number } | null;\n  cursorVisible: boolean; // For blink animation\n  textBuffer: string; // Current word being typed for undo batching\n  lineStartX: number; // Starting X position for line returns\n}\n\nexport interface CharacterPalette {\n  categories: {\n    [key: string]: string[];\n  };\n  customPalettes: {\n    [name: string]: string[];\n  };\n  activePalette: string;\n}\n\nexport interface ExportSettings {\n  gif: {\n    width: number;\n    height: number;\n    quality: number;\n    colors: number;\n    scale: number;\n  };\n  video: {\n    width: number;\n    height: number;\n    quality: number;\n    format: 'mp4' | 'webm';\n    scale: number;\n  };\n  text: {\n    preserveFormatting: boolean;\n    lineEndings: 'lf' | 'crlf';\n  };\n}\n\n// Gradient Fill Tool Types\nexport type InterpolationMethod = 'linear' | 'constant' | 'bayer2x2' | 'bayer4x4' | 'noise';\nexport type QuantizeStepCount =\n  | 1\n  | 2\n  | 3\n  | 4\n  | 5\n  | 6\n  | 7\n  | 8\n  | 9\n  | 10\n  | 'infinite';\nexport type GradientType = 'linear' | 'radial';\n\nexport interface GradientStop {\n  position: number; // 0-1 along gradient line\n  value: string; // Character, color hex, or bgColor hex\n}\n\nexport interface GradientProperty {\n  enabled: boolean;\n  stops: GradientStop[];\n  interpolation: InterpolationMethod;\n  ditherStrength: number; // 0-100, controls how much dithering spreads across stop range\n  quantizeSteps: QuantizeStepCount; // Number of discrete steps for linear interpolation ('infinite' for smooth)\n}\n\nexport interface GradientDefinition {\n  type: GradientType;\n  character: GradientProperty;\n  textColor: GradientProperty;\n  backgroundColor: GradientProperty;\n}\n\nexport interface GradientState {\n  // Fill area matching (extends paint bucket logic)\n  contiguous: boolean;\n  matchChar: boolean;\n  matchColor: boolean;\n  matchBgColor: boolean;\n  \n  // Gradient definition\n  definition: GradientDefinition;\n  \n  // Interactive state\n  isApplying: boolean;\n  startPoint: { x: number; y: number } | null;\n  endPoint: { x: number; y: number } | null;\n  ellipsePoint: { x: number; y: number } | null;\n  previewData: Map<string, Cell> | null;\n}\n\n// Utility type for creating Cell coordinates\nexport const createCellKey = (x: number, y: number): string => `${x},${y}`;\nexport const parseCellKey = (key: string): { x: number; y: number } => {\n  const [x, y] = key.split(',').map(Number);\n  return { x, y };\n};\n\n// Type guards\nexport const isValidCell = (cell: any): cell is Cell => {\n  return typeof cell === 'object' && \n         typeof cell.char === 'string' && \n         typeof cell.color === 'string' && \n         typeof cell.bgColor === 'string';\n};\n\nexport const isValidFrame = (frame: any): frame is Frame => {\n  return typeof frame === 'object' &&\n         typeof frame.id === 'string' &&\n         typeof frame.name === 'string' &&\n         typeof frame.duration === 'number' &&\n         frame.data instanceof Map;\n};\n\n// Enhanced History System Types\nexport type HistoryActionType = \n  | 'canvas_edit'      // Canvas cell modifications\n  | 'add_frame'        // Add new frame\n  | 'duplicate_frame'  // Duplicate existing frame\n  | 'duplicate_frame_range' // Duplicate multiple frames\n  | 'delete_frame'     // Delete frame\n  | 'delete_frame_range'  // Delete multiple frames\n  | 'delete_all_frames'   // Delete all frames and reset\n  | 'reorder_frames'   // Reorder frame positions\n  | 'reorder_frame_range' // Reorder multiple frames as a group\n  | 'update_duration'  // Change frame duration\n  | 'update_name'      // Change frame name\n  | 'navigate_frame'   // Navigate to different frame\n  | 'apply_effect'     // Apply effect to canvas or timeline\n  | 'apply_time_effect'     // Apply time-based effect (wave warp, wiggle)\n  | 'set_frame_durations';  // Bulk set frame durations\n\nexport interface HistoryAction {\n  type: HistoryActionType;\n  timestamp: number;\n  description: string;\n}\n\nexport interface CanvasHistoryAction extends HistoryAction {\n  type: 'canvas_edit';\n  data: {\n    canvasData: Map<string, Cell>;\n    frameIndex: number;\n  };\n}\n\nexport interface AddFrameHistoryAction extends HistoryAction {\n  type: 'add_frame';\n  data: {\n    frameIndex: number;\n    frame: Frame;\n    canvasData: Map<string, Cell>; // Canvas state when frame was added\n    previousCurrentFrame: number;\n  };\n}\n\nexport interface DuplicateFrameHistoryAction extends HistoryAction {\n  type: 'duplicate_frame';\n  data: {\n    originalIndex: number;\n    newIndex: number;\n    frame: Frame;\n    previousCurrentFrame: number;\n  };\n}\n\nexport interface DuplicateFrameRangeHistoryAction extends HistoryAction {\n  type: 'duplicate_frame_range';\n  data: {\n    originalFrameIndices: number[];\n    insertedFrameIds: FrameId[];\n    previousFrames: Frame[];\n    newFrames: Frame[];\n    previousSelection: number[];\n    newSelection: number[];\n    previousCurrentFrame: number;\n    newCurrentFrame: number;\n  };\n}\n\nexport interface DeleteFrameHistoryAction extends HistoryAction {\n  type: 'delete_frame';\n  data: {\n    frameIndex: number;\n    frame: Frame;\n    previousCurrentFrame: number;\n    newCurrentFrame: number;\n  };\n}\n\nexport interface ReorderFramesHistoryAction extends HistoryAction {\n  type: 'reorder_frames';\n  data: {\n    fromIndex: number;\n    toIndex: number;\n    previousCurrentFrame: number;\n    newCurrentFrame: number;\n  };\n}\n\nexport interface UpdateDurationHistoryAction extends HistoryAction {\n  type: 'update_duration';\n  data: {\n    frameIndex: number;\n    oldDuration: number;\n    newDuration: number;\n  };\n}\n\nexport interface UpdateNameHistoryAction extends HistoryAction {\n  type: 'update_name';\n  data: {\n    frameIndex: number;\n    oldName: string;\n    newName: string;\n  };\n}\n\nexport interface NavigateFrameHistoryAction extends HistoryAction {\n  type: 'navigate_frame';\n  data: {\n    previousFrameIndex: number;\n    newFrameIndex: number;\n  };\n}\n\nexport interface DeleteFrameRangeHistoryAction extends HistoryAction {\n  type: 'delete_frame_range';\n  data: {\n    frameIndices: number[];\n    frames: Frame[];\n    previousCurrentFrame: number;\n    newCurrentFrame: number;\n    previousFrames: Frame[];\n    previousSelection: number[];\n  };\n}\n\nexport interface DeleteAllFramesHistoryAction extends HistoryAction {\n  type: 'delete_all_frames';\n  data: {\n    frames: Frame[];\n    previousCurrentFrame: number;\n  };\n}\n\nexport interface ReorderFrameRangeHistoryAction extends HistoryAction {\n  type: 'reorder_frame_range';\n  data: {\n    frameIndices: number[];\n    targetIndex: number;\n    previousCurrentFrame: number;\n    newCurrentFrame: number;\n    movedFrameIds: FrameId[];\n    previousSelectionFrameIds: FrameId[];\n    newSelectionFrameIds: FrameId[];\n  };\n}\n\nexport interface ApplyEffectHistoryAction extends HistoryAction {\n  type: 'apply_effect';\n  data: {\n    effectType: import('./effects').EffectType;\n    effectSettings: any; // Settings object for the effect\n    applyToTimeline: boolean;\n    affectedFrameIndices: number[];\n    previousCanvasData?: Map<string, Cell>; // For single canvas effects\n    previousFramesData?: Array<{ frameIndex: number; data: Map<string, Cell> }>; // For timeline effects\n  };\n}\n\nexport interface ApplyTimeEffectHistoryAction extends HistoryAction {\n  type: 'apply_time_effect';\n  data: {\n    effectType: import('./timeEffects').TimeEffectType;\n    effectSettings: import('./timeEffects').WaveWarpSettings | import('./timeEffects').WiggleSettings;\n    frameRange: import('./timeEffects').FrameRangeSettings;\n    affectedFrameIndices: number[];\n    previousFramesData: Array<{ frameIndex: number; data: Map<string, Cell> }>;\n  };\n}\n\nexport interface SetFrameDurationsHistoryAction extends HistoryAction {\n  type: 'set_frame_durations';\n  data: {\n    affectedFrameIndices: number[];\n    newDuration: number;\n    previousDurations: Array<{ frameIndex: number; duration: number }>;\n  };\n}\n\nexport type AnyHistoryAction = \n  | CanvasHistoryAction\n  | AddFrameHistoryAction \n  | DuplicateFrameHistoryAction\n  | DuplicateFrameRangeHistoryAction\n  | DeleteFrameHistoryAction\n  | DeleteFrameRangeHistoryAction\n  | DeleteAllFramesHistoryAction\n  | ReorderFramesHistoryAction\n  | ReorderFrameRangeHistoryAction\n  | UpdateDurationHistoryAction\n  | UpdateNameHistoryAction\n  | NavigateFrameHistoryAction\n  | ApplyEffectHistoryAction\n  | ApplyTimeEffectHistoryAction\n  | SetFrameDurationsHistoryAction;\n","usedDeprecatedRules":[]},{"filePath":"/Users/cameronfoxly/GitHubRepos/Ascii-Motion/src/types/palette.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":60,"column":37,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":60,"endColumn":40,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1291,1294],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1291,1294],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":70,"column":37,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":70,"endColumn":40,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1575,1578],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1575,1578],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":82,"column":44,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":82,"endColumn":47,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1922,1925],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1922,1925],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":87,"column":30,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":87,"endColumn":33,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2100,2103],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2100,2103],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":130,"column":41,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":130,"endColumn":44,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3626,3629],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3626,3629],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":143,"column":53,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":143,"endColumn":56,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4067,4070],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4067,4070],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":6,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// Color Palette System Types\n\nexport interface PaletteColor {\n  id: string;\n  value: string; // hex color (e.g., \"#ff0000\")\n  name?: string; // optional display name\n}\n\nexport interface ColorPalette {\n  id: string;\n  name: string;\n  colors: PaletteColor[];\n  isPreset: boolean;\n  isCustom: boolean;\n}\n\nexport interface ColorPickerState {\n  isOpen: boolean;\n  mode: 'foreground' | 'background';\n  currentColor: string;\n  previewColor: string;\n  recentColors: string[];\n}\n\nexport interface DragState {\n  isDragging: boolean;\n  draggedColorId: string | null;\n  draggedFromIndex: number | null;\n  dropTargetIndex: number | null;\n}\n\n// Export format for JSON import/export\nexport interface PaletteExportFormat {\n  name: string;\n  colors: string[];\n}\n\n// HSV color representation\nexport interface HSVColor {\n  h: number; // hue: 0-360\n  s: number; // saturation: 0-100\n  v: number; // value: 0-100\n}\n\n// RGB color representation\nexport interface RGBColor {\n  r: number; // red: 0-255\n  g: number; // green: 0-255\n  b: number; // blue: 0-255\n}\n\n// Utility type for color format validation\nexport type ColorFormat = 'hex' | 'rgb' | 'hsv';\n\n// Type guards\nexport const isValidHexColor = (color: string): boolean => {\n  return /^#[0-9A-Fa-f]{6}$/.test(color);\n};\n\nexport const isPaletteColor = (obj: any): obj is PaletteColor => {\n  return (\n    typeof obj === 'object' &&\n    typeof obj.id === 'string' &&\n    typeof obj.value === 'string' &&\n    isValidHexColor(obj.value) &&\n    (obj.name === undefined || typeof obj.name === 'string')\n  );\n};\n\nexport const isColorPalette = (obj: any): obj is ColorPalette => {\n  return (\n    typeof obj === 'object' &&\n    typeof obj.id === 'string' &&\n    typeof obj.name === 'string' &&\n    Array.isArray(obj.colors) &&\n    obj.colors.every(isPaletteColor) &&\n    typeof obj.isPreset === 'boolean' &&\n    typeof obj.isCustom === 'boolean'\n  );\n};\n\nexport const isPaletteExportFormat = (obj: any): obj is PaletteExportFormat => {\n  return (\n    typeof obj === 'object' &&\n    typeof obj.name === 'string' &&\n    Array.isArray(obj.colors) &&\n    obj.colors.every((color: any) => typeof color === 'string' && isValidHexColor(color))\n  );\n};\n\n// Character Palette System Types (similar to color palettes but for ASCII characters)\n\nexport interface CharacterPalette {\n  id: string;\n  name: string;\n  characters: string[];           // Ordered by density (light to dark)\n  isPreset: boolean;             // System preset vs user created\n  isCustom: boolean;            // User-created custom palette\n  category: 'ascii' | 'unicode' | 'blocks' | 'custom';\n}\n\nexport interface CharacterMappingSettings {\n  activePalette: CharacterPalette;\n  mappingMethod: 'brightness' | 'luminance' | 'contrast' | 'edge-detection' | 'saturation' | 'red-channel' | 'green-channel' | 'blue-channel';\n  invertDensity: boolean;         // Reverse light/dark mapping\n  characterSpacing: number;       // Spacing between characters (1.0 = normal)\n  useCustomOrder: boolean;        // Allow manual character reordering\n}\n\n// Character palette editor state\nexport interface CharacterPaletteEditorState {\n  isEditing: boolean;\n  editingPaletteId: string | null;\n  draggedCharacterIndex: number | null;\n  dropTargetIndex: number | null;\n}\n\n// Export format for JSON import/export (future feature)\nexport interface CharacterPaletteExportFormat {\n  name: string;\n  characters: string[];\n  category: CharacterPalette['category'];\n}\n\n// Type guards for character palettes\nexport const isValidCharacter = (char: string): boolean => {\n  return typeof char === 'string' && char.length === 1;\n};\n\nexport const isCharacterPalette = (obj: any): obj is CharacterPalette => {\n  return (\n    typeof obj === 'object' &&\n    typeof obj.id === 'string' &&\n    typeof obj.name === 'string' &&\n    Array.isArray(obj.characters) &&\n    obj.characters.every(isValidCharacter) &&\n    typeof obj.isPreset === 'boolean' &&\n    typeof obj.isCustom === 'boolean' &&\n    ['ascii', 'unicode', 'blocks', 'custom'].includes(obj.category)\n  );\n};\n\nexport const isCharacterPaletteExportFormat = (obj: any): obj is CharacterPaletteExportFormat => {\n  return (\n    typeof obj === 'object' &&\n    typeof obj.name === 'string' &&\n    Array.isArray(obj.characters) &&\n    obj.characters.every(isValidCharacter) &&\n    ['ascii', 'unicode', 'blocks', 'custom'].includes(obj.category)\n  );\n};\n\n// Utility functions for ID generation\nexport const generateColorId = (): string => {\n  return `color_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n};\n\nexport const generatePaletteId = (): string => {\n  return `palette_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n};\n\nexport const generateCharacterPaletteId = (): string => {\n  return `char_palette_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n};\n","usedDeprecatedRules":[]},{"filePath":"/Users/cameronfoxly/GitHubRepos/Ascii-Motion/src/types/timeEffects.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/cameronfoxly/GitHubRepos/Ascii-Motion/src/utils/asciiConverter.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":62,"column":90,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":62,"endColumn":93,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2217,2220],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2217,2220],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"prefer-const","severity":2,"message":"'algorithmOptions' is never reassigned. Use 'const' instead.","line":437,"column":15,"nodeType":"Identifier","messageId":"useConst","endLine":437,"endColumn":36,"fix":{"range":[16848,16879],"text":"const algorithmOptions: any = {};"}},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":437,"column":33,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":437,"endColumn":36,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[16870,16873],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[16870,16873],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"prefer-const","severity":2,"message":"'currentData' is never reassigned. Use 'const' instead.","line":662,"column":9,"nodeType":"Identifier","messageId":"useConst","endLine":662,"endColumn":20,"fix":{"range":[25496,25542],"text":"const currentData = new Uint8ClampedArray(data);"}},{"ruleId":"prefer-const","severity":2,"message":"'tempData' is never reassigned. Use 'const' instead.","line":663,"column":9,"nodeType":"Identifier","messageId":"useConst","endLine":663,"endColumn":17,"fix":{"range":[25547,25597],"text":"const tempData = new Uint8ClampedArray(data.length);"}},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":861,"column":15,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":861,"endColumn":18,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[32476,32479],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[32476,32479],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":6,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":3,"fixableWarningCount":0,"source":"/**\n * ASCII Converter - Converts processed image data to ASCII art\n * \n * Features:\n * - Brightness-to-character mapping\n * - Color extraction and quantization\n * - Cell data generation for canvas\n * - Multiple conversion algorithms\n */\n\nimport type { Cell } from '../types';\nimport type { ProcessedFrame } from './mediaProcessor';\nimport type { CharacterPalette, CharacterMappingSettings } from '../types/palette';\n\n// Legacy support - kept for backward compatibility\nexport const DEFAULT_ASCII_CHARS = [\n  '@', '#', 'S', '%', '?', '*', '+', ';', ':', ',', '.', ' '\n];\n\nexport interface ConversionSettings {\n  // Character mapping - Enhanced with palette support\n  enableCharacterMapping: boolean;\n  characterPalette: CharacterPalette;\n  mappingMethod: CharacterMappingSettings['mappingMethod'];\n  invertDensity: boolean;\n  \n  // Text (foreground) color mapping - NEW\n  enableTextColorMapping: boolean;\n  textColorPalette: string[]; // Array of hex colors from selected palette\n  textColorMappingMode: 'closest' | 'dithering' | 'by-index';\n  defaultTextColor: string; // Default color when text color mapping is disabled\n  \n  // Background color mapping - NEW\n  enableBackgroundColorMapping: boolean;\n  backgroundColorPalette: string[]; // Array of hex colors from selected palette\n  backgroundColorMappingMode: 'closest' | 'dithering' | 'by-index';\n  \n  // Legacy color settings (keep for backward compatibility)\n  useOriginalColors: boolean;\n  colorQuantization: 'none' | 'basic' | 'advanced';\n  paletteSize: number;\n  colorMappingMode: 'closest' | 'dithering';\n  \n  // Processing options\n  contrastEnhancement: number; // 0-2 multiplier\n  brightnessAdjustment: number; // -100 to 100\n  saturationAdjustment: number; // -100 to 100\n  highlightsAdjustment: number; // -100 to 100\n  shadowsAdjustment: number; // -100 to 100\n  midtonesAdjustment: number; // -100 to 100\n  blurAmount: number; // 0-10\n  sharpenAmount: number; // 0-10\n  ditherStrength: number; // 0-1 for dithering algorithms\n}\n\n/**\n * Mapping algorithm interface for extensibility\n */\nexport interface MappingAlgorithm {\n  name: string;\n  description: string;\n  mapPixelToCharacter: (r: number, g: number, b: number, characters: string[], options?: any) => string;\n}\n\n/**\n * Brightness-based mapping algorithm\n */\nexport const brightnessAlgorithm: MappingAlgorithm = {\n  name: 'brightness',\n  description: 'Maps characters based on pixel brightness/luminance',\n  mapPixelToCharacter: (r: number, g: number, b: number, characters: string[]) => {\n    // Using relative luminance formula (Rec. 709)\n    const brightness = 0.2126 * r + 0.7152 * g + 0.0722 * b;\n    // Fixed mapping: ensures all characters are used by mapping brightness 0-255 to indices 0-(length-1)\n    const charIndex = Math.min(Math.floor((brightness / 256) * characters.length), characters.length - 1);\n    return characters[charIndex];\n  }\n};\n\n/**\n * Luminance-based mapping algorithm (alternative weighting)\n */\nexport const luminanceAlgorithm: MappingAlgorithm = {\n  name: 'luminance',\n  description: 'Maps characters based on perceptual luminance',\n  mapPixelToCharacter: (r: number, g: number, b: number, characters: string[]) => {\n    // Perceptual luminance with gamma correction\n    const luminance = Math.pow(0.299 * Math.pow(r/255, 2.2) + 0.587 * Math.pow(g/255, 2.2) + 0.114 * Math.pow(b/255, 2.2), 1/2.2) * 255;\n    // Fixed mapping: ensures all characters are used by mapping luminance 0-255 to indices 0-(length-1)\n    const charIndex = Math.min(Math.floor((luminance / 256) * characters.length), characters.length - 1);\n    return characters[charIndex];\n  }\n};\n\n/**\n * Contrast-based mapping algorithm\n */\nexport const contrastAlgorithm: MappingAlgorithm = {\n  name: 'contrast',\n  description: 'Maps characters based on local contrast detection',\n  mapPixelToCharacter: (r: number, g: number, b: number, characters: string[], options?: { neighborValues?: number[] }) => {\n    const brightness = 0.2126 * r + 0.7152 * g + 0.0722 * b;\n    \n    // If neighbor values are provided, calculate local contrast\n    if (options?.neighborValues && options.neighborValues.length > 0) {\n      const avgNeighbor = options.neighborValues.reduce((sum, val) => sum + val, 0) / options.neighborValues.length;\n      const localContrast = Math.abs(brightness - avgNeighbor) / 255;\n      \n      // Calculate standard deviation for better contrast measurement\n      const variance = options.neighborValues.reduce((sum, val) => {\n        const diff = val - avgNeighbor;\n        return sum + (diff * diff);\n      }, 0) / options.neighborValues.length;\n      const stdDev = Math.sqrt(variance) / 255;\n      \n      // Combine local contrast with neighborhood variance for better contrast detection\n      const contrastScore = (localContrast * 0.7) + (stdDev * 0.3);\n      \n      // Map contrast score to character index - higher contrast gets denser characters\n      const contrastBasedIndex = Math.min(\n        Math.floor(contrastScore * characters.length * 1.5), \n        characters.length - 1\n      );\n      \n      // Blend contrast-based selection with brightness-based selection\n      const brightnessIndex = Math.min(Math.floor((brightness / 256) * characters.length), characters.length - 1);\n      const blendedIndex = Math.floor((contrastBasedIndex * 0.6) + (brightnessIndex * 0.4));\n      \n      return characters[Math.min(blendedIndex, characters.length - 1)];\n    }\n    \n    // Fallback to brightness if no neighbors - fixed mapping\n    const charIndex = Math.min(Math.floor((brightness / 256) * characters.length), characters.length - 1);\n    return characters[charIndex];\n  }\n};\n\n/**\n * Edge detection mapping algorithm\n */\nexport const edgeDetectionAlgorithm: MappingAlgorithm = {\n  name: 'edge-detection',\n  description: 'Maps characters based on edge detection for line art',\n  mapPixelToCharacter: (r: number, g: number, b: number, characters: string[], options?: { \n    gradientMagnitude?: number,\n    sobelX?: number,\n    sobelY?: number \n  }) => {\n    const brightness = 0.2126 * r + 0.7152 * g + 0.0722 * b;\n    \n    // If Sobel gradient values are provided, calculate proper edge strength\n    if (options?.sobelX !== undefined && options?.sobelY !== undefined) {\n      const gradientMagnitude = Math.sqrt(options.sobelX * options.sobelX + options.sobelY * options.sobelY);\n      const edgeStrength = Math.min(gradientMagnitude / 765, 1); // Normalize to 0-1 (765 = max possible gradient)\n      \n      // For strong edges, prefer characters with more visual density\n      if (edgeStrength > 0.2) {\n        // Map edge strength to higher-density characters\n        const edgeCharIndex = Math.floor(edgeStrength * characters.length);\n        const minIndex = Math.floor(characters.length * 0.4); // Prefer at least medium-density chars for edges\n        return characters[Math.min(Math.max(edgeCharIndex, minIndex), characters.length - 1)];\n      }\n      \n      // For weak edges, blend with brightness\n      const brightnessIndex = Math.min(Math.floor((brightness / 256) * characters.length), characters.length - 1);\n      const edgeInfluence = edgeStrength * 0.5; // Moderate influence for weak edges\n      const blendedIndex = Math.floor((brightnessIndex * (1 - edgeInfluence)) + (characters.length * 0.6 * edgeInfluence));\n      return characters[Math.min(blendedIndex, characters.length - 1)];\n    }\n    \n    // Fallback using gradient magnitude (legacy support)\n    if (options?.gradientMagnitude !== undefined) {\n      const edgeStrength = options.gradientMagnitude / 255;\n      \n      if (edgeStrength > 0.3) {\n        const edgeCharIndex = Math.min(Math.floor((edgeStrength / 256) * characters.length), characters.length - 1);\n        return characters[Math.max(Math.floor(characters.length * 0.5), edgeCharIndex)];\n      }\n    }\n    \n    // For non-edges, use brightness-based selection - fixed mapping\n    const charIndex = Math.min(Math.floor((brightness / 256) * characters.length), characters.length - 1);\n    return characters[charIndex];\n  }\n};\n\n/**\n * Saturation-based mapping algorithm\n */\nexport const saturationAlgorithm: MappingAlgorithm = {\n  name: 'saturation',\n  description: 'Maps characters based on color saturation intensity',\n  mapPixelToCharacter: (r: number, g: number, b: number, characters: string[]) => {\n    // Calculate HSV saturation\n    const rNorm = r / 255;\n    const gNorm = g / 255;\n    const bNorm = b / 255;\n    \n    const max = Math.max(rNorm, gNorm, bNorm);\n    const min = Math.min(rNorm, gNorm, bNorm);\n    \n    const saturation = max === 0 ? 0 : (max - min) / max;\n    \n    // Map saturation (0-1) to character index - higher saturation gets denser characters\n    const charIndex = Math.min(Math.floor(saturation * characters.length), characters.length - 1);\n    return characters[charIndex];\n  }\n};\n\n/**\n * Red channel mapping algorithm\n */\nexport const redChannelAlgorithm: MappingAlgorithm = {\n  name: 'red-channel',\n  description: 'Maps characters based on red color channel intensity',\n  mapPixelToCharacter: (r: number, _g: number, _b: number, characters: string[]) => {\n    // Use red channel value directly\n    const charIndex = Math.min(Math.floor((r / 256) * characters.length), characters.length - 1);\n    return characters[charIndex];\n  }\n};\n\n/**\n * Green channel mapping algorithm\n */\nexport const greenChannelAlgorithm: MappingAlgorithm = {\n  name: 'green-channel',\n  description: 'Maps characters based on green color channel intensity',\n  mapPixelToCharacter: (_r: number, g: number, _b: number, characters: string[]) => {\n    // Use green channel value directly\n    const charIndex = Math.min(Math.floor((g / 256) * characters.length), characters.length - 1);\n    return characters[charIndex];\n  }\n};\n\n/**\n * Blue channel mapping algorithm\n */\nexport const blueChannelAlgorithm: MappingAlgorithm = {\n  name: 'blue-channel',\n  description: 'Maps characters based on blue color channel intensity',\n  mapPixelToCharacter: (_r: number, _g: number, b: number, characters: string[]) => {\n    // Use blue channel value directly\n    const charIndex = Math.min(Math.floor((b / 256) * characters.length), characters.length - 1);\n    return characters[charIndex];\n  }\n};\n\n/**\n * Registry of available mapping algorithms\n */\nexport const MAPPING_ALGORITHMS: Record<CharacterMappingSettings['mappingMethod'], MappingAlgorithm> = {\n  'brightness': brightnessAlgorithm,\n  'luminance': luminanceAlgorithm,\n  'contrast': contrastAlgorithm,\n  'edge-detection': edgeDetectionAlgorithm,\n  'saturation': saturationAlgorithm,\n  'red-channel': redChannelAlgorithm,\n  'green-channel': greenChannelAlgorithm,\n  'blue-channel': blueChannelAlgorithm\n};\n\n/**\n * Color distance calculation utility functions\n */\nexport class ColorMatcher {\n  /**\n   * Calculate Euclidean distance between two RGB colors\n   */\n  static calculateColorDistance(r1: number, g1: number, b1: number, r2: number, g2: number, b2: number): number {\n    return Math.sqrt(Math.pow(r2 - r1, 2) + Math.pow(g2 - g1, 2) + Math.pow(b2 - b1, 2));\n  }\n\n  /**\n   * Find closest color from palette to given RGB values\n   */\n  static findClosestColor(r: number, g: number, b: number, palette: string[]): string {\n    let closestColor = palette[0];\n    let minDistance = Infinity;\n    \n    for (const hexColor of palette) {\n      const { r: pr, g: pg, b: pb } = this.hexToRgb(hexColor);\n      const distance = this.calculateColorDistance(r, g, b, pr, pg, pb);\n      \n      if (distance < minDistance) {\n        minDistance = distance;\n        closestColor = hexColor;\n      }\n    }\n    \n    return closestColor;\n  }\n\n  /**\n   * Convert hex color to RGB values\n   */\n  static hexToRgb(hex: string): { r: number; g: number; b: number } {\n    const result = /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i.exec(hex);\n    return result ? {\n      r: parseInt(result[1], 16),\n      g: parseInt(result[2], 16),\n      b: parseInt(result[3], 16)\n    } : { r: 0, g: 0, b: 0 };\n  }\n\n  /**\n   * Convert RGB to hex color\n   */\n  static rgbToHex(r: number, g: number, b: number): string {\n    return `#${[r, g, b].map(x => x.toString(16).padStart(2, '0')).join('')}`;\n  }\n\n  /**\n   * Simple dithering algorithm for color mapping\n   */\n  static ditherColor(r: number, g: number, b: number, palette: string[], ditherStrength: number = 0.1): string {\n    // Add some noise for dithering effect\n    const noise = () => (Math.random() - 0.5) * ditherStrength * 255;\n    const ditheredR = Math.max(0, Math.min(255, r + noise()));\n    const ditheredG = Math.max(0, Math.min(255, g + noise()));\n    const ditheredB = Math.max(0, Math.min(255, b + noise()));\n    \n    return this.findClosestColor(ditheredR, ditheredG, ditheredB, palette);\n  }\n\n  /**\n   * Map color by brightness to palette index (like character mapping)\n   */\n  static mapColorByIndex(r: number, g: number, b: number, palette: string[]): string {\n    if (palette.length === 0) return '#000000';\n    \n    // Calculate brightness using the same formula as character mapping\n    const brightness = 0.2126 * r + 0.7152 * g + 0.0722 * b;\n    \n    // Fixed mapping: ensures all colors are used by mapping brightness 0-255 to indices 0-(length-1)\n    const paletteIndex = Math.min(Math.floor((brightness / 256) * palette.length), palette.length - 1);\n    \n    return palette[paletteIndex];\n  }\n}\n\nexport interface ConversionResult {\n  cells: Map<string, Cell>;\n  colorPalette: string[];\n  characterUsage: { [char: string]: number };\n  metadata: {\n    width: number;\n    height: number;\n    totalCells: number;\n    uniqueColors: number;\n    conversionTime: number;\n  };\n}\n\nexport class ASCIIConverter {\n  private colorCache = new Map<string, string>();\n  \n  /**\n   * Convert processed frame to ASCII art cells\n   */\n  convertFrame(frame: ProcessedFrame, settings: ConversionSettings): ConversionResult {\n    const startTime = performance.now();\n    \n    let { imageData } = frame;\n    \n    // Apply blur filter if specified\n    if (settings.blurAmount > 0) {\n      imageData = this.applyBlurFilter(imageData, settings.blurAmount);\n    }\n    \n    // Apply sharpen filter if specified\n    if (settings.sharpenAmount > 0) {\n      imageData = this.applySharpenFilter(imageData, settings.sharpenAmount);\n    }\n    \n    const { data, width, height } = imageData;\n    \n    const cells = new Map<string, Cell>();\n    const colorPalette = new Set<string>();\n    const characterUsage: { [char: string]: number } = {};\n    \n    // Extract colors if quantization is enabled\n    let quantizedColors: string[] = [];\n    if (settings.colorQuantization !== 'none') {\n      quantizedColors = this.extractColors(imageData, settings.paletteSize);\n    }\n    \n    // Process each pixel/cell\n    for (let y = 0; y < height; y++) {\n      for (let x = 0; x < width; x++) {\n        const pixelIndex = (y * width + x) * 4;\n        const r = data[pixelIndex];\n        const g = data[pixelIndex + 1];\n        const b = data[pixelIndex + 2];\n        const a = data[pixelIndex + 3];\n        \n        // Skip transparent pixels\n        if (a < 128) continue;\n        \n        // Apply preprocessing adjustments to RGB values\n        let adjustedR = r, adjustedG = g, adjustedB = b;\n        \n        // Apply brightness adjustment\n        if (settings.brightnessAdjustment !== 0) {\n          const adjustment = settings.brightnessAdjustment * 2.55;\n          adjustedR = Math.max(0, Math.min(255, r + adjustment));\n          adjustedG = Math.max(0, Math.min(255, g + adjustment));\n          adjustedB = Math.max(0, Math.min(255, b + adjustment));\n        }\n        \n        // Apply contrast enhancement\n        if (settings.contrastEnhancement !== 1) {\n          adjustedR = this.applyContrastToChannel(adjustedR, settings.contrastEnhancement);\n          adjustedG = this.applyContrastToChannel(adjustedG, settings.contrastEnhancement);\n          adjustedB = this.applyContrastToChannel(adjustedB, settings.contrastEnhancement);\n        }\n        \n        // Apply saturation adjustment\n        if (settings.saturationAdjustment !== 0) {\n          [adjustedR, adjustedG, adjustedB] = this.applySaturationAdjustment(adjustedR, adjustedG, adjustedB, settings.saturationAdjustment);\n        }\n        \n        // Apply tonal adjustments (highlights, shadows, midtones)\n        if (settings.highlightsAdjustment !== 0 || settings.shadowsAdjustment !== 0 || settings.midtonesAdjustment !== 0) {\n          [adjustedR, adjustedG, adjustedB] = this.applyTonalAdjustments(\n            adjustedR, adjustedG, adjustedB,\n            settings.highlightsAdjustment,\n            settings.shadowsAdjustment,\n            settings.midtonesAdjustment\n          );\n        }\n        \n        // Select character using the chosen algorithm (if character mapping is enabled)\n        let character: string;\n        if (settings.enableCharacterMapping) {\n          // Calculate additional data for advanced algorithms\n          let algorithmOptions: any = {};\n          \n          if (settings.mappingMethod === 'contrast' || settings.mappingMethod === 'edge-detection') {\n            // Calculate neighbor values for contrast and edge detection\n            const neighbors = this.getNeighborValues(data, width, height, x, y);\n            algorithmOptions.neighborValues = neighbors;\n            \n            // For edge detection, calculate Sobel gradients\n            if (settings.mappingMethod === 'edge-detection') {\n              const { sobelX, sobelY } = this.calculateSobelGradients(data, width, height, x, y);\n              algorithmOptions.sobelX = sobelX;\n              algorithmOptions.sobelY = sobelY;\n            }\n          }\n          \n          character = this.selectCharacterWithAlgorithm(\n            adjustedR, adjustedG, adjustedB,\n            settings.characterPalette,\n            settings.mappingMethod,\n            settings.invertDensity,\n            algorithmOptions\n          );\n        } else {\n          // Use space character if character mapping is disabled (for pixel-art style effects)\n          character = ' ';\n        }\n        \n        // Determine text (foreground) color\n        let color: string;\n        if (settings.enableTextColorMapping && settings.textColorPalette.length > 0) {\n          // Use palette-based color mapping\n          if (settings.textColorMappingMode === 'dithering') {\n            color = ColorMatcher.ditherColor(adjustedR, adjustedG, adjustedB, settings.textColorPalette, settings.ditherStrength);\n          } else if (settings.textColorMappingMode === 'by-index') {\n            color = ColorMatcher.mapColorByIndex(adjustedR, adjustedG, adjustedB, settings.textColorPalette);\n          } else {\n            color = ColorMatcher.findClosestColor(adjustedR, adjustedG, adjustedB, settings.textColorPalette);\n          }\n        } else if (!settings.enableTextColorMapping) {\n          // Use default text color when text color mapping is explicitly disabled\n          color = settings.defaultTextColor;\n        } else if (settings.useOriginalColors) {\n          // Legacy color handling (only when text color mapping is not explicitly controlled)\n          if (settings.colorQuantization === 'none') {\n            color = ColorMatcher.rgbToHex(r, g, b);\n          } else {\n            color = this.quantizeColor(r, g, b, quantizedColors);\n          }\n        } else {\n          // Fallback to default text color\n          color = settings.defaultTextColor;\n        }\n        \n        // Determine background color\n        let bgColor: string;\n        if (settings.enableBackgroundColorMapping && settings.backgroundColorPalette.length > 0) {\n          // Use palette-based background color mapping\n          if (settings.backgroundColorMappingMode === 'dithering') {\n            bgColor = ColorMatcher.ditherColor(adjustedR, adjustedG, adjustedB, settings.backgroundColorPalette, settings.ditherStrength);\n          } else if (settings.backgroundColorMappingMode === 'by-index') {\n            bgColor = ColorMatcher.mapColorByIndex(adjustedR, adjustedG, adjustedB, settings.backgroundColorPalette);\n          } else {\n            bgColor = ColorMatcher.findClosestColor(adjustedR, adjustedG, adjustedB, settings.backgroundColorPalette);\n          }\n        } else {\n          bgColor = 'transparent'; // Default transparent background\n        }\n        \n        // Create cell\n        const cellKey = `${x},${y}`;\n        cells.set(cellKey, {\n          char: character,\n          color,\n          bgColor\n        });\n        \n        // Track usage\n        colorPalette.add(color);\n        characterUsage[character] = (characterUsage[character] || 0) + 1;\n      }\n    }\n    \n    const endTime = performance.now();\n    \n    return {\n      cells,\n      colorPalette: Array.from(colorPalette),\n      characterUsage,\n      metadata: {\n        width,\n        height,\n        totalCells: cells.size,\n        uniqueColors: colorPalette.size,\n        conversionTime: endTime - startTime\n      }\n    };\n  }\n  \n  /**\n   * Apply contrast enhancement to individual color channel\n   */\n  private applyContrastToChannel(channelValue: number, enhancement: number): number {\n    // Sigmoid contrast curve applied to individual channel\n    const normalized = channelValue / 255;\n    const enhanced = 1 / (1 + Math.exp(-enhancement * (normalized - 0.5) * 6));\n    return Math.round(Math.max(0, Math.min(255, enhanced * 255)));\n  }\n\n  /**\n   * Apply saturation adjustment to RGB values\n   */\n  private applySaturationAdjustment(r: number, g: number, b: number, saturationAdjustment: number): [number, number, number] {\n    // Convert RGB to HSL\n    const rNorm = r / 255;\n    const gNorm = g / 255;\n    const bNorm = b / 255;\n    \n    const max = Math.max(rNorm, gNorm, bNorm);\n    const min = Math.min(rNorm, gNorm, bNorm);\n    const delta = max - min;\n    \n    // Calculate lightness\n    const lightness = (max + min) / 2;\n    \n    // If no saturation (grayscale), return original\n    if (delta === 0) {\n      return [r, g, b];\n    }\n    \n    // Calculate current saturation\n    const saturation = lightness > 0.5 ? delta / (2 - max - min) : delta / (max + min);\n    \n    // Apply saturation adjustment (-100 to 100 -> 0 to 2 multiplier)\n    const saturationMultiplier = 1 + (saturationAdjustment / 100);\n    const newSaturation = Math.max(0, Math.min(1, saturation * saturationMultiplier));\n    \n    // Calculate hue\n    let hue = 0;\n    if (max === rNorm) {\n      hue = ((gNorm - bNorm) / delta + (gNorm < bNorm ? 6 : 0)) / 6;\n    } else if (max === gNorm) {\n      hue = ((bNorm - rNorm) / delta + 2) / 6;\n    } else {\n      hue = ((rNorm - gNorm) / delta + 4) / 6;\n    }\n    \n    // Convert HSL back to RGB\n    const c = (1 - Math.abs(2 * lightness - 1)) * newSaturation;\n    const x = c * (1 - Math.abs(((hue * 6) % 2) - 1));\n    const m = lightness - c / 2;\n    \n    let rPrime = 0, gPrime = 0, bPrime = 0;\n    const hueSegment = hue * 6;\n    \n    if (hueSegment < 1) {\n      rPrime = c; gPrime = x; bPrime = 0;\n    } else if (hueSegment < 2) {\n      rPrime = x; gPrime = c; bPrime = 0;\n    } else if (hueSegment < 3) {\n      rPrime = 0; gPrime = c; bPrime = x;\n    } else if (hueSegment < 4) {\n      rPrime = 0; gPrime = x; bPrime = c;\n    } else if (hueSegment < 5) {\n      rPrime = x; gPrime = 0; bPrime = c;\n    } else {\n      rPrime = c; gPrime = 0; bPrime = x;\n    }\n    \n    const newR = Math.round((rPrime + m) * 255);\n    const newG = Math.round((gPrime + m) * 255);\n    const newB = Math.round((bPrime + m) * 255);\n    \n    return [\n      Math.max(0, Math.min(255, newR)),\n      Math.max(0, Math.min(255, newG)),\n      Math.max(0, Math.min(255, newB))\n    ];\n  }\n\n  /**\n   * Apply tonal adjustments (highlights, shadows, midtones)\n   */\n  private applyTonalAdjustments(\n    r: number, g: number, b: number,\n    highlightsAdjustment: number,\n    shadowsAdjustment: number,\n    midtonesAdjustment: number\n  ): [number, number, number] {\n    // Calculate luminance to determine which tonal range this pixel belongs to\n    const luminance = 0.2126 * r + 0.7152 * g + 0.0722 * b;\n    const normalizedLuminance = luminance / 255;\n    \n    // Calculate weights for each tonal range using smooth transitions\n    const shadowWeight = Math.max(0, 1 - normalizedLuminance * 2); // Strong in dark areas\n    const highlightWeight = Math.max(0, (normalizedLuminance - 0.5) * 2); // Strong in bright areas\n    const midtoneWeight = 1 - Math.abs(normalizedLuminance - 0.5) * 2; // Strong in middle areas\n    \n    // Apply adjustments based on tonal range weights\n    const shadowAdjust = (shadowsAdjustment / 100) * shadowWeight;\n    const highlightAdjust = (highlightsAdjustment / 100) * highlightWeight;\n    const midtoneAdjust = (midtonesAdjustment / 100) * midtoneWeight;\n    \n    // Combine adjustments\n    const totalAdjustment = (shadowAdjust + highlightAdjust + midtoneAdjust) * 2.55;\n    \n    const newR = Math.max(0, Math.min(255, r + totalAdjustment));\n    const newG = Math.max(0, Math.min(255, g + totalAdjustment));\n    const newB = Math.max(0, Math.min(255, b + totalAdjustment));\n    \n    return [newR, newG, newB];\n  }\n\n  /**\n   * Apply blur filter to image data\n   */\n  private applyBlurFilter(imageData: ImageData, blurAmount: number): ImageData {\n    if (blurAmount <= 0) return imageData;\n    \n    const { data, width, height } = imageData;\n    const result = new ImageData(width, height);\n    const resultData = result.data;\n    \n    // Gaussian blur approximation using box blur passes\n    // Number of passes increases with blur amount for better quality\n    const passes = Math.ceil(blurAmount / 2);\n    let currentData = new Uint8ClampedArray(data);\n    let tempData = new Uint8ClampedArray(data.length);\n    \n    for (let pass = 0; pass < passes; pass++) {\n      // Horizontal pass\n      for (let y = 0; y < height; y++) {\n        for (let x = 0; x < width; x++) {\n          const centerIndex = (y * width + x) * 4;\n          let r = 0, g = 0, b = 0, a = 0;\n          let count = 0;\n          \n          // Box blur kernel size based on blur amount\n          const kernelRadius = Math.max(1, Math.floor(blurAmount / Math.max(1, passes)));\n          \n          for (let i = -kernelRadius; i <= kernelRadius; i++) {\n            const sampleX = Math.max(0, Math.min(width - 1, x + i));\n            const sampleIndex = (y * width + sampleX) * 4;\n            \n            r += currentData[sampleIndex];\n            g += currentData[sampleIndex + 1];\n            b += currentData[sampleIndex + 2];\n            a += currentData[sampleIndex + 3];\n            count++;\n          }\n          \n          tempData[centerIndex] = r / count;\n          tempData[centerIndex + 1] = g / count;\n          tempData[centerIndex + 2] = b / count;\n          tempData[centerIndex + 3] = a / count;\n        }\n      }\n      \n      // Vertical pass\n      for (let y = 0; y < height; y++) {\n        for (let x = 0; x < width; x++) {\n          const centerIndex = (y * width + x) * 4;\n          let r = 0, g = 0, b = 0, a = 0;\n          let count = 0;\n          \n          const kernelRadius = Math.max(1, Math.floor(blurAmount / Math.max(1, passes)));\n          \n          for (let i = -kernelRadius; i <= kernelRadius; i++) {\n            const sampleY = Math.max(0, Math.min(height - 1, y + i));\n            const sampleIndex = (sampleY * width + x) * 4;\n            \n            r += tempData[sampleIndex];\n            g += tempData[sampleIndex + 1];\n            b += tempData[sampleIndex + 2];\n            a += tempData[sampleIndex + 3];\n            count++;\n          }\n          \n          currentData[centerIndex] = r / count;\n          currentData[centerIndex + 1] = g / count;\n          currentData[centerIndex + 2] = b / count;\n          currentData[centerIndex + 3] = a / count;\n        }\n      }\n    }\n    \n    // Copy result back\n    resultData.set(currentData);\n    return result;\n  }\n\n  /**\n   * Apply sharpen filter to image data\n   */\n  private applySharpenFilter(imageData: ImageData, sharpenAmount: number): ImageData {\n    if (sharpenAmount <= 0) return imageData;\n    \n    const { data, width, height } = imageData;\n    const result = new ImageData(width, height);\n    const resultData = result.data;\n    \n    // Unsharp mask kernel - center weight increases with sharpen amount\n    const centerWeight = 1 + (sharpenAmount * 0.8);\n    const neighborWeight = -(sharpenAmount * 0.2);\n    \n    // Sharpen kernel: neighbor values are negative, center is positive\n    // This enhances edges by subtracting the blur from the original\n    for (let y = 0; y < height; y++) {\n      for (let x = 0; x < width; x++) {\n        const centerIndex = (y * width + x) * 4;\n        \n        let r = data[centerIndex] * centerWeight;\n        let g = data[centerIndex + 1] * centerWeight;\n        let b = data[centerIndex + 2] * centerWeight;\n        const a = data[centerIndex + 3]; // Alpha unchanged\n        \n        // Apply 3x3 kernel with neighbor weights\n        for (let dy = -1; dy <= 1; dy++) {\n          for (let dx = -1; dx <= 1; dx++) {\n            if (dx === 0 && dy === 0) continue; // Skip center pixel\n            \n            const neighborX = Math.max(0, Math.min(width - 1, x + dx));\n            const neighborY = Math.max(0, Math.min(height - 1, y + dy));\n            const neighborIndex = (neighborY * width + neighborX) * 4;\n            \n            r += data[neighborIndex] * neighborWeight;\n            g += data[neighborIndex + 1] * neighborWeight;\n            b += data[neighborIndex + 2] * neighborWeight;\n          }\n        }\n        \n        // Clamp values and apply\n        resultData[centerIndex] = Math.max(0, Math.min(255, Math.round(r)));\n        resultData[centerIndex + 1] = Math.max(0, Math.min(255, Math.round(g)));\n        resultData[centerIndex + 2] = Math.max(0, Math.min(255, Math.round(b)));\n        resultData[centerIndex + 3] = a;\n      }\n    }\n    \n    return result;\n  }\n  \n  /**\n   * Get neighbor brightness values for contrast calculation\n   */\n  private getNeighborValues(data: Uint8ClampedArray, width: number, height: number, x: number, y: number): number[] {\n    const neighbors: number[] = [];\n    \n    // Check 8-connected neighbors\n    for (let dy = -1; dy <= 1; dy++) {\n      for (let dx = -1; dx <= 1; dx++) {\n        if (dx === 0 && dy === 0) continue; // Skip center pixel\n        \n        const nx = x + dx;\n        const ny = y + dy;\n        \n        // Check bounds\n        if (nx >= 0 && nx < width && ny >= 0 && ny < height) {\n          const pixelIndex = (ny * width + nx) * 4;\n          const r = data[pixelIndex];\n          const g = data[pixelIndex + 1];\n          const b = data[pixelIndex + 2];\n          \n          // Calculate brightness using same formula as brightness algorithm\n          const brightness = 0.2126 * r + 0.7152 * g + 0.0722 * b;\n          neighbors.push(brightness);\n        }\n      }\n    }\n    \n    return neighbors;\n  }\n\n  /**\n   * Calculate Sobel gradients for edge detection\n   */\n  private calculateSobelGradients(data: Uint8ClampedArray, width: number, height: number, x: number, y: number): { sobelX: number, sobelY: number } {\n    // Sobel X kernel: [-1, 0, 1; -2, 0, 2; -1, 0, 1]\n    // Sobel Y kernel: [-1, -2, -1; 0, 0, 0; 1, 2, 1]\n    \n    let sobelX = 0;\n    let sobelY = 0;\n    \n    const sobelXKernel = [[-1, 0, 1], [-2, 0, 2], [-1, 0, 1]];\n    const sobelYKernel = [[-1, -2, -1], [0, 0, 0], [1, 2, 1]];\n    \n    for (let dy = -1; dy <= 1; dy++) {\n      for (let dx = -1; dx <= 1; dx++) {\n        const nx = x + dx;\n        const ny = y + dy;\n        \n        // Use edge pixel values for out-of-bounds pixels\n        const boundedX = Math.max(0, Math.min(width - 1, nx));\n        const boundedY = Math.max(0, Math.min(height - 1, ny));\n        \n        const pixelIndex = (boundedY * width + boundedX) * 4;\n        const r = data[pixelIndex];\n        const g = data[pixelIndex + 1];\n        const b = data[pixelIndex + 2];\n        \n        // Convert to grayscale\n        const gray = 0.2126 * r + 0.7152 * g + 0.0722 * b;\n        \n        // Apply Sobel kernels\n        const kernelY = dy + 1;\n        const kernelX = dx + 1;\n        \n        sobelX += gray * sobelXKernel[kernelY][kernelX];\n        sobelY += gray * sobelYKernel[kernelY][kernelX];\n      }\n    }\n    \n    return { sobelX, sobelY };\n  }\n\n  /**\n   * Select character using the specified algorithm\n   */\n  private selectCharacterWithAlgorithm(\n    r: number,\n    g: number,\n    b: number,\n    characterPalette: CharacterPalette,\n    mappingMethod: CharacterMappingSettings['mappingMethod'],\n    invertDensity: boolean,\n    options?: any\n  ): string {\n    const algorithm = MAPPING_ALGORITHMS[mappingMethod];\n    if (!algorithm) {\n      console.warn(`Unknown mapping algorithm: ${mappingMethod}, falling back to brightness`);\n      return MAPPING_ALGORITHMS.brightness.mapPixelToCharacter(r, g, b, characterPalette.characters);\n    }\n    \n    let characters = [...characterPalette.characters];\n    \n    // Invert character order if requested (light to dark becomes dark to light)\n    if (invertDensity) {\n      characters = characters.reverse();\n    }\n    \n    // Use the algorithm to map pixel to character\n    return algorithm.mapPixelToCharacter(r, g, b, characters, options);\n  }\n  \n  /**\n   * Convert RGB to hex color\n   */\n  private rgbToHex(r: number, g: number, b: number): string {\n    return `#${[r, g, b].map(x => x.toString(16).padStart(2, '0')).join('')}`;\n  }\n  \n  /**\n   * Extract dominant colors from image using k-means clustering\n   */\n  private extractColors(imageData: ImageData, paletteSize: number): string[] {\n    const { data, width, height } = imageData;\n    const pixels: [number, number, number][] = [];\n    \n    // Sample pixels (take every nth pixel for performance)\n    const sampleRate = Math.max(1, Math.floor((width * height) / 1000));\n    \n    for (let i = 0; i < data.length; i += 4 * sampleRate) {\n      const r = data[i];\n      const g = data[i + 1];\n      const b = data[i + 2];\n      const a = data[i + 3];\n      \n      if (a >= 128) { // Skip transparent pixels\n        pixels.push([r, g, b]);\n      }\n    }\n    \n    // Simple color quantization (can be enhanced with k-means later)\n    const colorCounts = new Map<string, number>();\n    \n    pixels.forEach(([r, g, b]) => {\n      // Quantize to reduce color space\n      const qr = Math.round(r / 32) * 32;\n      const qg = Math.round(g / 32) * 32;\n      const qb = Math.round(b / 32) * 32;\n      const key = this.rgbToHex(qr, qg, qb);\n      \n      colorCounts.set(key, (colorCounts.get(key) || 0) + 1);\n    });\n    \n    // Get most frequent colors\n    const sortedColors = Array.from(colorCounts.entries())\n      .sort((a, b) => b[1] - a[1])\n      .slice(0, paletteSize)\n      .map(([color]) => color);\n    \n    return sortedColors;\n  }\n  \n  /**\n   * Quantize color to nearest palette color\n   */\n  private quantizeColor(\n    r: number, \n    g: number, \n    b: number, \n    palette: string[]\n  ): string {\n    const originalColor = this.rgbToHex(r, g, b);\n    \n    // Check cache first\n    if (this.colorCache.has(originalColor)) {\n      return this.colorCache.get(originalColor)!;\n    }\n    \n    let nearestColor = palette[0] || '#000000';\n    let minDistance = Infinity;\n    \n    palette.forEach(paletteColor => {\n      const distance = this.colorDistance(r, g, b, paletteColor);\n      if (distance < minDistance) {\n        minDistance = distance;\n        nearestColor = paletteColor;\n      }\n    });\n    \n    // Cache result\n    this.colorCache.set(originalColor, nearestColor);\n    \n    return nearestColor;\n  }\n  \n  /**\n   * Calculate Euclidean distance between colors\n   */\n  private colorDistance(r: number, g: number, b: number, hexColor: string): number {\n    const targetR = parseInt(hexColor.slice(1, 3), 16);\n    const targetG = parseInt(hexColor.slice(3, 5), 16);\n    const targetB = parseInt(hexColor.slice(5, 7), 16);\n    \n    return Math.sqrt(\n      Math.pow(r - targetR, 2) +\n      Math.pow(g - targetG, 2) +\n      Math.pow(b - targetB, 2)\n    );\n  }\n  \n  /**\n   * Clear color cache (call when settings change)\n   */\n  clearCache(): void {\n    this.colorCache.clear();\n  }\n}\n\n// Singleton instance\nexport const asciiConverter = new ASCIIConverter();","usedDeprecatedRules":[]},{"filePath":"/Users/cameronfoxly/GitHubRepos/Ascii-Motion/src/utils/brushUtils.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/cameronfoxly/GitHubRepos/Ascii-Motion/src/utils/canvasAnalysis.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/cameronfoxly/GitHubRepos/Ascii-Motion/src/utils/canvasDPI.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":49,"column":13,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":49,"endColumn":16,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1857,1860],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1857,1860],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":54,"column":13,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":54,"endColumn":16,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1996,1999],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1996,1999],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":59,"column":13,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":59,"endColumn":16,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2138,2141],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2138,2141],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":63,"column":13,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":63,"endColumn":16,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2241,2244],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2241,2244],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":67,"column":13,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":67,"endColumn":16,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2343,2346],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2343,2346],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":5,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Canvas Text Rendering Utilities for ASCII Motion\n * \n * This module provides optimized text rendering for crisp, smooth ASCII art display.\n * \n * ## Final Implementation Summary:\n * After testing multiple approaches (high-DPI scaling, pixel-perfect rendering, etc.),\n * the optimal solution combines:\n * \n * 1. **Smooth Text Rendering**: High-quality canvas antialiasing for readable text\n * 2. **CSS Font Smoothing**: Browser's native font smoothing capabilities\n * 3. **Layered Grid Rendering**: Grid drawn as background, content on top\n * 4. **Pixel-Aligned Coordinates**: Rounded positions prevent sub-pixel blur\n * 5. **Modern Font Stack**: Professional monospace fonts (SF Mono, Monaco, etc.)\n * \n * ## Key Features:\n * - Professional text editor appearance similar to VS Code\n * - Smooth, readable text without chunky pixelation\n * - Subtle background grid that enhances rather than competes\n * - Accurate mouse coordinate handling\n * - Excellent cross-browser compatibility\n * - Optimal performance with layered rendering\n * \n * ## Rendering Layers:\n * 1. Canvas background color\n * 2. Grid lines (background layer)\n * 3. Onion skin layers\n * 4. Cell content (text and backgrounds)\n * 5. Overlays (selection, cursor, etc.)\n */\n\n/**\n * Setup optimal text rendering settings for a canvas context\n * \n * Configures the canvas for smooth, high-quality text rendering that looks\n * professional and readable without chunky pixelation.\n */\nexport const setupTextRendering = (ctx: CanvasRenderingContext2D): void => {\n  // Enable high-quality image smoothing for smooth text\n  ctx.imageSmoothingEnabled = true;\n  ctx.imageSmoothingQuality = 'high';\n  \n  // Set text baseline for consistent positioning\n  ctx.textBaseline = 'top';\n  ctx.textAlign = 'left';\n  \n  // Enable font optimization for smooth text\n  if ('textRendering' in ctx) {\n    (ctx as any).textRendering = 'optimizeLegibility';\n  }\n  \n  // Set better text rendering where available\n  if ('fontKerning' in ctx) {\n    (ctx as any).fontKerning = 'normal';\n  }\n  \n  // Enable high-quality smoothing across browsers\n  if ('mozImageSmoothingEnabled' in ctx) {\n    (ctx as any).mozImageSmoothingEnabled = true;\n  }\n  \n  if ('webkitImageSmoothingEnabled' in ctx) {\n    (ctx as any).webkitImageSmoothingEnabled = true;\n  }\n  \n  if ('msImageSmoothingEnabled' in ctx) {\n    (ctx as any).msImageSmoothingEnabled = true;\n  }\n};\n\n/**\n * Round coordinates to pixel boundaries for crisp rendering\n * \n * Used for drawing sharp lines and preventing sub-pixel positioning blur.\n * For 1-pixel lines, add 0.5 to coordinates.\n */\nexport const pixelAlign = (value: number): number => {\n  return Math.round(value) + 0.5;\n};\n\n/**\n * Calculate optimal font size for crisp rendering\n * Ensures font size aligns well with pixel boundaries\n */\nexport const getOptimalFontSize = (\n  desiredSize: number,\n  devicePixelRatio: number = window.devicePixelRatio || 1\n): number => {\n  // Round to ensure crisp rendering at the device pixel level\n  return Math.round(desiredSize * devicePixelRatio) / devicePixelRatio;\n};\n","usedDeprecatedRules":[]},{"filePath":"/Users/cameronfoxly/GitHubRepos/Ascii-Motion/src/utils/canvasTextRendering.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":49,"column":13,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":49,"endColumn":16,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1857,1860],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1857,1860],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":54,"column":13,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":54,"endColumn":16,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1996,1999],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1996,1999],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":59,"column":13,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":59,"endColumn":16,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2138,2141],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2138,2141],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":63,"column":13,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":63,"endColumn":16,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2241,2244],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2241,2244],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":67,"column":13,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":67,"endColumn":16,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2343,2346],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2343,2346],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":5,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Canvas Text Rendering Utilities for ASCII Motion\n * \n * This module provides optimized text rendering for crisp, smooth ASCII art display.\n * \n * ## Final Implementation Summary:\n * After testing multiple approaches (high-DPI scaling, pixel-perfect rendering, etc.),\n * the optimal solution combines:\n * \n * 1. **Smooth Text Rendering**: High-quality canvas antialiasing for readable text\n * 2. **CSS Font Smoothing**: Browser's native font smoothing capabilities\n * 3. **Layered Grid Rendering**: Grid drawn as background, content on top\n * 4. **Pixel-Aligned Coordinates**: Rounded positions prevent sub-pixel blur\n * 5. **Modern Font Stack**: Professional monospace fonts (SF Mono, Monaco, etc.)\n * \n * ## Key Features:\n * - Professional text editor appearance similar to VS Code\n * - Smooth, readable text without chunky pixelation\n * - Subtle background grid that enhances rather than competes\n * - Accurate mouse coordinate handling\n * - Excellent cross-browser compatibility\n * - Optimal performance with layered rendering\n * \n * ## Rendering Layers:\n * 1. Canvas background color\n * 2. Grid lines (background layer)\n * 3. Onion skin layers\n * 4. Cell content (text and backgrounds)\n * 5. Overlays (selection, cursor, etc.)\n */\n\n/**\n * Setup optimal text rendering settings for a canvas context\n * \n * Configures the canvas for smooth, high-quality text rendering that looks\n * professional and readable without chunky pixelation.\n */\nexport const setupTextRendering = (ctx: CanvasRenderingContext2D): void => {\n  // Enable high-quality image smoothing for smooth text\n  ctx.imageSmoothingEnabled = true;\n  ctx.imageSmoothingQuality = 'high';\n  \n  // Set text baseline for consistent positioning\n  ctx.textBaseline = 'top';\n  ctx.textAlign = 'left';\n  \n  // Enable font optimization for smooth text\n  if ('textRendering' in ctx) {\n    (ctx as any).textRendering = 'optimizeLegibility';\n  }\n  \n  // Set better text rendering where available\n  if ('fontKerning' in ctx) {\n    (ctx as any).fontKerning = 'normal';\n  }\n  \n  // Enable high-quality smoothing across browsers\n  if ('mozImageSmoothingEnabled' in ctx) {\n    (ctx as any).mozImageSmoothingEnabled = true;\n  }\n  \n  if ('webkitImageSmoothingEnabled' in ctx) {\n    (ctx as any).webkitImageSmoothingEnabled = true;\n  }\n  \n  if ('msImageSmoothingEnabled' in ctx) {\n    (ctx as any).msImageSmoothingEnabled = true;\n  }\n};\n\n/**\n * Round coordinates to pixel boundaries for crisp rendering\n * \n * Used for drawing sharp lines and preventing sub-pixel positioning blur.\n * For 1-pixel lines, add 0.5 to coordinates.\n */\nexport const pixelAlign = (value: number): number => {\n  return Math.round(value) + 0.5;\n};\n\n/**\n * Calculate optimal font size for crisp rendering\n * Ensures font size aligns well with pixel boundaries\n */\nexport const getOptimalFontSize = (\n  desiredSize: number,\n  devicePixelRatio: number = window.devicePixelRatio || 1\n): number => {\n  // Round to ensure crisp rendering at the device pixel level\n  return Math.round(desiredSize * devicePixelRatio) / devicePixelRatio;\n};\n","usedDeprecatedRules":[]},{"filePath":"/Users/cameronfoxly/GitHubRepos/Ascii-Motion/src/utils/characterPaletteValidation.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":24,"column":19,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":24,"endColumn":22,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[651,654],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[651,654],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'error' is defined but never used.","line":27,"column":12,"nodeType":null,"messageId":"unusedVar","endLine":27,"endColumn":17},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":57,"column":47,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":57,"endColumn":50,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1653,1656],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1653,1656],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// Character palette validation utilities for import/export functionality\n\nimport type { CharacterPaletteExportFormat } from '../types/palette';\nimport { isValidCharacter } from '../types/palette';\n\nexport interface CharacterValidationResult {\n  isValid: boolean;\n  errors: string[];\n  warnings: string[];\n  data?: CharacterPaletteExportFormat;\n}\n\n/**\n * Validate JSON string as character palette export format\n */\nexport const validateCharacterPaletteJSON = (jsonString: string): CharacterValidationResult => {\n  const result: CharacterValidationResult = {\n    isValid: false,\n    errors: [],\n    warnings: []\n  };\n\n  // Parse JSON\n  let parsedData: any;\n  try {\n    parsedData = JSON.parse(jsonString);\n  } catch (error) {\n    result.errors.push('Invalid JSON format. Please check the file syntax.');\n    return result;\n  }\n\n  // Check if it's an object\n  if (typeof parsedData !== 'object' || parsedData === null) {\n    result.errors.push('Character palette data must be a JSON object.');\n    return result;\n  }\n\n  // Validate required fields\n  if (typeof parsedData.name !== 'string') {\n    result.errors.push('Character palette must have a \"name\" field of type string.');\n  }\n\n  if (!Array.isArray(parsedData.characters)) {\n    result.errors.push('Character palette must have a \"characters\" field of type array.');\n  }\n\n  if (typeof parsedData.category !== 'string') {\n    result.errors.push('Character palette must have a \"category\" field of type string.');\n  }\n\n  // If basic structure is invalid, return early\n  if (result.errors.length > 0) {\n    return result;\n  }\n\n  // Validate characters array\n  const characters = parsedData.characters as any[];\n  if (characters.length === 0) {\n    result.errors.push('Character palette must contain at least one character.');\n  }\n\n  // Check each character\n  const invalidCharacters: string[] = [];\n  const duplicateCharacters: string[] = [];\n  const characterCounts: Record<string, number> = {};\n\n  characters.forEach((char, index) => {\n    if (!isValidCharacter(char)) {\n      invalidCharacters.push(`Position ${index}: \"${char}\"`);\n    } else {\n      characterCounts[char] = (characterCounts[char] || 0) + 1;\n      if (characterCounts[char] === 2) {\n        duplicateCharacters.push(char);\n      }\n    }\n  });\n\n  if (invalidCharacters.length > 0) {\n    result.errors.push(\n      `Invalid characters found (must be single characters): ${invalidCharacters.join(', ')}`\n    );\n  }\n\n  // Validate category\n  const validCategories = ['ascii', 'unicode', 'blocks', 'custom'];\n  if (!validCategories.includes(parsedData.category)) {\n    result.errors.push(\n      `Invalid category \"${parsedData.category}\". Must be one of: ${validCategories.join(', ')}`\n    );\n  }\n\n  // Warnings for duplicates\n  if (duplicateCharacters.length > 0) {\n    result.warnings.push(\n      `Duplicate characters found: ${duplicateCharacters.map(c => c === ' ' ? '␣' : c).join(', ')}`\n    );\n  }\n\n  // Warning for very large palettes\n  if (characters.length > 50) {\n    result.warnings.push(\n      `Large character palette (${characters.length} characters). Consider splitting into smaller palettes for better performance.`\n    );\n  }\n\n  // Warning for empty name\n  if (parsedData.name.trim().length === 0) {\n    result.errors.push('Character palette name cannot be empty.');\n  }\n\n  // If no errors, it's valid\n  if (result.errors.length === 0) {\n    result.isValid = true;\n    result.data = parsedData as CharacterPaletteExportFormat;\n  }\n\n  return result;\n};\n\n/**\n * Get a human-readable summary of validation results\n */\nexport const getCharacterValidationSummary = (validation: CharacterValidationResult): string => {\n  if (!validation.data) return 'Invalid character palette data';\n  \n  const { data } = validation;\n  const characterCount = data.characters.length;\n  const uniqueCount = new Set(data.characters).size;\n  \n  let summary = `Valid character palette \"${data.name}\" with ${characterCount} character${characterCount !== 1 ? 's' : ''}`;\n  \n  if (uniqueCount !== characterCount) {\n    summary += ` (${uniqueCount} unique)`;\n  }\n  \n  summary += ` in ${data.category} category.`;\n  \n  return summary;\n};\n\n/**\n * Sanitize character palette data for import\n */\nexport const sanitizeCharacterPaletteData = (data: CharacterPaletteExportFormat): CharacterPaletteExportFormat => {\n  // Remove duplicates while preserving order\n  const uniqueCharacters: string[] = [];\n  const seen = new Set<string>();\n  \n  data.characters.forEach(char => {\n    if (!seen.has(char)) {\n      seen.add(char);\n      uniqueCharacters.push(char);\n    }\n  });\n  \n  return {\n    name: data.name.trim() || 'Imported Palette',\n    characters: uniqueCharacters,\n    category: data.category\n  };\n};\n\n/**\n * Validate character palette name for export filename\n */\nexport const sanitizeCharacterPaletteNameForFileName = (name: string): string => {\n  return name\n    .trim()\n    .replace(/[^a-zA-Z0-9\\s\\-_]/g, '') // Remove special characters\n    .replace(/\\s+/g, '-') // Replace spaces with hyphens\n    .replace(/-+/g, '-') // Replace multiple hyphens with single\n    .replace(/^-|-$/g, '') // Remove leading/trailing hyphens\n    .toLowerCase()\n    .substring(0, 50) || 'character-palette'; // Fallback name\n};","usedDeprecatedRules":[]},{"filePath":"/Users/cameronfoxly/GitHubRepos/Ascii-Motion/src/utils/clipboardUtils.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/cameronfoxly/GitHubRepos/Ascii-Motion/src/utils/colorConversion.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/cameronfoxly/GitHubRepos/Ascii-Motion/src/utils/dirtyTracker.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/cameronfoxly/GitHubRepos/Ascii-Motion/src/utils/effectsProcessing.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'_canvasWidth' is defined but never used.","line":25,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":25,"endColumn":15},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'_canvasHeight' is defined but never used.","line":26,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":26,"endColumn":16},{"ruleId":"no-case-declarations","severity":2,"message":"Unexpected lexical declaration in case block.","line":36,"column":9,"nodeType":"VariableDeclaration","messageId":"unexpected","endLine":36,"endColumn":91,"suggestions":[{"messageId":"addBrackets","fix":{"range":[1054,1245],"text":"{ const result = await processLevelsEffect(cells, settings as LevelsEffectSettings);\n        processedCells = result.processedCells;\n        affectedCells = result.affectedCells;\n        break; }"},"desc":"Add {} brackets around the case block."}]},{"ruleId":"no-case-declarations","severity":2,"message":"Unexpected lexical declaration in case block.","line":42,"column":9,"nodeType":"VariableDeclaration","messageId":"unexpected","endLine":42,"endColumn":107,"suggestions":[{"messageId":"addBrackets","fix":{"range":[1292,1503],"text":"{ const hsResult = await processHueSaturationEffect(cells, settings as HueSaturationEffectSettings);\n        processedCells = hsResult.processedCells;\n        affectedCells = hsResult.affectedCells;\n        break; }"},"desc":"Add {} brackets around the case block."}]},{"ruleId":"no-case-declarations","severity":2,"message":"Unexpected lexical declaration in case block.","line":48,"column":9,"nodeType":"VariableDeclaration","messageId":"unexpected","endLine":48,"endColumn":103,"suggestions":[{"messageId":"addBrackets","fix":{"range":[1548,1755],"text":"{ const rcResult = await processRemapColorsEffect(cells, settings as RemapColorsEffectSettings);\n        processedCells = rcResult.processedCells;\n        affectedCells = rcResult.affectedCells;\n        break; }"},"desc":"Add {} brackets around the case block."}]},{"ruleId":"no-case-declarations","severity":2,"message":"Unexpected lexical declaration in case block.","line":54,"column":9,"nodeType":"VariableDeclaration","messageId":"unexpected","endLine":54,"endColumn":112,"suggestions":[{"messageId":"addBrackets","fix":{"range":[1804,2022],"text":"{ const rchResult = await processRemapCharactersEffect(cells, settings as RemapCharactersEffectSettings);\n        processedCells = rchResult.processedCells;\n        affectedCells = rchResult.affectedCells;\n        break; }"},"desc":"Add {} brackets around the case block."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":321,"column":56,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":321,"endColumn":59,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9459,9462],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9459,9462],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":7,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * effectsProcessing.ts - Core effect processing algorithms for ASCII Motion\n * \n * Provides functions to apply each effect type to canvas data, supporting\n * both single frame and timeline application with proper error handling.\n */\n\nimport type { Cell, Frame } from '../types';\nimport type { \n  EffectType, \n  LevelsEffectSettings, \n  HueSaturationEffectSettings,\n  RemapColorsEffectSettings,\n  RemapCharactersEffectSettings,\n  EffectProcessingResult \n} from '../types/effects';\n\n/**\n * Main effect processing function - applies an effect to canvas data\n */\nexport async function processEffect(\n  effectType: EffectType,\n  cells: Map<string, Cell>,\n  settings: LevelsEffectSettings | HueSaturationEffectSettings | RemapColorsEffectSettings | RemapCharactersEffectSettings,\n  _canvasWidth: number,\n  _canvasHeight: number\n): Promise<EffectProcessingResult> {\n  const startTime = performance.now();\n  \n  try {\n    let processedCells: Map<string, Cell> | null = null;\n    let affectedCells = 0;\n\n    switch (effectType) {\n      case 'levels':\n        const result = await processLevelsEffect(cells, settings as LevelsEffectSettings);\n        processedCells = result.processedCells;\n        affectedCells = result.affectedCells;\n        break;\n        \n      case 'hue-saturation':\n        const hsResult = await processHueSaturationEffect(cells, settings as HueSaturationEffectSettings);\n        processedCells = hsResult.processedCells;\n        affectedCells = hsResult.affectedCells;\n        break;\n        \n      case 'remap-colors':\n        const rcResult = await processRemapColorsEffect(cells, settings as RemapColorsEffectSettings);\n        processedCells = rcResult.processedCells;\n        affectedCells = rcResult.affectedCells;\n        break;\n        \n      case 'remap-characters':\n        const rchResult = await processRemapCharactersEffect(cells, settings as RemapCharactersEffectSettings);\n        processedCells = rchResult.processedCells;\n        affectedCells = rchResult.affectedCells;\n        break;\n        \n      default:\n        throw new Error(`Unknown effect type: ${effectType}`);\n    }\n\n    const processingTime = performance.now() - startTime;\n\n    return {\n      success: true,\n      processedCells,\n      affectedCells,\n      processingTime,\n    };\n\n  } catch (error) {\n    const processingTime = performance.now() - startTime;\n    console.error(`Effect processing failed for ${effectType}:`, error);\n    \n    return {\n      success: false,\n      processedCells: null,\n      affectedCells: 0,\n      processingTime,\n      error: error instanceof Error ? error.message : 'Unknown processing error'\n    };\n  }\n}\n\n/**\n * Process multiple frames with an effect (for timeline application)\n */\nexport async function processEffectOnFrames(\n  effectType: EffectType,\n  frames: Frame[],\n  settings: LevelsEffectSettings | HueSaturationEffectSettings | RemapColorsEffectSettings | RemapCharactersEffectSettings,\n  canvasWidth: number,\n  canvasHeight: number,\n  onProgress?: (frameIndex: number, totalFrames: number) => void\n): Promise<{ processedFrames: Frame[], totalAffectedCells: number, processingTime: number, errors: string[] }> {\n  const startTime = performance.now();\n  const processedFrames: Frame[] = [];\n  const errors: string[] = [];\n  let totalAffectedCells = 0;\n\n  for (let i = 0; i < frames.length; i++) {\n    const frame = frames[i];\n    onProgress?.(i, frames.length);\n\n    try {\n      const result = await processEffect(effectType, frame.data, settings, canvasWidth, canvasHeight);\n      \n      if (result.success && result.processedCells) {\n        processedFrames.push({\n          ...frame,\n          data: result.processedCells\n        });\n        totalAffectedCells += result.affectedCells;\n      } else {\n        // Keep original frame if processing failed\n        processedFrames.push(frame);\n        if (result.error) {\n          errors.push(`Frame ${i}: ${result.error}`);\n        }\n      }\n    } catch (error) {\n      processedFrames.push(frame);\n      errors.push(`Frame ${i}: ${error instanceof Error ? error.message : 'Unknown error'}`);\n    }\n  }\n\n  const processingTime = performance.now() - startTime;\n\n  return {\n    processedFrames,\n    totalAffectedCells,\n    processingTime,\n    errors\n  };\n}\n\n/**\n * Levels Effect Processing\n */\nasync function processLevelsEffect(\n  cells: Map<string, Cell>,\n  settings: LevelsEffectSettings\n): Promise<{ processedCells: Map<string, Cell>, affectedCells: number }> {\n  const processedCells = new Map<string, Cell>();\n  let affectedCells = 0;\n\n  const {\n    shadowsInput,\n    midtonesInput,\n    highlightsInput,\n    outputMin,\n    outputMax,\n    colorRange\n  } = settings;\n\n  cells.forEach((cell, position) => {\n    const newCell = { ...cell };\n    let cellModified = false;\n\n    // Apply levels to foreground color\n    if (cell.color && shouldProcessColor(cell.color, colorRange)) {\n      const adjustedColor = applyLevelsToColor(\n        cell.color,\n        shadowsInput,\n        midtonesInput,\n        highlightsInput,\n        outputMin,\n        outputMax\n      );\n      if (adjustedColor !== cell.color) {\n        newCell.color = adjustedColor;\n        cellModified = true;\n      }\n    }\n\n    // Apply levels to background color\n    if (cell.bgColor && cell.bgColor !== 'transparent' && shouldProcessColor(cell.bgColor, colorRange)) {\n      const adjustedBgColor = applyLevelsToColor(\n        cell.bgColor,\n        shadowsInput,\n        midtonesInput,\n        highlightsInput,\n        outputMin,\n        outputMax\n      );\n      if (adjustedBgColor !== cell.bgColor) {\n        newCell.bgColor = adjustedBgColor;\n        cellModified = true;\n      }\n    }\n\n    processedCells.set(position, newCell);\n    if (cellModified) affectedCells++;\n  });\n\n  return { processedCells, affectedCells };\n}\n\n/**\n * Hue & Saturation Effect Processing\n */\nasync function processHueSaturationEffect(\n  cells: Map<string, Cell>,\n  settings: HueSaturationEffectSettings\n): Promise<{ processedCells: Map<string, Cell>, affectedCells: number }> {\n  const processedCells = new Map<string, Cell>();\n  let affectedCells = 0;\n\n  const { hue, saturation, lightness, colorRange } = settings;\n\n  cells.forEach((cell, position) => {\n    const newCell = { ...cell };\n    let cellModified = false;\n\n    // Apply HSL adjustments to foreground color\n    if (cell.color && shouldProcessColor(cell.color, colorRange)) {\n      const adjustedColor = applyHSLAdjustments(cell.color, hue, saturation, lightness);\n      if (adjustedColor !== cell.color) {\n        newCell.color = adjustedColor;\n        cellModified = true;\n      }\n    }\n\n    // Apply HSL adjustments to background color\n    if (cell.bgColor && cell.bgColor !== 'transparent' && shouldProcessColor(cell.bgColor, colorRange)) {\n      const adjustedBgColor = applyHSLAdjustments(cell.bgColor, hue, saturation, lightness);\n      if (adjustedBgColor !== cell.bgColor) {\n        newCell.bgColor = adjustedBgColor;\n        cellModified = true;\n      }\n    }\n\n    processedCells.set(position, newCell);\n    if (cellModified) affectedCells++;\n  });\n\n  return { processedCells, affectedCells };\n}\n\n/**\n * Remap Colors Effect Processing\n */\nasync function processRemapColorsEffect(\n  cells: Map<string, Cell>,\n  settings: RemapColorsEffectSettings\n): Promise<{ processedCells: Map<string, Cell>, affectedCells: number }> {\n  const processedCells = new Map<string, Cell>();\n  let affectedCells = 0;\n\n  const { colorMappings, matchExact } = settings;\n\n  cells.forEach((cell, position) => {\n    const newCell = { ...cell };\n    let cellModified = false;\n\n    // Remap foreground color\n    if (cell.color) {\n      const mappedColor = findColorMapping(cell.color, colorMappings, matchExact);\n      if (mappedColor && mappedColor !== cell.color) {\n        newCell.color = mappedColor;\n        cellModified = true;\n      }\n    }\n\n    // Remap background color\n    if (cell.bgColor && cell.bgColor !== 'transparent') {\n      const mappedBgColor = findColorMapping(cell.bgColor, colorMappings, matchExact);\n      if (mappedBgColor && mappedBgColor !== cell.bgColor) {\n        newCell.bgColor = mappedBgColor;\n        cellModified = true;\n      }\n    }\n\n    processedCells.set(position, newCell);\n    if (cellModified) affectedCells++;\n  });\n\n  return { processedCells, affectedCells };\n}\n\n/**\n * Remap Characters Effect Processing\n */\nasync function processRemapCharactersEffect(\n  cells: Map<string, Cell>,\n  settings: RemapCharactersEffectSettings\n): Promise<{ processedCells: Map<string, Cell>, affectedCells: number }> {\n  const processedCells = new Map<string, Cell>();\n  let affectedCells = 0;\n\n  const { characterMappings } = settings;\n\n  cells.forEach((cell, position) => {\n    const newCell = { ...cell };\n    let cellModified = false;\n\n    // Remap character\n    if (cell.char && characterMappings[cell.char]) {\n      const mappedChar = characterMappings[cell.char];\n      if (mappedChar !== cell.char) {\n        newCell.char = mappedChar;\n        cellModified = true;\n      }\n    }\n\n    processedCells.set(position, newCell);\n    if (cellModified) affectedCells++;\n  });\n\n  return { processedCells, affectedCells };\n}\n\n// =============================================================================\n// Color Processing Utilities\n// =============================================================================\n\n/**\n * Check if a color should be processed based on color range settings\n */\nfunction shouldProcessColor(color: string, colorRange: any): boolean {\n  if (!colorRange || colorRange.type === 'all') {\n    return true;\n  }\n  \n  if (colorRange.type === 'custom' && colorRange.customColors) {\n    return colorRange.customColors.includes(color);\n  }\n  \n  // For 'text' and 'background' types, we'd need context about which colors are text vs background\n  // For now, process all colors\n  return true;\n}\n\n/**\n * Apply levels adjustment to a single color\n */\nfunction applyLevelsToColor(\n  color: string,\n  shadowsInput: number,\n  midtonesInput: number,\n  highlightsInput: number,\n  outputMin: number,\n  outputMax: number\n): string {\n  const rgb = hexToRgb(color);\n  if (!rgb) return color;\n\n  // Apply levels to each channel\n  const adjustedR = applyLevelsToChannel(rgb.r, shadowsInput, midtonesInput, highlightsInput, outputMin, outputMax);\n  const adjustedG = applyLevelsToChannel(rgb.g, shadowsInput, midtonesInput, highlightsInput, outputMin, outputMax);\n  const adjustedB = applyLevelsToChannel(rgb.b, shadowsInput, midtonesInput, highlightsInput, outputMin, outputMax);\n\n  return rgbToHex(adjustedR, adjustedG, adjustedB);\n}\n\n/**\n * Apply levels adjustment to a single color channel\n */\nfunction applyLevelsToChannel(\n  value: number,\n  shadowsInput: number,\n  midtonesInput: number,\n  highlightsInput: number,\n  outputMin: number,\n  outputMax: number\n): number {\n  // Validate input range - prevent division by zero\n  if (highlightsInput <= shadowsInput) {\n    // Invalid range: highlights must be greater than shadows\n    // Return value unchanged to prevent processing errors\n    return Math.round(Math.max(0, Math.min(255, value)));\n  }\n  \n  // Clamp input to shadows-highlights range\n  if (value <= shadowsInput) return outputMin;\n  if (value >= highlightsInput) return outputMax;\n  \n  // Apply gamma correction for midtones\n  const normalizedInput = (value - shadowsInput) / (highlightsInput - shadowsInput);\n  const gammaAdjusted = Math.pow(normalizedInput, 1.0 / midtonesInput);\n  \n  // Map to output range\n  const result = outputMin + (gammaAdjusted * (outputMax - outputMin));\n  \n  return Math.round(Math.max(0, Math.min(255, result)));\n}\n\n/**\n * Apply HSL adjustments to a color\n */\nfunction applyHSLAdjustments(color: string, hueShift: number, saturationShift: number, lightnessShift: number): string {\n  const hsl = hexToHsl(color);\n  if (!hsl) return color;\n\n  // Apply adjustments\n  let newHue = (hsl.h + hueShift) % 360;\n  if (newHue < 0) newHue += 360;\n  \n  const newSaturation = Math.max(0, Math.min(100, hsl.s + saturationShift));\n  const newLightness = Math.max(0, Math.min(100, hsl.l + lightnessShift));\n\n  return hslToHex(newHue, newSaturation, newLightness);\n}\n\n/**\n * Find a color mapping, supporting exact and fuzzy matching\n */\nfunction findColorMapping(color: string, mappings: Record<string, string>, exactMatch: boolean): string | null {\n  // Direct exact match\n  if (mappings[color]) {\n    return mappings[color];\n  }\n  \n  if (!exactMatch) {\n    // Try case-insensitive match\n    const lowerColor = color.toLowerCase();\n    const lowerMappings = Object.entries(mappings).find(([key]) => key.toLowerCase() === lowerColor);\n    if (lowerMappings) {\n      return lowerMappings[1];\n    }\n    \n    // Try without # prefix\n    if (color.startsWith('#')) {\n      const withoutHash = color.slice(1);\n      if (mappings[withoutHash]) {\n        return mappings[withoutHash];\n      }\n    } else {\n      const withHash = '#' + color;\n      if (mappings[withHash]) {\n        return mappings[withHash];\n      }\n    }\n  }\n  \n  return null;\n}\n\n// =============================================================================\n// Color Conversion Utilities\n// =============================================================================\n\n/**\n * Convert hex color to RGB\n */\nfunction hexToRgb(hex: string): { r: number; g: number; b: number } | null {\n  const result = /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i.exec(hex);\n  return result ? {\n    r: parseInt(result[1], 16),\n    g: parseInt(result[2], 16),\n    b: parseInt(result[3], 16)\n  } : null;\n}\n\n/**\n * Convert RGB to hex\n */\nfunction rgbToHex(r: number, g: number, b: number): string {\n  const toHex = (n: number) => {\n    const hex = Math.round(Math.max(0, Math.min(255, n))).toString(16);\n    return hex.length === 1 ? '0' + hex : hex;\n  };\n  return `#${toHex(r)}${toHex(g)}${toHex(b)}`;\n}\n\n/**\n * Convert hex color to HSL\n */\nfunction hexToHsl(hex: string): { h: number; s: number; l: number } | null {\n  const rgb = hexToRgb(hex);\n  if (!rgb) return null;\n\n  const r = rgb.r / 255;\n  const g = rgb.g / 255;\n  const b = rgb.b / 255;\n\n  const max = Math.max(r, g, b);\n  const min = Math.min(r, g, b);\n  let h = 0;\n  let s = 0;\n  const l = (max + min) / 2;\n\n  if (max !== min) {\n    const d = max - min;\n    s = l > 0.5 ? d / (2 - max - min) : d / (max + min);\n\n    switch (max) {\n      case r: h = (g - b) / d + (g < b ? 6 : 0); break;\n      case g: h = (b - r) / d + 2; break;\n      case b: h = (r - g) / d + 4; break;\n    }\n    h /= 6;\n  }\n\n  return {\n    h: Math.round(h * 360),\n    s: Math.round(s * 100),\n    l: Math.round(l * 100)\n  };\n}\n\n/**\n * Convert HSL to hex\n */\nfunction hslToHex(h: number, s: number, l: number): string {\n  h = h / 360;\n  s = s / 100;\n  l = l / 100;\n\n  const hue2rgb = (p: number, q: number, t: number) => {\n    if (t < 0) t += 1;\n    if (t > 1) t -= 1;\n    if (t < 1/6) return p + (q - p) * 6 * t;\n    if (t < 1/2) return q;\n    if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;\n    return p;\n  };\n\n  let r, g, b;\n\n  if (s === 0) {\n    r = g = b = l; // achromatic\n  } else {\n    const q = l < 0.5 ? l * (1 + s) : l + s - l * s;\n    const p = 2 * l - q;\n    r = hue2rgb(p, q, h + 1/3);\n    g = hue2rgb(p, q, h);\n    b = hue2rgb(p, q, h - 1/3);\n  }\n\n  return rgbToHex(Math.round(r * 255), Math.round(g * 255), Math.round(b * 255));\n}","usedDeprecatedRules":[]},{"filePath":"/Users/cameronfoxly/GitHubRepos/Ascii-Motion/src/utils/exportDataCollector.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/cameronfoxly/GitHubRepos/Ascii-Motion/src/utils/exportPixelCalculator.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/cameronfoxly/GitHubRepos/Ascii-Motion/src/utils/exportRenderer.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'error' is defined but never used.","line":117,"column":18,"nodeType":null,"messageId":"unusedVar","endLine":117,"endColumn":23},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":117,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":117,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3754,3757],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3754,3757],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"prefer-const","severity":2,"message":"'processedGrid' is never reassigned. Use 'const' instead.","line":407,"column":13,"nodeType":"Identifier","messageId":"useConst","endLine":407,"endColumn":26,"fix":{"range":[13495,13545],"text":"const processedGrid = this.cropGrid(grid, settings);"}},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":461,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":461,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[15161,15164],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[15161,15164],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":510,"column":26,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":510,"endColumn":29,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[16898,16901],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[16898,16901],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":541,"column":23,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":541,"endColumn":26,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[17907,17910],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[17907,17910],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":1737,"column":18,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":1737,"endColumn":21,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[60330,60333],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[60330,60333],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":1738,"column":17,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":1738,"endColumn":20,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[60351,60354],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[60351,60354],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":1792,"column":20,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":1792,"endColumn":23,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[62417,62420],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[62417,62420],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":1793,"column":19,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":1793,"endColumn":22,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[62440,62443],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[62440,62443],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":10,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":1,"fixableWarningCount":0,"source":"import { saveAs } from 'file-saver';\nimport type { Font } from 'opentype.js';\nimport type { \n  ExportDataBundle, \n  ImageExportSettings, \n  VideoExportSettings, \n  SessionExportSettings,\n  TextExportSettings,\n  JsonExportSettings,\n  HtmlExportSettings,\n  ReactExportSettings,\n  ExportProgress \n} from '../types/export';\nimport type { Cell } from '../types';\nimport { setupTextRendering } from './canvasTextRendering';\nimport { calculateAdaptiveGridColor } from './gridColor';\nimport { \n  generateSvgHeader, \n  generateSvgGrid, \n  generateSvgTextElement, \n  convertTextToPath,\n  minifySvg\n} from './svgExportUtils';\n\n/**\n * High-quality export renderer for ASCII Motion\n * Handles image (PNG/JPEG/SVG), MP4, and Session exports with optimal quality settings\n */\nexport class ExportRenderer {\n  private progressCallback?: (progress: ExportProgress) => void;\n\n  constructor(progressCallback?: (progress: ExportProgress) => void) {\n    this.progressCallback = progressCallback;\n  }\n\n  /**\n   * Export current frame as an image (PNG or JPEG)\n   */\n  async exportImage(\n    data: ExportDataBundle,\n    settings: ImageExportSettings,\n    filename: string\n  ): Promise<void> {\n    this.updateProgress('Preparing image export...', 0);\n\n    try {\n      const currentFrame = data.frames[data.currentFrameIndex]?.data || data.canvasData;\n\n      const exportCanvas = this.createExportCanvas(\n        data.canvasDimensions.width,\n        data.canvasDimensions.height,\n        settings.sizeMultiplier,\n        data.fontMetrics,\n        data.typography\n      );\n\n      this.updateProgress('Rendering canvas...', 30);\n\n      await this.renderFrame(\n        exportCanvas.canvas,\n        currentFrame,\n        data.canvasDimensions.width,\n        data.canvasDimensions.height,\n        {\n          backgroundColor: data.canvasBackgroundColor,\n          showGrid: settings.includeGrid && data.showGrid,\n          fontMetrics: data.fontMetrics,\n          typography: data.typography,\n          sizeMultiplier: settings.sizeMultiplier,\n          theme: data.uiState.theme,\n          scale: exportCanvas.scale\n        }\n      );\n\n      this.updateProgress('Converting to image...', 70);\n\n      const mimeType = settings.format === 'jpg' ? 'image/jpeg' : 'image/png';\n      const quality = settings.format === 'jpg' ? Math.min(Math.max(settings.quality, 10), 100) / 100 : undefined;\n      const blob = await this.canvasToBlob(exportCanvas.canvas, mimeType, quality);\n\n      this.updateProgress('Saving file...', 90);\n\n      const extension = settings.format === 'jpg' ? 'jpg' : 'png';\n      saveAs(blob, `${filename}.${extension}`);\n\n      this.updateProgress('Export complete!', 100);\n    } catch (error) {\n      console.error('Image export failed:', error);\n      throw new Error(`Image export failed: ${error instanceof Error ? error.message : 'Unknown error'}`);\n    }\n  }\n\n  /**\n   * Export current frame as SVG (Scalable Vector Graphics)\n   */\n  async exportSvg(\n    data: ExportDataBundle,\n    settings: ImageExportSettings,\n    filename: string\n  ): Promise<void> {\n    this.updateProgress('Preparing SVG export...', 0);\n\n    try {\n      const currentFrame = data.frames[data.currentFrameIndex]?.data || data.canvasData;\n      const svgSettings = settings.svgSettings!;\n\n      // Load font if text-as-outlines is enabled\n      let font: Font | undefined;\n      if (svgSettings.textAsOutlines) {\n        this.updateProgress('Loading font for outlines...', 5);\n        const { fontLoader } = await import('./font/fontLoader');\n        const fontId = svgSettings.outlineFont || 'jetbrains-mono';\n        \n        try {\n          const loadedFont = await fontLoader.loadFont(fontId, { cache: true, timeout: 10000 });\n          font = loadedFont.font;\n        } catch (error: any) {\n          // Font loading failed, will fall back to pixel tracing\n          font = undefined;\n        }\n      }\n\n      // Calculate dimensions using typography settings\n      const actualFontSize = data.typography?.fontSize || data.fontMetrics?.fontSize || 16;\n      const characterSpacing = data.typography?.characterSpacing || 1.0;\n      const lineSpacing = data.typography?.lineSpacing || 1.0;\n      \n      const baseCharWidth = actualFontSize * 0.6; // Standard monospace aspect ratio\n      const baseCharHeight = actualFontSize;\n      \n      const cellWidth = baseCharWidth * characterSpacing;\n      const cellHeight = baseCharHeight * lineSpacing;\n      \n      const canvasWidth = data.canvasDimensions.width * cellWidth;\n      const canvasHeight = data.canvasDimensions.height * cellHeight;\n\n      this.updateProgress('Generating SVG structure...', 20);\n\n      // Start SVG with header\n      let svg = generateSvgHeader(\n        canvasWidth, \n        canvasHeight, \n        svgSettings.includeBackground ? data.canvasBackgroundColor : undefined\n      );\n\n      // Add grid if enabled\n      if (svgSettings.includeGrid) {\n        this.updateProgress('Rendering grid...', 30);\n        const gridColor = calculateAdaptiveGridColor(\n          data.canvasBackgroundColor, \n          data.uiState.theme as 'light' | 'dark'\n        );\n        svg += generateSvgGrid(\n          data.canvasDimensions.width,\n          data.canvasDimensions.height,\n          cellWidth,\n          cellHeight,\n          gridColor\n        );\n      }\n\n      this.updateProgress('Rendering characters...', 50);\n\n      // Content group\n      svg += '  <g id=\"content\">\\n';\n\n      const fontFamily = data.fontMetrics?.fontFamily || 'SF Mono, Monaco, Inconsolata, Roboto Mono, Consolas, Courier New';\n\n      // Render each cell\n      let cellCount = 0;\n      const totalCells = currentFrame.size;\n      \n      currentFrame.forEach((cell, key) => {\n        const [x, y] = key.split(',').map(Number);\n        \n        if (cell.char) {\n          if (svgSettings.textAsOutlines) {\n            svg += convertTextToPath(\n              cell.char,\n              x, y,\n              cell.color || '#ffffff',\n              cell.bgColor,\n              cellWidth,\n              cellHeight,\n              actualFontSize,\n              fontFamily,\n              font // Pass the loaded font for opentype.js conversion\n            );\n          } else {\n            svg += generateSvgTextElement(\n              cell.char,\n              x, y,\n              cell.color || '#ffffff',\n              cell.bgColor,\n              cellWidth,\n              cellHeight,\n              actualFontSize,\n              fontFamily\n            );\n          }\n        }\n        \n        cellCount++;\n        if (cellCount % 100 === 0) {\n          const progress = 50 + Math.floor((cellCount / totalCells) * 30);\n          this.updateProgress(`Rendering characters... (${cellCount}/${totalCells})`, progress);\n        }\n      });\n\n      svg += '  </g>\\n';\n      svg += '</svg>';\n\n      this.updateProgress('Formatting SVG...', 85);\n\n      // Minify if not prettify (SVG is already prettified during generation)\n      if (!svgSettings.prettify) {\n        svg = minifySvg(svg);\n      }\n\n      this.updateProgress('Saving file...', 95);\n\n      // Create blob and download\n      const blob = new Blob([svg], { type: 'image/svg+xml;charset=utf-8' });\n      saveAs(blob, `${filename}.svg`);\n\n      this.updateProgress('Export complete!', 100);\n    } catch (error) {\n      console.error('SVG export failed:', error);\n      throw new Error(`SVG export failed: ${error instanceof Error ? error.message : 'Unknown error'}`);\n    }\n  }\n\n  /**\n   * Export animation as video (WebM/MP4)\n   */\n  async exportVideo(\n    data: ExportDataBundle, \n    settings: VideoExportSettings, \n    filename: string\n  ): Promise<void> {\n    this.updateProgress('Preparing video export...', 0);\n\n    try {\n      // Check if we have frames to export\n      if (data.frames.length === 0) {\n        throw new Error('No frames to export');\n      }\n\n      // Check WebCodecs support for WebM\n      if (settings.format === 'webm' && !this.supportsWebCodecs()) {\n        throw new Error('WebCodecs is not supported in your browser. Please use a modern Chrome, Edge, or Safari browser, or switch to MP4 format.');\n      }\n\n      this.updateProgress('Setting up video encoder...', 10);\n\n      if (settings.format === 'webm') {\n        await this.exportWebMVideo(data, settings, filename);\n      } else {\n        // MP4 fallback using canvas frame capture and blob creation\n        await this.exportMP4Fallback(data, settings, filename);\n      }\n      \n    } catch (error) {\n      console.error('Video export failed:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Export complete session as JSON file\n   */\n  async exportSession(\n    data: ExportDataBundle, \n    settings: SessionExportSettings, \n    filename: string\n  ): Promise<void> {\n    this.updateProgress('Preparing session export...', 0);\n\n    try {\n      this.updateProgress('Serializing data...', 30);\n\n      // Create session data structure\n      const sessionData = {\n        version: '1.0.0',\n        metadata: settings.includeMetadata ? {\n          exportedAt: new Date().toISOString(),\n          exportVersion: '1.0.0',\n          userAgent: navigator.userAgent\n        } : undefined,\n        canvas: {\n          width: data.canvasDimensions.width,\n          height: data.canvasDimensions.height,\n          canvasBackgroundColor: data.canvasBackgroundColor,\n          showGrid: data.showGrid\n        },\n        animation: {\n          frames: data.frames.map(frame => ({\n            id: frame.id,\n            name: frame.name,\n            duration: frame.duration,\n            data: Object.fromEntries(frame.data.entries())\n          })),\n          currentFrameIndex: data.currentFrameIndex,\n          frameRate: data.frameRate,\n          looping: data.looping\n        },\n        tools: {\n          activeTool: data.toolState.activeTool,\n          selectedCharacter: data.toolState.selectedCharacter,\n          selectedColor: data.toolState.selectedColor,\n          selectedBgColor: data.toolState.selectedBgColor,\n          paintBucketContiguous: data.toolState.paintBucketContiguous,\n          rectangleFilled: data.toolState.rectangleFilled\n        },\n        ui: {\n          theme: data.uiState.theme,\n          zoom: data.uiState.zoom,\n          panOffset: data.uiState.panOffset,\n          fontMetrics: data.fontMetrics\n        },\n        typography: {\n          fontSize: data.typography.fontSize,\n          characterSpacing: data.typography.characterSpacing,\n          lineSpacing: data.typography.lineSpacing\n        },\n        palettes: data.paletteState ? {\n          activePaletteId: data.paletteState.activePaletteId,\n          customPalettes: data.paletteState.customPalettes,\n          recentColors: data.paletteState.recentColors\n        } : undefined,\n        characterPalettes: data.characterPaletteState ? {\n          activePaletteId: data.characterPaletteState.activePaletteId,\n          customPalettes: data.characterPaletteState.customPalettes.map(palette => ({\n            ...palette,\n            characters: [...palette.characters]\n          })),\n          mappingMethod: data.characterPaletteState.mappingMethod,\n          invertDensity: data.characterPaletteState.invertDensity,\n          characterSpacing: data.characterPaletteState.characterSpacing\n        } : undefined\n      };\n\n      this.updateProgress('Converting to JSON...', 70);\n\n      // Convert to JSON string\n      const jsonString = JSON.stringify(sessionData, null, 2);\n      \n      this.updateProgress('Creating file...', 90);\n\n      // Create blob and download\n      const blob = new Blob([jsonString], { type: 'application/json' });\n      saveAs(blob, `${filename}.asciimtn`);\n      \n      this.updateProgress('Export complete!', 100);\n    } catch (error) {\n      console.error('Session export failed:', error);\n      throw new Error(`Session export failed: ${error instanceof Error ? error.message : 'Unknown error'}`);\n    }\n  }\n\n  /**\n   * Export animation frames as simple text\n   */\n  async exportText(\n    data: ExportDataBundle, \n    settings: TextExportSettings, \n    filename: string\n  ): Promise<void> {\n    this.updateProgress('Preparing text export...', 0);\n\n    try {\n      this.updateProgress('Processing frames...', 20);\n\n      const textLines: string[] = [];\n\n      // Add metadata header if requested\n      if (settings.includeMetadata) {\n        textLines.push('ASCII Motion Text Export');\n        textLines.push(`Version: ${data.metadata.version}`);\n        textLines.push(`Export Date: ${data.metadata.exportDate}`);\n        textLines.push(`Frames: ${data.frames.length}`);\n        textLines.push(`Canvas Size: ${data.canvasDimensions.width}x${data.canvasDimensions.height}`);\n        textLines.push('');\n        textLines.push('---');\n        textLines.push('');\n      }\n\n      // Process each frame\n      for (let frameIndex = 0; frameIndex < data.frames.length; frameIndex++) {\n        const frame = data.frames[frameIndex];\n        const frameData = frame.data;\n\n        this.updateProgress(`Processing frame ${frameIndex + 1}...`, 20 + (frameIndex / data.frames.length) * 60);\n\n        // Convert frame to 2D array of characters\n        const grid: string[][] = [];\n        for (let y = 0; y < data.canvasDimensions.height; y++) {\n          grid[y] = [];\n          for (let x = 0; x < data.canvasDimensions.width; x++) {\n            const cellKey = `${x},${y}`;\n            const cell = frameData.get(cellKey);\n            grid[y][x] = cell?.char || ' '; // Use space for empty cells\n          }\n        }\n\n        // Apply cropping settings\n        let processedGrid = this.cropGrid(grid, settings);\n\n        // Convert grid to text lines\n        const frameTextLines = processedGrid.map(row => {\n          let line = row.join('');\n          // Apply trailing space removal if enabled\n          if (settings.removeTrailingSpaces) {\n            line = line.replace(/\\s+$/, '');\n          }\n          return line;\n        });\n\n        // Add frame text to output\n        textLines.push(...frameTextLines);\n\n        // Add frame separator (except for last frame)\n        if (frameIndex < data.frames.length - 1) {\n          textLines.push('');\n          textLines.push(',');\n          textLines.push('');\n        }\n      }\n\n      this.updateProgress('Creating text file...', 90);\n\n      // Join all lines with newlines and create blob\n      const textContent = textLines.join('\\n');\n      const blob = new Blob([textContent], { type: 'text/plain; charset=utf-8' });\n      \n      this.updateProgress('Saving file...', 95);\n      \n      saveAs(blob, `${filename}.txt`);\n      \n      this.updateProgress('Export complete!', 100);\n    } catch (error) {\n      console.error('Text export failed:', error);\n      throw new Error(`Text export failed: ${error instanceof Error ? error.message : 'Unknown error'}`);\n    }\n  }\n\n  /**\n   * Export project data as human-readable JSON\n   */\n  async exportJson(\n    data: ExportDataBundle, \n    settings: JsonExportSettings, \n    filename: string\n  ): Promise<void> {\n    this.updateProgress('Preparing JSON export...', 0);\n\n    try {\n      this.updateProgress('Serializing project data...', 30);\n\n      // Create frames with text content and separate color data\n      const frames: any[] = [];\n\n      data.frames.forEach((frame, index) => {\n        this.updateProgress(`Processing frame ${index + 1}...`, 30 + (index / data.frames.length) * 40);\n        \n        // Build frame content as text lines\n        const lines: string[] = [];\n        const foregroundColors: { [key: string]: string } = {};\n        const backgroundColors: { [key: string]: string } = {};\n\n        // Process each row\n        for (let y = 0; y < data.canvasDimensions.height; y++) {\n          let line = '';\n          \n          for (let x = 0; x < data.canvasDimensions.width; x++) {\n            const cellKey = `${x},${y}`;\n            const cell = frame.data.get(cellKey);\n            \n            const character = cell?.char || ' ';\n            const fgColor = cell?.color || '#FFFFFF';\n            const bgColor = cell?.bgColor || 'transparent';\n\n            // Add character to line\n            line += character;\n\n            // Store color data only for non-empty/non-space cells\n            if (character !== ' ' && character !== '') {\n              if (fgColor !== '#FFFFFF') {\n                foregroundColors[`${x},${y}`] = fgColor;\n              }\n              if (bgColor !== 'transparent' && bgColor !== '#000000') {\n                backgroundColors[`${x},${y}`] = bgColor;\n              }\n            }\n          }\n          \n          // Remove trailing spaces from line\n          lines.push(line.replace(/\\s+$/, ''));\n        }\n\n        // Remove trailing empty lines\n        while (lines.length > 0 && lines[lines.length - 1] === '') {\n          lines.pop();\n        }\n\n        const contentLines = [...lines];\n        const joinedContent = contentLines.join('\\n');\n\n        // Create frame object\n        const frameData: any = {\n          title: `Frame ${index}`,\n          duration: frame.duration,\n          content: settings.humanReadable ? contentLines : joinedContent\n        };\n\n        if (settings.humanReadable) {\n          frameData.contentString = joinedContent;\n        }\n\n        // Add color data if present\n        if (Object.keys(foregroundColors).length > 0 || Object.keys(backgroundColors).length > 0) {\n          frameData.colors = {};\n          \n          if (Object.keys(foregroundColors).length > 0) {\n            frameData.colors.foreground = settings.humanReadable\n              ? JSON.stringify(foregroundColors)\n              : foregroundColors;\n          }\n          \n          if (Object.keys(backgroundColors).length > 0) {\n            frameData.colors.background = settings.humanReadable\n              ? JSON.stringify(backgroundColors)\n              : backgroundColors;\n          }\n        }\n\n        frames.push(frameData);\n      });\n\n      // Create the final JSON structure\n      const jsonData: any = {\n        ...(settings.includeMetadata && {\n          metadata: {\n            exportedAt: new Date().toISOString(),\n            exportVersion: '1.0.0',\n            appVersion: data.metadata.version,\n            description: 'ASCII Motion Animation - Human Readable Format',\n            title: filename,\n            frameCount: data.frames.length,\n            canvasSize: {\n              width: data.canvasDimensions.width,\n              height: data.canvasDimensions.height\n            }\n          }\n        }),\n\n        canvas: {\n          width: data.canvasDimensions.width,\n          height: data.canvasDimensions.height,\n          backgroundColor: data.canvasBackgroundColor\n        },\n\n        typography: {\n          fontSize: data.typography.fontSize,\n          characterSpacing: data.typography.characterSpacing,\n          lineSpacing: data.typography.lineSpacing\n        },\n\n        animation: {\n          frameRate: data.frameRate,\n          looping: data.looping,\n          currentFrame: data.currentFrameIndex\n        },\n\n        frames\n      };\n\n      this.updateProgress('Converting to JSON...', 80);\n\n      // Convert to JSON string with formatting\n      const jsonString = settings.humanReadable \n        ? JSON.stringify(jsonData, null, 2)\n        : JSON.stringify(jsonData);\n      \n      this.updateProgress('Creating file...', 90);\n\n      // Create blob and download\n      const blob = new Blob([jsonString], { type: 'application/json' });\n      saveAs(blob, `${filename}.json`);\n      \n      this.updateProgress('Export complete!', 100);\n    } catch (error) {\n      console.error('JSON export failed:', error);\n      throw new Error(`JSON export failed: ${error instanceof Error ? error.message : 'Unknown error'}`);\n    }\n  }\n\n  /**\n   * Export animation as standalone HTML file with inline CSS/JS\n   */\n  async exportHtml(\n    data: ExportDataBundle, \n    settings: HtmlExportSettings, \n    filename: string\n  ): Promise<void> {\n    this.updateProgress('Preparing HTML export...', 0);\n\n    try {\n      this.updateProgress('Generating HTML structure...', 20);\n\n      // Prepare frame data as JSON for JavaScript\n      const frameDataJson = JSON.stringify(data.frames.map(frame => {\n        const frameGrid: string[][] = [];\n        const colorGrid: string[][] = [];\n        const bgColorGrid: string[][] = [];\n        \n        // Initialize grids\n        for (let y = 0; y < data.canvasDimensions.height; y++) {\n          frameGrid[y] = [];\n          colorGrid[y] = [];\n          bgColorGrid[y] = [];\n          for (let x = 0; x < data.canvasDimensions.width; x++) {\n            const cellKey = `${x},${y}`;\n            const cell = frame.data.get(cellKey);\n            frameGrid[y][x] = cell?.char || ' ';\n            colorGrid[y][x] = cell?.color || '#FFFFFF';\n            bgColorGrid[y][x] = cell?.bgColor || 'transparent';\n          }\n        }\n        \n        return {\n          id: frame.id,\n          name: frame.name,\n          duration: frame.duration,\n          characters: frameGrid,\n          colors: colorGrid,\n          backgrounds: bgColorGrid\n        };\n      }));\n\n      this.updateProgress('Building CSS styles...', 40);\n\n      const animationDuration = (data.frames.reduce((sum, frame) => sum + frame.duration, 0) / 1000) / settings.animationSpeed;\n\n      // Generate complete HTML document\n      const htmlContent = `<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>${filename} - ASCII Motion Animation</title>\n  <style>\n    :root {\n      color-scheme: dark;\n    }\n\n    * {\n      box-sizing: border-box;\n    }\n\n    body {\n      margin: 0;\n      padding: 32px 24px;\n      background-color: ${settings.backgroundColor};\n      font-family: ${settings.fontFamily}, monospace;\n      font-size: ${settings.fontSize}px;\n      line-height: 1;\n      color: #f8f9fb;\n      display: flex;\n      justify-content: center;\n      align-items: flex-start;\n      min-height: 100vh;\n    }\n\n    .layout {\n      width: min(100%, 960px);\n      display: flex;\n      flex-direction: column;\n      align-items: center;\n      gap: 24px;\n    }\n\n    .animation-shell {\n      width: 100%;\n      display: flex;\n      flex-direction: column;\n      align-items: center;\n      gap: 16px;\n    }\n\n    .animation-stage {\n      --cols: ${data.canvasDimensions.width};\n      --rows: ${data.canvasDimensions.height};\n      background-color: ${data.canvasBackgroundColor};\n      border: 2px solid rgba(255,255,255,0.3);\n      border-radius: 6px;\n      padding: 16px;\n      box-shadow: 0 0 0 1px rgba(0,0,0,0.25) inset;\n    }\n\n    .animation-canvas {\n      position: relative;\n      display: block;\n      white-space: pre;\n      font-family: inherit;\n      font-size: inherit;\n      line-height: inherit;\n      min-width: calc(var(--cols) * 1ch);\n      min-height: calc(var(--rows) * 1em);\n    }\n\n    .frame {\n      position: absolute;\n      inset: 0;\n      display: none;\n      white-space: pre;\n      font-family: inherit;\n      font-size: inherit;\n      line-height: inherit;\n      pointer-events: none;\n    }\n        \n    .frame.active {\n      display: block;\n    }\n\n    .controls {\n      display: flex;\n      justify-content: center;\n      width: 100%;\n    }\n\n    .playback-controls {\n      display: flex;\n      align-items: center;\n      gap: 8px;\n      padding: 8px 12px;\n      border-radius: 10px;\n      border: 1px solid rgba(255,255,255,0.12);\n      background: rgba(14, 14, 16, 0.65);\n      box-shadow: inset 0 0 0 1px rgba(0,0,0,0.35);\n    }\n\n    .playback-button {\n      width: 36px;\n      height: 36px;\n      border-radius: 8px;\n      border: 1px solid rgba(255,255,255,0.18);\n      background: rgba(22,22,26,0.9);\n      color: #f8f9fb;\n      display: inline-flex;\n      align-items: center;\n      justify-content: center;\n      cursor: pointer;\n      transition: background 150ms ease, border-color 150ms ease, transform 120ms ease;\n    }\n\n    .playback-button svg {\n      width: 20px;\n      height: 20px;\n      display: block;\n    }\n\n    .playback-button:hover:not(:disabled),\n    .playback-button:focus-visible {\n      background: rgba(255,255,255,0.12);\n      border-color: rgba(255,255,255,0.28);\n      outline: none;\n    }\n\n    .playback-button:active:not(:disabled) {\n      transform: translateY(1px);\n    }\n\n    .playback-button:disabled {\n      cursor: not-allowed;\n      opacity: 0.4;\n    }\n\n    .playback-button.is-primary,\n    .playback-button.is-active {\n      background: rgba(139, 92, 246, 0.9);\n      border-color: rgba(139, 92, 246, 0.95);\n      color: #fff;\n    }\n\n    .playback-button.is-primary:hover:not(:disabled),\n    .playback-button.is-active:hover:not(:disabled) {\n      background: rgba(167, 139, 250, 0.95);\n      border-color: rgba(167, 139, 250, 1);\n    }\n\n    .playback-divider {\n      width: 1px;\n      height: 24px;\n      background: rgba(255,255,255,0.14);\n      margin: 0 4px;\n    }\n\n    .frame-indicator {\n      display: flex;\n      align-items: center;\n      gap: 6px;\n      font-size: 13px;\n      color: rgba(255,255,255,0.7);\n    }\n\n    .frame-value {\n      padding: 4px 12px;\n      min-width: 3.75rem;\n      border-radius: 8px;\n      background: rgba(255,255,255,0.08);\n      border: 1px solid rgba(255,255,255,0.18);\n      color: #f8f9fb;\n      font-variant-numeric: tabular-nums;\n      font-feature-settings: \"tnum\" 1;\n      text-align: center;\n      display: inline-flex;\n      justify-content: center;\n      align-items: center;\n    }\n\n    .info {\n      display: flex;\n      flex-direction: column;\n      gap: 4px;\n      align-items: center;\n      font-size: 12px;\n      color: rgba(255,255,255,0.72);\n      text-align: center;\n    }\n  </style>\n</head>\n<body>\n  <main class=\"layout\">\n    <div class=\"animation-shell\">\n      <div class=\"animation-stage\" id=\"animationStage\">\n        <div class=\"animation-canvas\" id=\"animationCanvas\"></div>\n      </div>\n\n      <div class=\"controls\">\n        <div class=\"playback-controls\" role=\"group\" aria-label=\"Playback controls\">\n          <button class=\"playback-button\" id=\"control-prev\" aria-label=\"Previous frame\" type=\"button\"></button>\n          <button class=\"playback-button\" id=\"control-play\" aria-label=\"Play animation\" type=\"button\"></button>\n          <button class=\"playback-button\" id=\"control-stop\" aria-label=\"Stop animation\" type=\"button\"></button>\n          <button class=\"playback-button\" id=\"control-next\" aria-label=\"Next frame\" type=\"button\"></button>\n          <div class=\"playback-divider\" aria-hidden=\"true\"></div>\n          <div class=\"frame-indicator\">\n            <span class=\"frame-label\">Frame:</span>\n            <span class=\"frame-value\" id=\"frame-indicator\">1 / 1</span>\n          </div>\n          <button class=\"playback-button\" id=\"control-loop\" aria-label=\"Toggle loop\" aria-pressed=\"false\" type=\"button\"></button>\n        </div>\n      </div>\n\n      <div class=\"info\">\n        ${settings.includeMetadata ? `\n        <div>ASCII Motion Animation</div>\n        <div>Frames: ${data.frames.length} | Duration: ${animationDuration.toFixed(1)}s</div>\n        <div>Resolution: ${data.canvasDimensions.width}×${data.canvasDimensions.height}</div>\n        <div>Exported: ${new Date().toLocaleDateString()}</div>\n        ` : ''}\n      </div>\n    </div>\n  </main>\n\n    <script>\n      const frameData = ${frameDataJson};\n      const playbackSpeed = Math.max(${settings.animationSpeed}, 0.1);\n      let currentFrameIndex = 0;\n      let animationTimeout = null;\n      let isPlaying = false;\n  let isLooping = true;\n      let activeFrameElement = null;\n\n      const animationCanvas = document.getElementById('animationCanvas');\n      const controls = {\n        prev: document.getElementById('control-prev'),\n        play: document.getElementById('control-play'),\n        stop: document.getElementById('control-stop'),\n        next: document.getElementById('control-next'),\n        loop: document.getElementById('control-loop'),\n        frameValue: document.getElementById('frame-indicator')\n      };\n\n      const ICONS = {\n        skipBack: '<svg aria-hidden=\"true\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\"><path d=\"M10 20 4 12l6-8\"></path><path d=\"M20 19V5\"></path></svg>',\n        play: '<svg aria-hidden=\"true\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\"><path d=\"M5 3v18l15-9Z\"></path></svg>',\n        stop: '<svg aria-hidden=\"true\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\"><rect width=\"18\" height=\"18\" x=\"3\" y=\"3\" rx=\"2\"></rect></svg>',\n        skipForward: '<svg aria-hidden=\"true\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\"><path d=\"m14 4 6 8-6 8\"></path><path d=\"M4 5v14\"></path></svg>',\n        loop: '<svg aria-hidden=\"true\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\"><path d=\"M17 2l4 4-4 4\"></path><path d=\"M3 11v-1a4 4 0 0 1 4-4h14\"></path><path d=\"M7 22l-4-4 4-4\"></path><path d=\"M21 13v1a4 4 0 0 1-4 4H3\"></path></svg>'\n      };\n\n      const iconAssignments = [\n        ['prev', ICONS.skipBack],\n        ['play', ICONS.play],\n        ['stop', ICONS.stop],\n        ['next', ICONS.skipForward],\n        ['loop', ICONS.loop]\n      ];\n\n      iconAssignments.forEach(([key, icon]) => {\n        const button = controls[key];\n        if (button) {\n          button.innerHTML = icon;\n        }\n      });\n\n      function initializeFrames() {\n        if (!animationCanvas) return;\n\n        animationCanvas.innerHTML = '';\n\n        frameData.forEach((frame, index) => {\n          const frameDiv = document.createElement('div');\n          frameDiv.className = 'frame';\n          frameDiv.id = 'frame-' + index;\n\n          let frameContent = '';\n          for (let y = 0; y < frame.characters.length; y++) {\n            for (let x = 0; x < frame.characters[y].length; x++) {\n              const char = frame.characters[y][x];\n              const color = frame.colors[y][x];\n              const bgColor = frame.backgrounds[y][x];\n\n              if (char !== ' ' || bgColor !== 'transparent') {\n                const span = '<span style=\"color: ' + color +\n                  (bgColor !== 'transparent' ? '; background-color: ' + bgColor : '') +\n                  '\">' + (char === ' ' ? '&nbsp;' : char.replace(/</g, '&lt;').replace(/>/g, '&gt;')) + '</span>';\n                frameContent += span;\n              } else {\n                frameContent += '&nbsp;';\n              }\n            }\n            if (y < frame.characters.length - 1) {\n              frameContent += '\\\\n';\n            }\n          }\n\n          frameDiv.innerHTML = frameContent;\n          animationCanvas.appendChild(frameDiv);\n        });\n      }\n\n      function updateFrameIndicator() {\n        if (!controls.frameValue) return;\n\n        const totalFrames = frameData.length;\n        if (totalFrames === 0) {\n          controls.frameValue.textContent = '0 / 0';\n          return;\n        }\n\n        const totalDigits = Math.max(1, String(totalFrames).length);\n        const currentValue = String(currentFrameIndex + 1).padStart(totalDigits, '0');\n        const totalValue = String(totalFrames).padStart(totalDigits, '0');\n\n        controls.frameValue.textContent = currentValue + ' / ' + totalValue;\n      }\n\n      function updatePlayButton() {\n        if (!controls.play) return;\n        controls.play.innerHTML = ICONS.play;\n        controls.play.classList.remove('is-primary');\n        controls.play.setAttribute('aria-label', 'Play animation');\n      }\n\n      function updateLoopButton() {\n        if (!controls.loop) return;\n        controls.loop.classList.toggle('is-active', isLooping);\n        controls.loop.setAttribute('aria-pressed', String(isLooping));\n        controls.loop.setAttribute('aria-label', isLooping ? 'Disable loop' : 'Enable loop');\n      }\n\n      function updateControlStates() {\n        const totalFrames = frameData.length;\n        const hasFrames = totalFrames > 0;\n\n        if (controls.prev) {\n          controls.prev.disabled = !hasFrames || isPlaying || currentFrameIndex === 0;\n        }\n        if (controls.next) {\n          controls.next.disabled = !hasFrames || isPlaying || currentFrameIndex >= totalFrames - 1;\n        }\n        if (controls.stop) {\n          controls.stop.disabled = !hasFrames || !isPlaying;\n        }\n        if (controls.play) {\n          controls.play.disabled = !hasFrames || isPlaying;\n        }\n\n        updatePlayButton();\n        updateLoopButton();\n      }\n\n      function clearAnimationTimer() {\n        if (animationTimeout !== null) {\n          clearTimeout(animationTimeout);\n          animationTimeout = null;\n        }\n      }\n\n      function showFrame(index) {\n        if (index < 0 || index >= frameData.length) return;\n        const nextFrame = document.getElementById('frame-' + index);\n        if (!nextFrame) return;\n\n        nextFrame.classList.add('active');\n\n        if (activeFrameElement && activeFrameElement !== nextFrame) {\n          activeFrameElement.classList.remove('active');\n        }\n\n        activeFrameElement = nextFrame;\n        currentFrameIndex = index;\n        updateFrameIndicator();\n        updateControlStates();\n      }\n\n      function scheduleNextFrame() {\n        if (!isPlaying || frameData.length === 0) return;\n\n        const currentFrame = frameData[currentFrameIndex];\n        const duration = Math.max((currentFrame?.duration || 100) / playbackSpeed, 16);\n\n        animationTimeout = window.setTimeout(() => {\n          animationTimeout = null;\n\n          if (!isPlaying) {\n            return;\n          }\n\n          let nextIndex = currentFrameIndex + 1;\n\n          if (nextIndex >= frameData.length) {\n            if (isLooping) {\n              nextIndex = 0;\n            } else {\n              stopAnimation({ reset: false });\n              return;\n            }\n          }\n\n          showFrame(nextIndex);\n          scheduleNextFrame();\n        }, duration);\n      }\n\n      function startAnimation() {\n        if (frameData.length === 0 || isPlaying) return;\n        isPlaying = true;\n        updateControlStates();\n        scheduleNextFrame();\n      }\n\n      function stopAnimation({ reset = true } = {}) {\n        const wasPlaying = isPlaying;\n\n        if (!wasPlaying && !reset) {\n          updateControlStates();\n          return;\n        }\n\n        isPlaying = false;\n        clearAnimationTimer();\n\n        if (reset && frameData.length > 0) {\n          showFrame(0);\n          return;\n        }\n\n        updateControlStates();\n      }\n\n      function goToPreviousFrame() {\n        if (isPlaying || currentFrameIndex === 0) return;\n        showFrame(currentFrameIndex - 1);\n      }\n\n      function goToNextFrame() {\n        if (isPlaying || currentFrameIndex >= frameData.length - 1) return;\n        showFrame(currentFrameIndex + 1);\n      }\n\n      if (controls.prev) {\n        controls.prev.addEventListener('click', goToPreviousFrame);\n      }\n      if (controls.play) {\n        controls.play.addEventListener('click', () => {\n          if (!isPlaying) {\n            startAnimation();\n          }\n        });\n      }\n      if (controls.stop) {\n        controls.stop.addEventListener('click', () => stopAnimation({ reset: true }));\n      }\n      if (controls.next) {\n        controls.next.addEventListener('click', goToNextFrame);\n      }\n      if (controls.loop) {\n        controls.loop.addEventListener('click', () => {\n          isLooping = !isLooping;\n          updateLoopButton();\n        });\n      }\n\n      window.addEventListener('visibilitychange', () => {\n        if (document.hidden) {\n          stopAnimation({ reset: false });\n        }\n      });\n\n      window.onload = function() {\n        initializeFrames();\n\n        if (frameData.length > 0) {\n          showFrame(0);\n          startAnimation();\n        } else {\n          updateFrameIndicator();\n          updateControlStates();\n        }\n\n      };\n    </script>\n</body>\n</html>`;\n\n      this.updateProgress('Creating file...', 90);\n\n      // Create blob and download\n      const blob = new Blob([htmlContent], { type: 'text/html' });\n      saveAs(blob, `${filename}.html`);\n      \n      this.updateProgress('Export complete!', 100);\n    } catch (error) {\n      console.error('HTML export failed:', error);\n      throw new Error(`HTML export failed: ${error instanceof Error ? error.message : 'Unknown error'}`);\n    }\n  }\n\n  /**\n   * Export animation as a reusable React component file (TSX/JSX)\n   */\n  async exportReactComponent(\n    data: ExportDataBundle,\n    settings: ReactExportSettings\n  ): Promise<void> {\n    this.updateProgress('Preparing React component export...', 0);\n\n    try {\n      const requestedName = settings.fileName?.trim() || 'ascii-motion-animation';\n      const sanitizedFileName = this.sanitizeReactFileName(requestedName) || 'ascii-motion-animation';\n      const componentName = this.toPascalCase(sanitizedFileName);\n\n      const fontSize = data.typography?.fontSize ?? data.fontMetrics?.fontSize ?? 16;\n      const characterSpacing = data.typography?.characterSpacing ?? 1.0;\n      const lineSpacing = data.typography?.lineSpacing ?? 1.0;\n\n      const baseCharWidth = fontSize * 0.6;\n      const baseCharHeight = fontSize;\n\n      const cellWidth = baseCharWidth * characterSpacing;\n      const cellHeight = baseCharHeight * lineSpacing;\n\n      const canvasPixelWidth = Number((cellWidth * data.canvasDimensions.width).toFixed(2));\n      const canvasPixelHeight = Number((cellHeight * data.canvasDimensions.height).toFixed(2));\n\n      this.updateProgress('Serializing animation data...', 20);\n\n      const framesPayload = data.frames.map((frame) => {\n        const cells: Array<{ x: number; y: number; char: string; color: string; bgColor?: string }> = [];\n\n        frame.data.forEach((cell, key) => {\n          if (!cell || !cell.char) {\n            return;\n          }\n\n          const [x, y] = key.split(',').map(Number);\n          const cellEntry: { x: number; y: number; char: string; color: string; bgColor?: string } = {\n            x,\n            y,\n            char: cell.char,\n            color: cell.color || '#ffffff'\n          };\n\n          if (cell.bgColor && cell.bgColor !== 'transparent') {\n            cellEntry.bgColor = cell.bgColor;\n          }\n\n          cells.push(cellEntry);\n        });\n\n        cells.sort((a, b) => (a.y - b.y) || (a.x - b.x));\n\n        return {\n          duration: Math.max(frame.duration, 16),\n          cells\n        };\n      });\n\n      const framesJson = JSON.stringify(framesPayload, null, 2);\n      const fontFamily =\n        data.fontMetrics?.fontFamily || 'SF Mono, Monaco, Inconsolata, \"Roboto Mono\", Consolas, \"Courier New\"';\n\n      this.updateProgress('Generating component code...', 60);\n\n      const componentCode = this.generateReactComponentCode({\n        componentName,\n        framesJson,\n        isTypescript: settings.typescript,\n        includeControls: settings.includeControls,\n        canvasWidth: canvasPixelWidth,\n        canvasHeight: canvasPixelHeight,\n        cellWidth,\n        cellHeight,\n        fontSize,\n        fontFamily,\n        backgroundColor: settings.includeBackground ? data.canvasBackgroundColor : null\n      });\n\n      this.updateProgress('Saving file...', 90);\n\n      const extension = settings.typescript ? 'tsx' : 'jsx';\n      const blob = new Blob([componentCode], { type: 'text/plain;charset=utf-8' });\n      saveAs(blob, `${sanitizedFileName}.${extension}`);\n\n      this.updateProgress('Export complete!', 100);\n    } catch (error) {\n      console.error('React component export failed:', error);\n      throw new Error(`React component export failed: ${error instanceof Error ? error.message : 'Unknown error'}`);\n    }\n  }\n\n  private sanitizeReactFileName(value: string): string {\n    if (!value) {\n      return '';\n    }\n\n    return value\n      .trim()\n      .replace(/\\s+/g, '-')\n      .replace(/[^a-zA-Z0-9\\-_]/g, '')\n      .replace(/-+/g, '-')\n      .replace(/_+/g, '_')\n      .replace(/^[-_]+|[-_]+$/g, '')\n      .toLowerCase();\n  }\n\n  private toPascalCase(value: string): string {\n    if (!value) {\n      return 'AsciiMotionAnimation';\n    }\n\n    const segments = value\n      .split(/[-_\\s]+/)\n      .filter(Boolean)\n      .map((segment) => segment.charAt(0).toUpperCase() + segment.slice(1));\n\n    const name = segments.length > 0 ? segments.join('') : 'AsciiMotionAnimation';\n    return /^[A-Za-z]/.test(name) ? name : `Ascii${name}`;\n  }\n\n  private generateReactComponentCode(options: {\n    componentName: string;\n    framesJson: string;\n    isTypescript: boolean;\n    includeControls: boolean;\n    canvasWidth: number;\n    canvasHeight: number;\n    cellWidth: number;\n    cellHeight: number;\n    fontSize: number;\n    fontFamily: string;\n    backgroundColor: string | null;\n  }): string {\n    const {\n      componentName,\n      framesJson,\n      isTypescript,\n      includeControls,\n      canvasWidth,\n      canvasHeight,\n      cellWidth,\n      cellHeight,\n      fontSize,\n      fontFamily,\n      backgroundColor\n    } = options;\n\n    const cellWidthLiteral = Number(cellWidth.toFixed(4));\n    const cellHeightLiteral = Number(cellHeight.toFixed(4));\n    const fontFamilyLiteral = JSON.stringify(fontFamily);\n    const backgroundLiteral = backgroundColor ? JSON.stringify(backgroundColor) : 'null';\n\n    const hooksImport = `import { useEffect, useRef, useCallback${includeControls ? ', useState' : ''} } from 'react';`;\n\n    const typeBlock = isTypescript\n      ? `type CellData = {\\n  x: number;\\n  y: number;\\n  char: string;\\n  color: string;\\n  bgColor?: string;\\n};\\n\\n` +\n        `type Frame = {\\n  duration: number;\\n  cells: CellData[];\\n};\\n\\n` +\n        `type AsciiMotionComponentProps = {\\n  showControls?: boolean;\\n  autoPlay?: boolean;\\n  onReady?: (api: {\\n    play: () => void;\\n    pause: () => void;\\n    togglePlay: () => void;\\n    restart: () => void;\\n  }) => void;\\n};`\n      : `/**\\n * @typedef {{ x: number, y: number, char: string, color: string, bgColor?: string }} CellData\\n * @typedef {{ duration: number, cells: CellData[] }} Frame\\n */\\n\\n/**\\n * @typedef {Object} AsciiMotionComponentProps\\n * @property {boolean} [showControls]\\n * @property {boolean} [autoPlay]\\n * @property {(api: { play: () => void; pause: () => void; togglePlay: () => void; restart: () => void; }) => void} [onReady]\\n */`;\n\n    const framesDeclaration = isTypescript\n      ? `const FRAMES: Frame[] = ${framesJson};`\n      : `const FRAMES = ${framesJson};`;\n\n    const canvasRefDeclaration = isTypescript\n      ? 'const canvasRef = useRef<HTMLCanvasElement | null>(null);'\n      : 'const canvasRef = useRef(null);';\n\n    const animationFrameRefDeclaration = isTypescript\n      ? 'const animationFrameRef = useRef<number | null>(null);'\n      : 'const animationFrameRef = useRef(null);';\n\n    const frameIndexRefDeclaration = isTypescript\n      ? 'const frameIndexRef = useRef<number>(0);'\n      : 'const frameIndexRef = useRef(0);';\n\n    const frameElapsedRefDeclaration = isTypescript\n      ? 'const frameElapsedRef = useRef<number>(0);'\n      : 'const frameElapsedRef = useRef(0);';\n\n    const lastTimestampRefDeclaration = isTypescript\n      ? 'const lastTimestampRef = useRef<number>(0);'\n      : 'const lastTimestampRef = useRef(0);';\n\n    const restartRefDeclaration = isTypescript\n      ? 'const restartRef = useRef<() => void>(() => {});'\n      : 'const restartRef = useRef(() => {});';\n\n    const isPlayingRefDeclaration = isTypescript\n      ? 'const isPlayingRef = useRef<boolean>(initialAutoPlay);'\n      : 'const isPlayingRef = useRef(initialAutoPlay);';\n\n    const drawFrameSignature = isTypescript ? '(index: number)' : '(index)';\n    const stepSignature = isTypescript ? '(timestamp: number)' : '(timestamp)';\n\n    const stateLines: string[] = [];\n    if (includeControls) {\n      if (isTypescript) {\n        stateLines.push('const [isPlaying, setIsPlaying] = useState<boolean>(initialAutoPlay);');\n        stateLines.push('const [activeFrame, setActiveFrame] = useState<number>(0);');\n      } else {\n        stateLines.push('const [isPlaying, setIsPlaying] = useState(initialAutoPlay);');\n        stateLines.push('const [activeFrame, setActiveFrame] = useState(0);');\n      }\n    }\n\n    const pushIndentedBlock = (target: string[], lines: string[], indent: number) => {\n      lines.forEach((line) => {\n        if (line === '') {\n          target.push('');\n        } else {\n          target.push(`${' '.repeat(indent)}${line}`);\n        }\n      });\n    };\n\n    const componentLines: string[] = [];\n    componentLines.push(`const ${componentName} = (props${isTypescript ? ': AsciiMotionComponentProps = {}' : ' = {}'}) => {`);\n    componentLines.push('  const { showControls = true, autoPlay = true, onReady } = props;');\n    if (includeControls) {\n      componentLines.push('  const controlsVisible = showControls !== false;');\n    }\n    componentLines.push('  const initialAutoPlay = autoPlay !== false;');\n    componentLines.push(`  ${canvasRefDeclaration}`);\n    componentLines.push(`  ${animationFrameRefDeclaration}`);\n    componentLines.push(`  ${frameIndexRefDeclaration}`);\n    componentLines.push(`  ${frameElapsedRefDeclaration}`);\n    componentLines.push(`  ${lastTimestampRefDeclaration}`);\n    componentLines.push(`  ${restartRefDeclaration}`);\n    componentLines.push(`  ${isPlayingRefDeclaration}`);\n\n    stateLines.forEach((line) => {\n      componentLines.push(`  ${line}`);\n    });\n\n    const updatePlayingStateLines = includeControls\n      ? [\n          `const updatePlayingState = useCallback(${isTypescript ? '(value: boolean)' : '(value)'} => {`,\n          '  isPlayingRef.current = value;',\n          '  setIsPlaying(value);',\n          '}, []);'\n        ]\n      : [\n          `const updatePlayingState = useCallback(${isTypescript ? '(value: boolean)' : '(value)'} => {`,\n          '  isPlayingRef.current = value;',\n          '}, []);'\n        ];\n\n    updatePlayingStateLines.forEach((line) => {\n      componentLines.push(`  ${line}`);\n    });\n\n    const actionBlocks = [\n      ['const play = useCallback(() => {', '  updatePlayingState(true);', '}, [updatePlayingState]);'],\n      ['const pause = useCallback(() => {', '  updatePlayingState(false);', '}, [updatePlayingState]);'],\n      ['const togglePlay = useCallback(() => {', '  updatePlayingState(!isPlayingRef.current);', '}, [updatePlayingState]);'],\n      ['const restart = useCallback(() => {', '  if (restartRef.current) {', '    restartRef.current();', '  }', '}, []);']\n    ];\n\n    actionBlocks.forEach((block) => {\n      block.forEach((line) => componentLines.push(`  ${line}`));\n    });\n\n    componentLines.push('');\n    componentLines.push('  useEffect(() => {');\n    componentLines.push('    if (isPlayingRef.current !== initialAutoPlay) {');\n    componentLines.push('      updatePlayingState(initialAutoPlay);');\n    componentLines.push('    }');\n    componentLines.push('  }, [initialAutoPlay, updatePlayingState]);');\n    componentLines.push('');\n    componentLines.push('  useEffect(() => {');\n\n    const effectLines: string[] = [\n      'const canvas = canvasRef.current;',\n      'if (!canvas) {',\n      '  return;',\n      '}',\n      '',\n      \"const context = canvas.getContext('2d');\",\n      'if (!context) {',\n      '  return;',\n      '}',\n      '',\n      'const devicePixelRatio = window.devicePixelRatio || 1;',\n      'canvas.width = CANVAS_WIDTH * devicePixelRatio;',\n      'canvas.height = CANVAS_HEIGHT * devicePixelRatio;',\n      \"canvas.style.width = CANVAS_WIDTH + 'px';\",\n      \"canvas.style.height = CANVAS_HEIGHT + 'px';\",\n      'context.resetTransform();',\n      'context.scale(devicePixelRatio, devicePixelRatio);',\n      \"context.textAlign = 'center';\",\n      \"context.textBaseline = 'middle';\",\n      \"context.font = FONT_SIZE + 'px ' + FONT_FAMILY;\",\n      'context.imageSmoothingEnabled = false;',\n      '',\n      'frameIndexRef.current = 0;',\n      'frameElapsedRef.current = 0;',\n      'lastTimestampRef.current = 0;',\n      '',\n      `const drawFrame = ${drawFrameSignature} => {`,\n      '  const frame = FRAMES[index];',\n      '',\n      '  if (BACKGROUND_COLOR) {',\n      '    context.fillStyle = BACKGROUND_COLOR;',\n      '    context.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);',\n      '  } else {',\n      '    context.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);',\n      '  }',\n      '',\n      '  if (!frame) {',\n      '    return;',\n      '  }',\n      '',\n      '  for (const cell of frame.cells) {',\n      '    if (cell.bgColor) {',\n      '      context.fillStyle = cell.bgColor;',\n      '      context.fillRect(cell.x * CELL_WIDTH, cell.y * CELL_HEIGHT, CELL_WIDTH, CELL_HEIGHT);',\n      '    }',\n      '',\n      \"    context.fillStyle = cell.color || '#ffffff';\",\n      '    context.fillText(',\n      '      cell.char,',\n      '      cell.x * CELL_WIDTH + CELL_WIDTH / 2,',\n      '      cell.y * CELL_HEIGHT + CELL_HEIGHT / 2',\n      '    );',\n      '  }'\n    ];\n\n    if (includeControls) {\n      effectLines.push('');\n      effectLines.push('  setActiveFrame(index);');\n    }\n\n    effectLines.push('};');\n    effectLines.push('');\n    effectLines.push('drawFrame(frameIndexRef.current);');\n    effectLines.push('');\n    effectLines.push('if (FRAMES.length === 0) {');\n    effectLines.push('  restartRef.current = () => {');\n    effectLines.push('    drawFrame(0);');\n    if (includeControls) {\n      effectLines.push('    setActiveFrame(0);');\n    }\n    effectLines.push('  };');\n    effectLines.push('  return;');\n    effectLines.push('}');\n    effectLines.push('');\n    effectLines.push(`const step = ${stepSignature} => {`);\n    effectLines.push('  if (FRAMES.length === 0) {');\n    effectLines.push('    return;');\n    effectLines.push('  }');\n    effectLines.push('');\n    effectLines.push('  if (lastTimestampRef.current === 0) {');\n    effectLines.push('    lastTimestampRef.current = timestamp;');\n    effectLines.push('  }');\n    effectLines.push('');\n    effectLines.push('  const delta = timestamp - lastTimestampRef.current;');\n    effectLines.push('  lastTimestampRef.current = timestamp;');\n    effectLines.push('');\n    effectLines.push('  if (isPlayingRef.current) {');\n    effectLines.push('    frameElapsedRef.current += delta;');\n    effectLines.push('');\n    effectLines.push('    let nextIndex = frameIndexRef.current;');\n    effectLines.push('    let remaining = frameElapsedRef.current;');\n    effectLines.push('    let duration = FRAMES[nextIndex]?.duration ?? 16;');\n    effectLines.push('');\n    effectLines.push('    while (remaining >= duration && FRAMES.length > 0) {');\n    effectLines.push('      remaining -= duration;');\n    effectLines.push('      nextIndex = (nextIndex + 1) % FRAMES.length;');\n    effectLines.push('      duration = FRAMES[nextIndex]?.duration ?? duration;');\n    effectLines.push('    }');\n    effectLines.push('');\n    effectLines.push('    frameElapsedRef.current = remaining;');\n    effectLines.push('');\n    effectLines.push('    if (nextIndex !== frameIndexRef.current) {');\n    effectLines.push('      frameIndexRef.current = nextIndex;');\n    effectLines.push('      drawFrame(nextIndex);');\n    effectLines.push('    } else {');\n    effectLines.push('      drawFrame(frameIndexRef.current);');\n    effectLines.push('    }');\n    effectLines.push('  } else {');\n    effectLines.push('    drawFrame(frameIndexRef.current);');\n    effectLines.push('  }');\n    effectLines.push('');\n    effectLines.push('  animationFrameRef.current = window.requestAnimationFrame(step);');\n    effectLines.push('};');\n    effectLines.push('');\n    effectLines.push('animationFrameRef.current = window.requestAnimationFrame(step);');\n    effectLines.push('');\n    effectLines.push('restartRef.current = () => {');\n    effectLines.push('  frameIndexRef.current = 0;');\n    effectLines.push('  frameElapsedRef.current = 0;');\n    effectLines.push('  lastTimestampRef.current = 0;');\n    effectLines.push('  drawFrame(0);');\n    if (includeControls) {\n      effectLines.push('  setActiveFrame(0);');\n    }\n    effectLines.push('};');\n    effectLines.push('');\n    effectLines.push('return () => {');\n    effectLines.push('  if (animationFrameRef.current !== null) {');\n    effectLines.push('    window.cancelAnimationFrame(animationFrameRef.current);');\n    effectLines.push('    animationFrameRef.current = null;');\n    effectLines.push('  }');\n    effectLines.push('};');\n\n    pushIndentedBlock(componentLines, effectLines, 4);\n    componentLines.push('  }, []);');\n\n    componentLines.push('');\n    componentLines.push('  useEffect(() => {');\n    componentLines.push('    if (typeof onReady === \"function\") {');\n    componentLines.push('      onReady({');\n    componentLines.push('        play,');\n    componentLines.push('        pause,');\n    componentLines.push('        togglePlay,');\n    componentLines.push('        restart,');\n    componentLines.push('      });');\n    componentLines.push('    }');\n    componentLines.push('  }, [onReady, play, pause, togglePlay, restart]);');\n\n    if (includeControls) {\n      componentLines.push('');\n      componentLines.push('  const hasFrames = FRAMES.length > 0;');\n      componentLines.push('');\n      componentLines.push('  const handleTogglePlay = () => {');\n      componentLines.push('    if (!hasFrames) {');\n      componentLines.push('      return;');\n      componentLines.push('    }');\n      componentLines.push('    togglePlay();');\n      componentLines.push('  };');\n      componentLines.push('');\n      componentLines.push('  const handleRestart = () => {');\n      componentLines.push('    if (!hasFrames) {');\n      componentLines.push('      return;');\n      componentLines.push('    }');\n      componentLines.push('    restart();');\n      componentLines.push('    updatePlayingState(true);');\n      componentLines.push('  };');\n      componentLines.push('');\n      componentLines.push(\"  const playLabel = isPlaying ? 'Pause' : 'Play';\");\n    }\n\n    componentLines.push('  return (');\n    componentLines.push('    <div');\n    componentLines.push('      style={{');\n    componentLines.push(\"        display: 'inline-flex',\");\n    componentLines.push(\"        flexDirection: 'column',\");\n    componentLines.push(\"        alignItems: 'center'\");\n    componentLines.push('      }}');\n    componentLines.push('    >');\n    componentLines.push('      <canvas');\n    componentLines.push('        ref={canvasRef}');\n    componentLines.push('        width={CANVAS_WIDTH}');\n    componentLines.push('        height={CANVAS_HEIGHT}');\n    componentLines.push('        style={{');\n    componentLines.push(\"          width: CANVAS_WIDTH + 'px',\");\n    componentLines.push(\"          height: CANVAS_HEIGHT + 'px',\");\n    componentLines.push(\"          backgroundColor: BACKGROUND_COLOR || 'transparent',\");\n    componentLines.push(\"          imageRendering: 'pixelated'\");\n    componentLines.push('        }}');\n    componentLines.push('      />');\n\n    if (includeControls) {\n      componentLines.push('      {controlsVisible && (');\n      componentLines.push('        <div');\n      componentLines.push('          style={{');\n      componentLines.push(\"            marginTop: '12px',\");\n      componentLines.push(\"            display: 'flex',\");\n      componentLines.push(\"            alignItems: 'center',\");\n      componentLines.push(\"            gap: '12px'\");\n      componentLines.push('          }}');\n      componentLines.push('        >');\n      componentLines.push('          <button');\n      componentLines.push('            type=\"button\"');\n      componentLines.push('            onClick={handleTogglePlay}');\n      componentLines.push('            disabled={!hasFrames}');\n      componentLines.push('            style={{');\n      componentLines.push(\"              padding: '6px 12px',\");\n      componentLines.push(\"              borderRadius: '8px',\");\n      componentLines.push(\"              border: '1px solid rgba(0, 0, 0, 0.2)',\");\n      componentLines.push(\"              background: isPlaying ? '#f1f5f9' : '#111827',\");\n      componentLines.push(\"              color: isPlaying ? '#111827' : '#f9fafb',\");\n      componentLines.push(\"              cursor: hasFrames ? 'pointer' : 'not-allowed'\");\n      componentLines.push('            }}');\n      componentLines.push('          >');\n      componentLines.push('            {playLabel}');\n      componentLines.push('          </button>');\n      componentLines.push('          <button');\n      componentLines.push('            type=\"button\"');\n      componentLines.push('            onClick={handleRestart}');\n      componentLines.push('            disabled={!hasFrames}');\n      componentLines.push('            style={{');\n      componentLines.push(\"              padding: '6px 12px',\");\n      componentLines.push(\"              borderRadius: '8px',\");\n      componentLines.push(\"              border: '1px solid rgba(0, 0, 0, 0.2)',\");\n      componentLines.push(\"              background: '#0f172a',\");\n      componentLines.push(\"              color: '#f9fafb',\");\n      componentLines.push(\"              cursor: hasFrames ? 'pointer' : 'not-allowed'\");\n      componentLines.push('            }}');\n      componentLines.push('          >');\n      componentLines.push('            Restart');\n      componentLines.push('          </button>');\n      componentLines.push('          <span');\n      componentLines.push(\"            style={{ fontFamily: 'monospace', fontSize: '12px', color: '#475569' }}\");\n      componentLines.push('          >');\n      componentLines.push(\"            {hasFrames ? 'Frame ' + (activeFrame + 1) + ' / ' + FRAMES.length : 'No frames'}\");\n      componentLines.push('          </span>');\n      componentLines.push('        </div>');\n      componentLines.push('      )}');\n    }\n\n    componentLines.push('    </div>');\n    componentLines.push('  );');\n    componentLines.push('};');\n\n    const componentBlock = componentLines.join('\\n');\n\n    const lines: string[] = [];\n    lines.push(\"'use client';\");\n    lines.push('');\n    lines.push(hooksImport);\n    lines.push('');\n    lines.push(typeBlock);\n    lines.push('');\n    lines.push(framesDeclaration);\n    lines.push('');\n    lines.push(`const CANVAS_WIDTH = ${canvasWidth};`);\n    lines.push(`const CANVAS_HEIGHT = ${canvasHeight};`);\n    lines.push(`const CELL_WIDTH = ${cellWidthLiteral};`);\n    lines.push(`const CELL_HEIGHT = ${cellHeightLiteral};`);\n    lines.push(`const FONT_SIZE = ${fontSize};`);\n    lines.push(`const FONT_FAMILY = ${fontFamilyLiteral};`);\n    lines.push(`const BACKGROUND_COLOR = ${backgroundLiteral};`);\n    lines.push('');\n    lines.push(componentBlock);\n    lines.push('');\n    lines.push(`export default ${componentName};`);\n\n    return lines.join('\\n') + '\\n';\n  }\n\n  /**\n   * Crop grid based on text export settings\n   */\n  private cropGrid(grid: string[][], settings: TextExportSettings): string[][] {\n    let processedGrid = [...grid.map(row => [...row])];\n\n    // Remove leading lines\n    if (settings.removeLeadingLines) {\n      while (processedGrid.length > 0 && processedGrid[0].every(char => char === ' ')) {\n        processedGrid.shift();\n      }\n    }\n\n    // Remove trailing lines\n    if (settings.removeTrailingLines) {\n      while (processedGrid.length > 0 && processedGrid[processedGrid.length - 1].every(char => char === ' ')) {\n        processedGrid.pop();\n      }\n    }\n\n    // Remove leading spaces (find leftmost non-space character across all rows)\n    if (settings.removeLeadingSpaces) {\n      let leftmostColumn = Infinity;\n      \n      // Find the leftmost column with any non-space character\n      for (const row of processedGrid) {\n        for (let col = 0; col < row.length; col++) {\n          if (row[col] !== ' ') {\n            leftmostColumn = Math.min(leftmostColumn, col);\n            break;\n          }\n        }\n      }\n\n      // Remove leading columns if we found any content\n      if (leftmostColumn !== Infinity && leftmostColumn > 0) {\n        processedGrid = processedGrid.map(row => row.slice(leftmostColumn));\n      }\n    }\n\n    return processedGrid;\n  }\n\n  /**\n   * Create a high-resolution canvas for export with DPI scaling\n   */\n  private createExportCanvas(\n    gridWidth: number,\n    gridHeight: number,\n    sizeMultiplier: number,\n    fontMetrics: any,\n    typography: any\n  ): { canvas: HTMLCanvasElement; ctx: CanvasRenderingContext2D; scale: number } {\n    const canvas = document.createElement('canvas');\n    const ctx = canvas.getContext('2d');\n    \n    if (!ctx) {\n      throw new Error('Failed to create canvas context');\n    }\n\n    // Calculate cell dimensions using actual typography settings\n    // Use typography.fontSize instead of fontMetrics.fontSize for accurate sizing\n    const actualFontSize = typography?.fontSize || fontMetrics?.fontSize || 16;\n    const characterSpacing = typography?.characterSpacing || 1.0;\n    const lineSpacing = typography?.lineSpacing || 1.0;\n    \n    // Calculate base character dimensions from actual font size\n    const baseCharWidth = actualFontSize * 0.6; // Standard monospace aspect ratio\n    const baseCharHeight = actualFontSize;\n    \n    // Apply spacing multipliers and size multiplier\n    const baseCellWidth = baseCharWidth * characterSpacing * sizeMultiplier;\n    const baseCellHeight = baseCharHeight * lineSpacing * sizeMultiplier;\n    \n    // Calculate display dimensions\n    const displayWidth = Math.max(gridWidth * baseCellWidth, 1);\n    const displayHeight = Math.max(gridHeight * baseCellHeight, 1);\n    \n    // Use device pixel ratio for high-DPI export (minimum 2x for crisp exports)\n    const devicePixelRatio = Math.max(window.devicePixelRatio || 1, 2);\n    \n    // Set canvas internal resolution to match device pixel ratio\n    canvas.width = displayWidth * devicePixelRatio;\n    canvas.height = displayHeight * devicePixelRatio;\n    \n    // Scale the drawing context to match the device pixel ratio\n    ctx.scale(devicePixelRatio, devicePixelRatio);\n    \n    // Setup high-quality rendering\n    setupTextRendering(ctx);\n    \n    return { canvas, ctx, scale: devicePixelRatio };\n  }\n\n  /**\n   * Render a single frame to canvas\n   */\n  private async renderFrame(\n    canvas: HTMLCanvasElement,\n    frameData: Map<string, Cell>,\n    gridWidth: number,\n    gridHeight: number,\n    options: {\n      backgroundColor: string;\n      showGrid: boolean;\n      fontMetrics: any;\n      typography: any;\n      sizeMultiplier: number;\n      theme: string;\n      scale?: number;\n    }\n  ): Promise<void> {\n    const ctx = canvas.getContext('2d');\n    if (!ctx) throw new Error('No canvas context');\n\n    const { backgroundColor, showGrid, fontMetrics, typography, sizeMultiplier, theme } = options;\n    \n    // Calculate cell dimensions using actual typography settings\n    const actualFontSize = typography?.fontSize || fontMetrics?.fontSize || 16;\n    const characterSpacing = typography?.characterSpacing || 1.0;\n    const lineSpacing = typography?.lineSpacing || 1.0;\n    \n    // Calculate character dimensions with spacing\n    const baseCharWidth = actualFontSize * 0.6; // Standard monospace aspect ratio\n    const baseCharHeight = actualFontSize;\n    \n    const cellWidth = baseCharWidth * characterSpacing * sizeMultiplier;\n    const cellHeight = baseCharHeight * lineSpacing * sizeMultiplier;\n    \n    // Clear canvas with background color\n    ctx.fillStyle = backgroundColor;\n    ctx.fillRect(0, 0, canvas.width, canvas.height);\n    \n    // Draw grid if enabled\n    if (showGrid) {\n      this.drawGrid(ctx, gridWidth, gridHeight, cellWidth, cellHeight, backgroundColor, theme);\n    }\n    \n    // Setup font for text rendering using actual typography settings\n    const exportFontSize = actualFontSize * sizeMultiplier;\n    const fontFamily = fontMetrics?.fontFamily || 'SF Mono, Monaco, Inconsolata, \"Roboto Mono\", Consolas, \"Courier New\"';\n    ctx.font = `${exportFontSize}px '${fontFamily}', monospace`;\n    ctx.textAlign = 'center';\n    ctx.textBaseline = 'middle';\n    \n    // Draw all cells\n    frameData.forEach((cell, key) => {\n      const [x, y] = key.split(',').map(Number);\n      this.drawExportCell(ctx, x, y, cell, cellWidth, cellHeight);\n    });\n  }\n\n  /**\n   * Draw grid lines for export\n   */\n  private drawGrid(\n    ctx: CanvasRenderingContext2D,\n    gridWidth: number,\n    gridHeight: number,\n    cellWidth: number,\n    cellHeight: number,\n    backgroundColor: string,\n    theme: string\n  ): void {\n    const gridColor = calculateAdaptiveGridColor(backgroundColor, theme as 'light' | 'dark');\n    ctx.strokeStyle = gridColor;\n    ctx.lineWidth = 1;\n    \n    ctx.beginPath();\n    \n    // Vertical lines\n    for (let x = 0; x <= gridWidth; x++) {\n      const xPos = x * cellWidth;\n      ctx.moveTo(xPos, 0);\n      ctx.lineTo(xPos, gridHeight * cellHeight);\n    }\n    \n    // Horizontal lines\n    for (let y = 0; y <= gridHeight; y++) {\n      const yPos = y * cellHeight;\n      ctx.moveTo(0, yPos);\n      ctx.lineTo(gridWidth * cellWidth, yPos);\n    }\n    \n    ctx.stroke();\n  }\n\n  /**\n   * Draw a single cell for export\n   */\n  private drawExportCell(\n    ctx: CanvasRenderingContext2D,\n    x: number,\n    y: number,\n    cell: Cell,\n    cellWidth: number,\n    cellHeight: number\n  ): void {\n    const pixelX = x * cellWidth;\n    const pixelY = y * cellHeight;\n    \n    // Draw background if specified\n    if (cell.bgColor && cell.bgColor !== 'transparent') {\n      ctx.fillStyle = cell.bgColor;\n      ctx.fillRect(pixelX, pixelY, cellWidth, cellHeight);\n    }\n    \n    // Draw character\n    if (cell.char && cell.char.trim()) {\n      ctx.fillStyle = cell.color || '#FFFFFF';\n      ctx.fillText(\n        cell.char,\n        pixelX + cellWidth / 2,\n        pixelY + cellHeight / 2\n      );\n    }\n  }\n\n  /**\n   * Convert canvas to blob\n   */\n  private canvasToBlob(canvas: HTMLCanvasElement, type: string, quality?: number): Promise<Blob> {\n    // Check if canvas has valid dimensions\n    if (canvas.width <= 0 || canvas.height <= 0) {\n      throw new Error(`Invalid canvas dimensions: ${canvas.width}x${canvas.height}`);\n    }\n\n    // Check if canvas is too large (some browsers have limits)\n    const maxDimension = 32767; // Common browser limit\n    if (canvas.width > maxDimension || canvas.height > maxDimension) {\n      throw new Error(`Canvas dimensions too large: ${canvas.width}x${canvas.height}. Max: ${maxDimension}x${maxDimension}`);\n    }\n\n    return new Promise((resolve, reject) => {\n      try {\n        canvas.toBlob((blob) => {\n          if (blob) {\n            resolve(blob);\n          } else {\n            reject(new Error('Failed to create blob from canvas - toBlob returned null'));\n          }\n  }, type, quality);\n      } catch (error) {\n        reject(new Error(`Canvas toBlob failed: ${error instanceof Error ? error.message : String(error)}`));\n      }\n    });\n  }\n\n  /**\n   * Check if WebCodecs is supported in the current browser\n   */\n  private supportsWebCodecs(): boolean {\n    return typeof window !== 'undefined' && \n           'VideoEncoder' in window && \n           'VideoFrame' in window;\n  }\n\n  /**\n   * Export video using WebCodecs API (WebM format)\n   */\n  private async exportWebMVideo(\n    data: ExportDataBundle,\n    settings: VideoExportSettings,\n    filename: string\n  ): Promise<void> {\n    this.updateProgress('Creating video frames...', 20);\n    \n    // Generate frame canvases\n    const frameCanvases = await this.generateVideoFrames(data, settings);\n    \n    if (frameCanvases.length === 0) {\n      throw new Error('No frames generated for video export');\n    }\n    \n    this.updateProgress('Encoding video...', 50);\n    \n    try {\n      // Use WebCodecs to create WebM video\n      const videoBlob = await this.encodeWebMVideo(frameCanvases, settings);\n      \n      this.updateProgress('Saving video file...', 90);\n      \n      saveAs(videoBlob, `${filename}.webm`);\n      \n      this.updateProgress('Video export complete!', 100);\n      \n    } catch (error) {\n      console.error('❌ Video encoding failed:', error);\n      throw error;\n    } finally {\n      // Clean up canvas resources\n      frameCanvases.forEach(canvas => {\n        canvas.width = 0;\n        canvas.height = 0;\n      });\n    }\n  }\n\n  /**\n   * Export video using FFmpeg.wasm (H.264 MP4)\n   */\n  private async exportMP4Fallback(\n    data: ExportDataBundle,\n    settings: VideoExportSettings,\n    filename: string\n  ): Promise<void> {\n    this.updateProgress('Initializing FFmpeg...', 10);\n    \n    try {\n      // Dynamic import of FFmpeg\n      const { FFmpeg } = await import('@ffmpeg/ffmpeg');\n      const { fetchFile } = await import('@ffmpeg/util');\n      \n      const ffmpeg = new FFmpeg();\n      \n      // Load FFmpeg core with better error handling\n      this.updateProgress('Loading FFmpeg core...', 15);\n      \n      try {\n        // Use default FFmpeg loading which handles worker files properly\n        await ffmpeg.load();\n      } catch (loadError) {\n        console.error('Failed to load FFmpeg:', loadError);\n        throw new Error(`Failed to initialize FFmpeg: ${loadError instanceof Error ? loadError.message : String(loadError)}`);\n      }\n      \n      this.updateProgress('Generating frames...', 20);\n      \n      // Generate frame canvases\n      const frameCanvases = await this.generateVideoFrames(data, settings);\n      \n      if (frameCanvases.length === 0) {\n        throw new Error('No frames generated for MP4 export');\n      }\n      \n      this.updateProgress('Converting frames to images...', 40);\n      \n      // Convert canvases to PNG files for FFmpeg\n      for (let i = 0; i < frameCanvases.length; i++) {\n        const canvas = frameCanvases[i];\n        const blob = await this.canvasToBlob(canvas, 'image/png');\n        const frameData = await fetchFile(blob);\n        \n        // Write frame to FFmpeg file system with zero-padded name\n        const frameName = `frame${i.toString().padStart(6, '0')}.png`;\n        await ffmpeg.writeFile(frameName, frameData);\n        \n        // Update progress during frame conversion\n        const progress = 40 + (i / frameCanvases.length) * 20; // 40-60%\n        this.updateProgress(`Converting frame ${i + 1}/${frameCanvases.length}...`, progress);\n      }\n      \n      this.updateProgress('Encoding H.264 MP4 video...', 70);\n      \n      // Build FFmpeg command based on your specification\n      const inputPattern = 'frame%06d.png';\n      const outputFilename = 'output.mp4';\n      \n      // Calculate frame rate (FFmpeg needs frames per second)\n      const framerate = settings.frameRate.toString();\n      \n      // Your FFmpeg command adapted for frame input:\n      const ffmpegArgs = [\n        '-framerate', framerate,        // Input framerate\n        '-i', inputPattern,             // Input pattern\n        '-map_metadata', '-1',          // Remove metadata\n        '-an',                          // No audio\n        '-c:v', 'libx264',             // H.264 codec\n        '-crf', settings.crf.toString(), // Quality (CRF value)\n        '-profile:v', 'main',           // H.264 profile\n        '-pix_fmt', 'yuv420p',         // Pixel format for compatibility\n        '-movflags', '+faststart',      // Optimize for web playback\n        '-vf', 'scale=trunc(iw/2)*2:trunc(ih/2)*2', // Ensure even dimensions\n        outputFilename\n      ];\n      \n      // Execute FFmpeg encoding\n      await ffmpeg.exec(ffmpegArgs);\n      \n      this.updateProgress('Saving MP4 file...', 90);\n      \n      // Read the output file\n      const outputData = await ffmpeg.readFile(outputFilename);\n      \n      // Create blob from FFmpeg output data\n      const uint8Array = new Uint8Array(outputData as unknown as ArrayBuffer);\n      const mp4Blob = new Blob([uint8Array.buffer], { type: 'video/mp4' });\n      \n      saveAs(mp4Blob, `${filename}.mp4`);\n      \n      this.updateProgress('MP4 export complete!', 100);\n      \n    } catch (error) {\n      console.error('❌ FFmpeg MP4 export failed:', error);\n      throw new Error(`MP4 export failed: ${error instanceof Error ? error.message : 'Unknown error'}`);\n    }\n  }\n\n  /**\n   * Generate canvas frames for video export\n   */\n  private async generateVideoFrames(\n    data: ExportDataBundle,\n    settings: VideoExportSettings\n  ): Promise<HTMLCanvasElement[]> {\n    const videoFrames: HTMLCanvasElement[] = [];\n    const originalFrames = data.frames;\n    \n    if (originalFrames.length === 0) {\n      console.warn('⚠️ No frames found in animation data');\n      return videoFrames;\n    }\n\n    // Calculate how many loops to generate\n    const loopMultiplier = this.getLoopMultiplier(settings.loops);\n    \n    // Pre-calculate video frame counts for each animation frame\n    const frameVideoFrameCounts = originalFrames.map(frame => \n      this.calculateVideoFramesForDuration(frame.duration, settings.frameRate)\n    );\n    \n    const totalVideoFrames = frameVideoFrameCounts.reduce((sum, count) => sum + count, 0) * loopMultiplier;\n    \n    let globalVideoFrameIndex = 0;\n    \n    // Generate frames for all loops\n    for (let loop = 0; loop < loopMultiplier; loop++) {\n      for (let animFrameIndex = 0; animFrameIndex < originalFrames.length; animFrameIndex++) {\n        const animationFrame = originalFrames[animFrameIndex];\n        const videoFrameCount = frameVideoFrameCounts[animFrameIndex];\n        \n        // Create high-resolution canvas for this animation frame\n        const frameCanvas = this.createExportCanvas(\n          data.canvasDimensions.width,\n          data.canvasDimensions.height,\n          settings.sizeMultiplier,\n          data.fontMetrics,\n          data.typography\n        );\n        \n        // Render the animation frame once\n        await this.renderFrame(\n          frameCanvas.canvas,\n          animationFrame.data,\n          data.canvasDimensions.width,\n          data.canvasDimensions.height,\n          {\n            backgroundColor: data.canvasBackgroundColor,\n            showGrid: settings.includeGrid && data.showGrid,\n            fontMetrics: data.fontMetrics,\n            typography: data.typography,\n            sizeMultiplier: settings.sizeMultiplier,\n            theme: data.uiState.theme,\n            scale: frameCanvas.scale\n          }\n        );\n        // Duplicate this canvas for the required number of video frames\n        for (let videoFrameIndex = 0; videoFrameIndex < videoFrameCount; videoFrameIndex++) {\n          // Clone the canvas for each video frame\n          const clonedCanvas = this.cloneCanvas(frameCanvas.canvas);\n          videoFrames.push(clonedCanvas);\n          \n          globalVideoFrameIndex++;\n          \n          // Update progress (spread across 20-50% range)\n          const progress = 20 + (globalVideoFrameIndex / totalVideoFrames) * 30;\n          this.updateProgress(\n            `Rendering video frame ${globalVideoFrameIndex}/${totalVideoFrames} (anim frame ${animFrameIndex + 1}/${originalFrames.length}, loop ${loop + 1}/${loopMultiplier})...`, \n            progress\n          );\n        }\n        \n        // Clean up the original canvas\n        frameCanvas.canvas.width = 0;\n        frameCanvas.canvas.height = 0;\n      }\n    }\n    \n    return videoFrames;\n  }\n\n  /**\n   * Calculate how many video frames an animation frame should occupy based on its duration\n   */\n  private calculateVideoFramesForDuration(durationMs: number, videoFrameRate: number): number {\n    // Convert duration to seconds, then multiply by frame rate\n    const durationSeconds = durationMs / 1000;\n    const videoFrameCount = Math.max(1, Math.round(durationSeconds * videoFrameRate));\n    return videoFrameCount;\n  }\n\n  /**\n   * Clone a canvas element\n   */\n  private cloneCanvas(originalCanvas: HTMLCanvasElement): HTMLCanvasElement {\n    const clonedCanvas = document.createElement('canvas');\n    clonedCanvas.width = originalCanvas.width;\n    clonedCanvas.height = originalCanvas.height;\n    \n    const clonedCtx = clonedCanvas.getContext('2d');\n    const originalCtx = originalCanvas.getContext('2d');\n    \n    if (clonedCtx && originalCtx) {\n      clonedCtx.drawImage(originalCanvas, 0, 0);\n    }\n    \n    return clonedCanvas;\n  }\n\n  /**\n   * Convert loop setting to numeric multiplier\n   */\n  private getLoopMultiplier(loops: VideoExportSettings['loops']): number {\n    switch (loops) {\n      case 'none': return 1;\n      case '2x': return 2;\n      case '4x': return 4;\n      case '8x': return 8;\n      default: return 1;\n    }\n  }\n\n  /**\n   * Encode frames to WebM using WebCodecs\n   */\n  private async encodeWebMVideo(\n    frames: HTMLCanvasElement[],\n    settings: VideoExportSettings\n  ): Promise<Blob> {\n    const { Muxer, ArrayBufferTarget } = await import('webm-muxer');\n    \n    const muxer = new Muxer({\n      target: new ArrayBufferTarget(),\n      video: {\n        codec: 'V_VP9',\n        width: frames[0].width,\n        height: frames[0].height,\n        frameRate: settings.frameRate\n      }\n    });\n\n    // Set up VideoEncoder for WebCodecs encoding\n    const encodedChunks: EncodedVideoChunk[] = [];\n    \n    return new Promise((resolve, reject) => {\n      const encoder = new VideoEncoder({\n        output: (chunk) => {\n          encodedChunks.push(chunk);\n          \n          // Add encoded chunk directly to muxer\n          muxer.addVideoChunk(chunk);\n          \n          // Update progress\n          const progress = 50 + (encodedChunks.length / frames.length) * 30;\n          this.updateProgress(`Encoding frame ${encodedChunks.length}/${frames.length}...`, progress);\n          \n          // Check if we've encoded all frames\n          if (encodedChunks.length === frames.length) {\n            encoder.close();\n            muxer.finalize();\n            const buffer = muxer.target.buffer;\n            resolve(new Blob([buffer], { type: 'video/webm' }));\n          }\n        },\n        error: (error) => {\n          console.error('VideoEncoder error:', error);\n          encoder.close();\n          reject(error);\n        }\n      });\n\n      // Configure the encoder\n      encoder.configure({\n        codec: 'vp09.00.10.08', // VP9 codec\n        width: frames[0].width,\n        height: frames[0].height,\n        framerate: settings.frameRate,\n        bitrate: this.getBitrateForQuality(settings.quality, frames[0].width, frames[0].height)\n      });\n\n      // Encode each frame\n      for (let i = 0; i < frames.length; i++) {\n        const canvas = frames[i];\n        \n        // Create VideoFrame from canvas\n        const frame = new VideoFrame(canvas, {\n          timestamp: (i * 1000000) / settings.frameRate // microseconds\n        });\n        \n        // Encode the frame\n        encoder.encode(frame, { keyFrame: i === 0 || i % 30 === 0 }); // Keyframe every 30 frames\n        \n        // Clean up the frame\n        frame.close();\n      }\n      \n      // Finish encoding\n      encoder.flush();\n    });\n  }\n\n  /**\n   * Get bitrate based on quality setting and resolution\n   */\n  private getBitrateForQuality(quality: VideoExportSettings['quality'], width: number, height: number): number {\n    const pixelCount = width * height;\n    const baseRate = pixelCount / 1000; // Base rate per 1000 pixels\n    \n    switch (quality) {\n      case 'low':\n        return Math.max(500000, baseRate * 200); // Minimum 500kbps\n      case 'medium':\n        return Math.max(1000000, baseRate * 400); // Minimum 1Mbps  \n      case 'high':\n        return Math.max(2000000, baseRate * 800); // Minimum 2Mbps\n      default:\n        return Math.max(1000000, baseRate * 400);\n    }\n  }\n\n  /**\n   * Update export progress\n   */\n  private updateProgress(message: string, percentage: number): void {\n    if (this.progressCallback) {\n      this.progressCallback({\n        message,\n        progress: percentage,\n        stage: percentage < 100 ? 'processing' : 'complete'\n      });\n    }\n  }\n}","usedDeprecatedRules":[]},{"filePath":"/Users/cameronfoxly/GitHubRepos/Ascii-Motion/src/utils/fillArea.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/cameronfoxly/GitHubRepos/Ascii-Motion/src/utils/flipUtils.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/cameronfoxly/GitHubRepos/Ascii-Motion/src/utils/font/fontLoader.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'error' is defined but never used.","line":158,"column":18,"nodeType":null,"messageId":"unusedVar","endLine":158,"endColumn":23}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Font Loader for ASCII Motion\n * \n * Handles loading, caching, and managing opentype.js fonts for SVG export.\n * Provides robust error handling and fallback mechanisms.\n */\n\nimport { load } from 'opentype.js';\nimport type { Font } from 'opentype.js';\nimport type { LoadedFont, FontLoadOptions, FontLoadErrorDetail } from './types';\nimport { FONT_REGISTRY, getFontMetadata } from './fontRegistry';\n\n/**\n * Singleton font loader class\n */\nclass FontLoader {\n  private fontCache: Map<string, LoadedFont> = new Map();\n  private loadingPromises: Map<string, Promise<LoadedFont>> = new Map();\n  private initialized = false;\n\n  /**\n   * Load a font by ID from the registry\n   */\n  async loadFont(\n    fontId: string,\n    options: FontLoadOptions = {}\n  ): Promise<LoadedFont> {\n    const { cache = true, timeout = 10000 } = options;\n\n    // Check cache first\n    if (cache && this.fontCache.has(fontId)) {\n      return this.fontCache.get(fontId)!;\n    }\n\n    // Check if already loading\n    if (this.loadingPromises.has(fontId)) {\n      return this.loadingPromises.get(fontId)!;\n    }\n\n    // Get font metadata\n    const metadata = getFontMetadata(fontId);\n    if (!metadata) {\n      throw this.createError('not-found', `Font ID \"${fontId}\" not found in registry`, fontId);\n    }\n\n    // Start loading with timeout\n    const loadPromise = this.loadFontFile(metadata.path, fontId, timeout);\n    this.loadingPromises.set(fontId, loadPromise);\n\n    try {\n      const loadedFont = await loadPromise;\n\n      // Cache if requested\n      if (cache) {\n        this.fontCache.set(fontId, loadedFont);\n      }\n\n      return loadedFont;\n    } catch (error) {\n      throw this.handleLoadError(error, fontId);\n    } finally {\n      this.loadingPromises.delete(fontId);\n    }\n  }\n\n  /**\n   * Load a font file from a path\n   */\n  private async loadFontFile(\n    path: string,\n    fontId: string,\n    timeout: number\n  ): Promise<LoadedFont> {\n    return new Promise((resolve, reject) => {\n      const timeoutId = setTimeout(() => {\n        reject(this.createError('timeout', `Font loading timed out after ${timeout}ms`, fontId));\n      }, timeout);\n\n      load(path, (err, font) => {\n        clearTimeout(timeoutId);\n\n        if (err) {\n          reject(this.createError('parse-error', `Failed to parse font: ${err.message}`, fontId, err));\n          return;\n        }\n\n        if (!font) {\n          reject(this.createError('invalid-font', 'Font loaded but is invalid', fontId));\n          return;\n        }\n\n        const metadata = getFontMetadata(fontId)!;\n        const loadedFont: LoadedFont = {\n          font,\n          family: font.names.fontFamily.en || metadata.name,\n          fileName: metadata.fileName,\n          metadata,\n        };\n\n        resolve(loadedFont);\n      });\n    });\n  }\n\n  /**\n   * Preload all bundled fonts\n   */\n  async preloadBundledFonts(): Promise<void> {\n    if (this.initialized) {\n      return;\n    }\n\n    const loadPromises = FONT_REGISTRY.map(async (metadata) => {\n      try {\n        await this.loadFont(metadata.id, { cache: true, timeout: 15000 });\n      } catch (error) {\n        // Font loading failed, but we'll continue with other fonts\n        console.error(`Failed to load ${metadata.name}:`, error);\n      }\n    });\n\n    await Promise.allSettled(loadPromises);\n    this.initialized = true;\n  }\n\n  /**\n   * Get a font by family name (with fuzzy matching)\n   */\n  async getFontForFamily(familyName: string): Promise<Font | null> {\n    const normalizedFamily = familyName.toLowerCase().trim();\n\n    // Check cache for exact or fuzzy match\n    for (const loadedFont of this.fontCache.values()) {\n      const fontFamilyLower = loadedFont.family.toLowerCase();\n      const metadataNameLower = loadedFont.metadata.name.toLowerCase();\n\n      if (\n        fontFamilyLower.includes(normalizedFamily) ||\n        normalizedFamily.includes(fontFamilyLower) ||\n        metadataNameLower.includes(normalizedFamily) ||\n        normalizedFamily.includes(metadataNameLower)\n      ) {\n        return loadedFont.font;\n      }\n    }\n\n    // Try to load fonts that might match\n    for (const metadata of FONT_REGISTRY) {\n      const metadataNameLower = metadata.name.toLowerCase();\n      \n      if (\n        metadataNameLower.includes(normalizedFamily) ||\n        normalizedFamily.includes(metadataNameLower)\n      ) {\n        try {\n          const loadedFont = await this.loadFont(metadata.id);\n          return loadedFont.font;\n        } catch (error) {\n          // Font loading failed, continue to next candidate\n        }\n      }\n    }\n\n    return null;\n  }\n\n  /**\n   * Get a loaded font by ID\n   */\n  getLoadedFont(fontId: string): LoadedFont | null {\n    return this.fontCache.get(fontId) || null;\n  }\n\n  /**\n   * Check if a font is loaded\n   */\n  isFontLoaded(fontId: string): boolean {\n    return this.fontCache.has(fontId);\n  }\n\n  /**\n   * Clear font cache\n   */\n  clearCache(): void {\n    this.fontCache.clear();\n    this.loadingPromises.clear();\n    this.initialized = false;\n  }\n\n  /**\n   * Get cache statistics\n   */\n  getCacheStats() {\n    return {\n      cachedFonts: this.fontCache.size,\n      loadingFonts: this.loadingPromises.size,\n      initialized: this.initialized,\n      availableFonts: FONT_REGISTRY.length,\n    };\n  }\n\n  /**\n   * Create a standardized error object\n   */\n  private createError(\n    type: FontLoadErrorDetail['type'],\n    message: string,\n    fontId?: string,\n    originalError?: Error\n  ): FontLoadErrorDetail {\n    return {\n      type,\n      message,\n      fontId,\n      originalError,\n    };\n  }\n\n  /**\n   * Handle and normalize load errors\n   */\n  private handleLoadError(error: unknown, fontId: string): FontLoadErrorDetail {\n    if (error && typeof error === 'object' && 'type' in error) {\n      return error as FontLoadErrorDetail;\n    }\n\n    if (error instanceof Error) {\n      if (error.message.includes('network')) {\n        return this.createError('network-error', error.message, fontId, error);\n      }\n      if (error.message.includes('timeout')) {\n        return this.createError('timeout', error.message, fontId, error);\n      }\n      return this.createError('unknown', error.message, fontId, error);\n    }\n\n    return this.createError('unknown', 'Unknown error occurred', fontId);\n  }\n}\n\n// Export singleton instance\nexport const fontLoader = new FontLoader();\n\n// Export class for testing\nexport { FontLoader };\n","usedDeprecatedRules":[]},{"filePath":"/Users/cameronfoxly/GitHubRepos/Ascii-Motion/src/utils/font/fontRegistry.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/cameronfoxly/GitHubRepos/Ascii-Motion/src/utils/font/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/cameronfoxly/GitHubRepos/Ascii-Motion/src/utils/font/opentypePathConverter.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/cameronfoxly/GitHubRepos/Ascii-Motion/src/utils/font/types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/cameronfoxly/GitHubRepos/Ascii-Motion/src/utils/fontMetrics.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/cameronfoxly/GitHubRepos/Ascii-Motion/src/utils/frameUtils.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/cameronfoxly/GitHubRepos/Ascii-Motion/src/utils/gradientEngine.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/cameronfoxly/GitHubRepos/Ascii-Motion/src/utils/gridColor.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/cameronfoxly/GitHubRepos/Ascii-Motion/src/utils/jsonImporter.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":56,"column":41,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":56,"endColumn":44,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1687,1690],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1687,1690],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":104,"column":15,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":104,"endColumn":18,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3634,3637],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3634,3637],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":139,"column":62,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":139,"endColumn":65,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4998,5001],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4998,5001],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { useCanvasStore } from '../stores/canvasStore';\nimport { useAnimationStore } from '../stores/animationStore';\nimport type { Cell } from '../types';\nimport { DEFAULT_FRAME_DURATION } from '../constants';\n\n/**\n * JSON Import Utility\n * Handles loading and restoring data from human-readable JSON files exported by ASCII Motion\n */\nexport class JsonImporter {\n  \n  /**\n   * Import project data from a JSON file\n   */\n  static async importJsonFile(\n    file: File, \n    typographyCallbacks?: {\n      setFontSize: (size: number) => void;\n      setCharacterSpacing: (spacing: number) => void;\n      setLineSpacing: (spacing: number) => void;\n    }\n  ): Promise<void> {\n    return new Promise((resolve, reject) => {\n      const reader = new FileReader();\n      \n      reader.onload = (event) => {\n        try {\n          const content = event.target?.result as string;\n          const jsonData = JSON.parse(content);\n          \n          // Validate JSON data structure\n          if (!JsonImporter.validateJsonData(jsonData)) {\n            throw new Error('Invalid JSON file format or structure');\n          }\n          \n          // Import the JSON data\n          JsonImporter.restoreJsonData(jsonData, typographyCallbacks);\n          \n          resolve();\n        } catch (error) {\n          reject(new Error(`Failed to import JSON: ${error instanceof Error ? error.message : 'Unknown error'}`));\n        }\n      };\n      \n      reader.onerror = () => {\n        reject(new Error('Failed to read file'));\n      };\n      \n      reader.readAsText(file);\n    });\n  }\n  \n    /**\n   * Validate JSON data structure for the new text-based format\n   */\n  private static validateJsonData(data: any): boolean {\n    try {\n      // Check top-level structure\n      if (typeof data !== 'object' || data === null) return false;\n      if (!data.canvas || typeof data.canvas !== 'object') return false;\n      if (!data.frames || !Array.isArray(data.frames)) return false;\n      \n      // Validate canvas settings\n      if (typeof data.canvas.width !== 'number' || typeof data.canvas.height !== 'number') return false;\n      \n      // Validate typography (optional)\n      if (data.typography) {\n        if (typeof data.typography.fontSize !== 'number') return false;\n        if (typeof data.typography.characterSpacing !== 'number') return false;\n        if (typeof data.typography.lineSpacing !== 'number') return false;\n      }\n      \n      // Validate frames\n      for (const frame of data.frames) {\n        if (typeof frame !== 'object' || frame === null) return false;\n        if (typeof frame.title !== 'string') return false;\n        if (typeof frame.duration !== 'number') return false;\n\n        const contentField = frame.content ?? frame.contentString;\n        const isStringContent = typeof contentField === 'string';\n        const isArrayContent = Array.isArray(contentField) && contentField.every((line: unknown) => typeof line === 'string');\n        if (!isStringContent && !isArrayContent) return false;\n        \n        // Validate colors (optional)\n        if (frame.colors) {\n          if (typeof frame.colors !== 'object') return false;\n\n          const { foreground, background } = frame.colors;\n          if (foreground && typeof foreground !== 'object' && typeof foreground !== 'string') return false;\n          if (background && typeof background !== 'object' && typeof background !== 'string') return false;\n        }\n      }\n      \n      return true;\n    } catch {\n      return false;\n    }\n  }\n  \n  /**\n   * Restore JSON data to application stores for text-based format\n   */\n  private static restoreJsonData(\n    jsonData: any, \n    typographyCallbacks?: {\n      setFontSize: (size: number) => void;\n      setCharacterSpacing: (spacing: number) => void;\n      setLineSpacing: (spacing: number) => void;\n    }\n  ): void {\n    const canvasStore = useCanvasStore.getState();\n    const animationStore = useAnimationStore.getState();\n    \n    // Restore canvas settings\n    canvasStore.setCanvasSize(jsonData.canvas.width, jsonData.canvas.height);\n    if (jsonData.canvas.backgroundColor) {\n      canvasStore.setCanvasBackgroundColor(jsonData.canvas.backgroundColor);\n    }\n    \n    // Clear current canvas\n    canvasStore.clearCanvas();\n    \n    // Restore typography settings if available\n    if (jsonData.typography && typographyCallbacks) {\n      if (jsonData.typography.fontSize) {\n        typographyCallbacks.setFontSize(jsonData.typography.fontSize);\n      }\n      if (jsonData.typography.characterSpacing !== undefined) {\n        typographyCallbacks.setCharacterSpacing(jsonData.typography.characterSpacing);\n      }\n      if (jsonData.typography.lineSpacing !== undefined) {\n        typographyCallbacks.setLineSpacing(jsonData.typography.lineSpacing);\n      }\n    }\n    \n    // Process frames from text content\n    if (jsonData.frames && jsonData.frames.length > 0) {\n      // Convert text-based frames to internal format\n      const importedFrames = jsonData.frames.map((frameData: any, index: number) => {\n        // Parse the text content into cells\n        const contentField = frameData.content ?? frameData.contentString;\n        const lines: string[] = Array.isArray(contentField)\n          ? contentField\n          : typeof contentField === 'string'\n            ? contentField.split('\\n')\n            : [];\n\n        const parseColorMap = (input: unknown): Record<string, string> => {\n          if (!input) return {};\n          if (typeof input === 'string') {\n            try {\n              const parsed = JSON.parse(input);\n              return typeof parsed === 'object' && parsed !== null\n                ? parsed as Record<string, string>\n                : {};\n            } catch {\n              return {};\n            }\n          }\n          if (typeof input === 'object' && input !== null) {\n            return input as Record<string, string>;\n          }\n          return {};\n        };\n\n        const foregroundMap = parseColorMap(frameData.colors?.foreground);\n        const backgroundMap = parseColorMap(frameData.colors?.background);\n\n        const frameMap = new Map<string, Cell>();\n        \n        lines.forEach((line: string, y: number) => {\n          [...line].forEach((character: string, x: number) => {\n            if (character !== ' ' && character !== '') {\n              const cellKey = `${x},${y}`;\n              \n              // Start with default colors\n              let foregroundColor = '#FFFFFF';\n              let backgroundColor = 'transparent';\n              \n              // Apply colors from color data\n              if (foregroundMap[cellKey]) {\n                foregroundColor = foregroundMap[cellKey];\n              }\n              if (backgroundMap[cellKey]) {\n                backgroundColor = backgroundMap[cellKey];\n              }\n              \n              frameMap.set(cellKey, {\n                char: character,\n                color: foregroundColor,\n                bgColor: backgroundColor\n              });\n            }\n          });\n        });\n        \n        return {\n          id: `frame-${index}`,\n          name: frameData.title || `Frame ${index}`,\n          duration: frameData.duration || DEFAULT_FRAME_DURATION,\n          data: frameMap\n        };\n      });\n      \n      // Import the frames using the session import method\n      animationStore.importSessionFrames(importedFrames);\n      \n      // Restore animation settings\n      if (jsonData.animation) {\n        if (jsonData.animation.frameRate) {\n          animationStore.setFrameRate(jsonData.animation.frameRate);\n        }\n        if (jsonData.animation.looping !== undefined) {\n          animationStore.setLooping(jsonData.animation.looping);\n        }\n        if (jsonData.animation.currentFrame !== undefined) {\n          animationStore.setCurrentFrame(jsonData.animation.currentFrame);\n        } else {\n          animationStore.setCurrentFrame(0);\n        }\n      } else {\n        // Default to first frame\n        animationStore.setCurrentFrame(0);\n      }\n      \n      // Load the current frame's data into the canvas\n      const animationState = useAnimationStore.getState();\n      const currentFrameIndex = animationState.currentFrameIndex;\n      const currentFrame = animationState.frames[currentFrameIndex];\n      if (currentFrame && currentFrame.data) {\n        canvasStore.clearCanvas();\n        currentFrame.data.forEach((cell, key) => {\n          const [x, y] = key.split(',').map(Number);\n          canvasStore.setCell(x, y, cell);\n        });\n      }\n    }\n  }\n}\n\n/**\n * Hook for JSON import functionality\n */\nexport const useJsonImporter = () => {\n  const importJson = async (\n    file: File, \n    typographyCallbacks?: {\n      setFontSize: (size: number) => void;\n      setCharacterSpacing: (spacing: number) => void;\n      setLineSpacing: (spacing: number) => void;\n    }\n  ): Promise<void> => {\n    try {\n      await JsonImporter.importJsonFile(file, typographyCallbacks);\n    } catch (error) {\n      console.error('JSON import failed:', error);\n      throw error;\n    }\n  };\n  \n  return { importJson };\n};","usedDeprecatedRules":[]},{"filePath":"/Users/cameronfoxly/GitHubRepos/Ascii-Motion/src/utils/mediaProcessor.ts","messages":[{"ruleId":"@typescript-eslint/ban-ts-comment","severity":2,"message":"Use \"@ts-expect-error\" instead of \"@ts-ignore\", as \"@ts-ignore\" will do nothing if the following line is error-free.","line":12,"column":1,"nodeType":"Line","messageId":"tsIgnoreInsteadOfExpectError","endLine":12,"endColumn":66,"suggestions":[{"messageId":"replaceTsIgnoreWithTsExpectError","fix":{"range":[325,390],"text":"// @ts-expect-error - mp4box doesn't have proper TypeScript definitions"},"desc":"Replace \"@ts-ignore\" with \"@ts-expect-error\"."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'error' is defined but never used.","line":347,"column":14,"nodeType":null,"messageId":"unusedVar","endLine":347,"endColumn":19},{"ruleId":"no-empty","severity":2,"message":"Empty block statement.","line":347,"column":21,"nodeType":"BlockStatement","messageId":"unexpected","endLine":349,"endColumn":6,"suggestions":[{"messageId":"suggestComment","data":{"type":"block"},"fix":{"range":[9633,9639],"text":" /* empty */ "},"desc":"Add comment inside empty block statement."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'error' is defined but never used.","line":365,"column":14,"nodeType":null,"messageId":"unusedVar","endLine":365,"endColumn":19},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":376,"column":37,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":376,"endColumn":40,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[10354,10357],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[10354,10357],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":379,"column":35,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":379,"endColumn":38,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[10445,10448],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[10445,10448],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":428,"column":37,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":428,"endColumn":40,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[12102,12105],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[12102,12105],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":7,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * MediaProcessor - Core utility for processing image and video files for ASCII conversion\n * \n * Handles:\n * - File loading and validation\n * - Image/video frame extraction\n * - Basic image processing operations (resize, crop)\n * - Canvas conversion for ASCII processing\n * - Error handling for unsupported formats\n */\n\n// @ts-ignore - mp4box doesn't have proper TypeScript definitions\nimport * as MP4Box from 'mp4box';\n\nexport interface MediaFile {\n  file: File;\n  type: 'image' | 'video';\n  name: string;\n  size: number;\n  duration?: number; // For video files\n  frameCount?: number; // For video files\n}\n\nexport interface ProcessingOptions {\n  // Size controls\n  targetWidth: number;  // Character width\n  targetHeight: number; // Character height\n  \n  // Basic processing options\n  maintainAspectRatio: boolean;\n  cropMode: 'center' | 'top' | 'bottom' | 'left' | 'right' | 'top-left' | 'top-right' | 'bottom-left' | 'bottom-right';\n  \n  // Quality settings\n  quality: 'high' | 'medium' | 'low';\n}\n\nexport interface ProcessedFrame {\n  canvas: HTMLCanvasElement;\n  imageData: ImageData;\n  timestamp?: number; // For video frames\n  frameIndex?: number; // For video frames\n  frameDuration?: number; // Duration in milliseconds (for video frames)\n}\n\nexport interface ProcessingResult {\n  success: boolean;\n  frames: ProcessedFrame[];\n  metadata: {\n    originalWidth: number;\n    originalHeight: number;\n    processedWidth: number;\n    processedHeight: number;\n    frameCount: number;\n    duration?: number;\n    frameRate?: number; // Original video frame rate\n  };\n  error?: string;\n}\n\n/**\n * Supported file formats for import\n */\nexport const SUPPORTED_IMAGE_FORMATS = [\n  'image/jpeg',\n  'image/jpg', \n  'image/png',\n  'image/gif',\n  'image/bmp',\n  'image/webp',\n  'image/svg+xml'\n];\n\nexport const SUPPORTED_VIDEO_FORMATS = [\n  'video/mp4',\n  'video/webm',\n  'video/ogg',\n  'video/avi',\n  'video/mov',\n  'video/quicktime', // MOV files typically use this MIME type\n  'video/wmv'\n];\n\nexport const ALL_SUPPORTED_FORMATS = [\n  ...SUPPORTED_IMAGE_FORMATS,\n  ...SUPPORTED_VIDEO_FORMATS\n];\n\nexport class MediaProcessor {\n  private canvas: HTMLCanvasElement;\n  private ctx: CanvasRenderingContext2D;\n  \n  constructor() {\n    this.canvas = document.createElement('canvas');\n    const ctx = this.canvas.getContext('2d');\n    if (!ctx) {\n      throw new Error('Failed to create canvas context for media processing');\n    }\n    this.ctx = ctx;\n  }\n\n  /**\n   * Validate and classify uploaded file\n   */\n  validateFile(file: File): MediaFile | null {\n    const isImage = SUPPORTED_IMAGE_FORMATS.includes(file.type);\n    const isVideo = SUPPORTED_VIDEO_FORMATS.includes(file.type);\n    \n    if (!isImage && !isVideo) {\n      return null;\n    }\n\n    return {\n      file,\n      type: isImage ? 'image' : 'video',\n      name: file.name,\n      size: file.size\n    };\n  }\n\n  /**\n   * Process image file and convert to canvas frames\n   */\n  async processImage(mediaFile: MediaFile, options: ProcessingOptions): Promise<ProcessingResult> {\n    try {\n      const img = await this.loadImage(mediaFile.file);\n      const processedFrame = this.processImageToCanvas(img, options);\n      \n      return {\n        success: true,\n        frames: [processedFrame],\n        metadata: {\n          originalWidth: img.width,\n          originalHeight: img.height,\n          processedWidth: processedFrame.canvas.width,\n          processedHeight: processedFrame.canvas.height,\n          frameCount: 1\n        }\n      };\n    } catch (error) {\n      return {\n        success: false,\n        frames: [],\n        metadata: {\n          originalWidth: 0,\n          originalHeight: 0,\n          processedWidth: 0,\n          processedHeight: 0,\n          frameCount: 0\n        },\n        error: error instanceof Error ? error.message : 'Unknown error processing image'\n      };\n    }\n  }\n\n  /**\n   * Process video file and extract frames\n   */\n  async processVideo(mediaFile: MediaFile, options: ProcessingOptions): Promise<ProcessingResult> {\n    try {\n      const video = await this.loadVideo(mediaFile.file);\n      const { frames, detectedFrameRate } = await this.extractVideoFrames(video, options, mediaFile.file);\n      \n      return {\n        success: true,\n        frames,\n        metadata: {\n          originalWidth: video.videoWidth,\n          originalHeight: video.videoHeight,\n          processedWidth: frames[0]?.canvas.width || 0,\n          processedHeight: frames[0]?.canvas.height || 0,\n          frameCount: frames.length,\n          duration: video.duration,\n          frameRate: detectedFrameRate\n        }\n      };\n    } catch (error) {\n      return {\n        success: false,\n        frames: [],\n        metadata: {\n          originalWidth: 0,\n          originalHeight: 0,\n          processedWidth: 0,\n          processedHeight: 0,\n          frameCount: 0\n        },\n        error: error instanceof Error ? error.message : 'Unknown error processing video'\n      };\n    }\n  }\n\n  /**\n   * Load image file into HTMLImageElement\n   */\n  private loadImage(file: File): Promise<HTMLImageElement> {\n    return new Promise((resolve, reject) => {\n      const img = new Image();\n      img.onload = () => resolve(img);\n      img.onerror = () => reject(new Error(`Failed to load image: ${file.name}`));\n      img.src = URL.createObjectURL(file);\n    });\n  }\n\n  /**\n   * Load video file into HTMLVideoElement\n   */\n  private loadVideo(file: File): Promise<HTMLVideoElement> {\n    return new Promise((resolve, reject) => {\n      const video = document.createElement('video');\n      video.preload = 'metadata';\n      \n      video.onloadedmetadata = () => {\n        resolve(video);\n      };\n      \n      video.onerror = () => {\n        reject(new Error(`Failed to load video: ${file.name}`));\n      };\n      \n      video.src = URL.createObjectURL(file);\n    });\n  }\n\n  /**\n   * Process image to canvas with resize and crop options\n   */\n  private processImageToCanvas(img: HTMLImageElement, options: ProcessingOptions): ProcessedFrame {\n    const { targetWidth, targetHeight, maintainAspectRatio, cropMode } = options;\n    \n    // Set canvas to target size (this is what the user wants)\n    this.canvas.width = targetWidth;\n    this.canvas.height = targetHeight;\n    \n    // Clear canvas\n    this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);\n    \n    if (maintainAspectRatio) {\n      // Apply crop settings to fill the canvas while maintaining aspect ratio\n      const sourceRect = this.calculateSourceRect(\n        img.width,\n        img.height,\n        targetWidth,\n        targetHeight,\n        cropMode,\n        maintainAspectRatio\n      );\n      \n      // Draw cropped image to fill the entire canvas\n      this.ctx.drawImage(\n        img,\n        sourceRect.x,\n        sourceRect.y,\n        sourceRect.width,\n        sourceRect.height,\n        0,\n        0,\n        targetWidth,\n        targetHeight\n      );\n    } else {\n      // Stretch to fit without maintaining aspect ratio\n      this.ctx.drawImage(\n        img,\n        0,\n        0,\n        img.width,\n        img.height,\n        0,\n        0,\n        targetWidth,\n        targetHeight\n      );\n    }\n    \n    // Get image data\n    const imageData = this.ctx.getImageData(0, 0, this.canvas.width, this.canvas.height);\n    \n    // Create result canvas (clone)\n    const resultCanvas = document.createElement('canvas');\n    resultCanvas.width = this.canvas.width;\n    resultCanvas.height = this.canvas.height;\n    const resultCtx = resultCanvas.getContext('2d')!;\n    resultCtx.drawImage(this.canvas, 0, 0);\n    \n    return {\n      canvas: resultCanvas,\n      imageData\n    };\n  }\n\n  /**\n   * Extract frames from video using original frame rate\n   */\n  private async extractVideoFrames(video: HTMLVideoElement, options: ProcessingOptions, originalFile: File): Promise<{ frames: ProcessedFrame[], detectedFrameRate: number }> {\n    const frames: ProcessedFrame[] = [];\n    \n    // Try to detect frame rate or use common defaults\n    const estimatedFrameRate = await this.estimateVideoFrameRate(video, originalFile);\n    const frameDuration = Math.round(1000 / estimatedFrameRate); // Convert to milliseconds\n    \n    // Extract all frames, but limit to reasonable maximum\n    const maxFrames = Math.min(300, Math.floor(video.duration * estimatedFrameRate)); // Cap at 300 frames\n    \n\n    \n    for (let i = 0; i < maxFrames; i++) {\n      const timestamp = i / estimatedFrameRate;\n      \n      // Stop if we exceed video duration\n      if (timestamp >= video.duration) break;\n      \n      video.currentTime = timestamp;\n      \n      // Wait for video to seek to the correct time with timeout\n      await new Promise<void>((resolve) => {\n        const timeout = setTimeout(() => resolve(), 200); // 200ms timeout\n        video.onseeked = () => {\n          clearTimeout(timeout);\n          resolve();\n        };\n      });\n      \n      // Small delay to ensure frame is ready\n      await new Promise(resolve => setTimeout(resolve, 10));\n      \n      // Process current frame\n      const processedFrame = this.processVideoFrameToCanvas(video, options, timestamp, i, frameDuration);\n      frames.push(processedFrame);\n    }\n    \n\n    \n    return { frames, detectedFrameRate: estimatedFrameRate };\n  }\n\n  /**\n   * Extract frame rate from video file metadata\n   */\n  private async estimateVideoFrameRate(video: HTMLVideoElement, originalFile: File): Promise<number> {\n    try {\n      // Attempt to get frame rate from video metadata\n      const frameRate = await this.extractFrameRateFromMetadata(video, originalFile);\n      if (frameRate > 0) {\n\n        return frameRate;\n      }\n    } catch (error) {\n\n    }\n\n    // Fallback to common frame rate\n\n    return 30;\n  }\n\n  /**\n   * Extract frame rate from video file metadata using MP4Box\n   */\n  private async extractFrameRateFromMetadata(_video: HTMLVideoElement, originalFile: File): Promise<number> {\n    try {\n      // Use the original file directly instead of fetching from blob URL\n      const arrayBuffer = await originalFile.arrayBuffer();\n      \n      return await this.parseMP4FrameRate(arrayBuffer);\n    } catch (error) {\n\n      return 0;\n    }\n  }\n\n  /**\n   * Parse MP4 file to extract framerate using MP4Box\n   */\n  private parseMP4FrameRate(arrayBuffer: ArrayBuffer): Promise<number> {\n    return new Promise((resolve) => {\n      const mp4boxFile = (MP4Box as any).createFile();\n      \n      // Set up event handlers\n      mp4boxFile.onReady = (info: any) => {\n\n        \n        // Look for video tracks\n        const videoTrack = info.videoTracks?.[0];\n        if (videoTrack) {\n          // Calculate frame rate from track info\n          let frameRate = 0;\n          \n          if (videoTrack.movie_timescale && videoTrack.movie_duration) {\n            const durationInSeconds = videoTrack.movie_duration / videoTrack.movie_timescale;\n            if (videoTrack.nb_samples && durationInSeconds > 0) {\n              frameRate = videoTrack.nb_samples / durationInSeconds;\n            }\n          }\n          \n          // Alternative: use timescale if available\n          if (!frameRate && videoTrack.timescale) {\n            // Many videos store frame rate info in the timescale\n            const commonRates = [23.976, 24, 25, 29.97, 30, 50, 59.94, 60];\n            \n            // Check if timescale matches common frame rates\n            for (const rate of commonRates) {\n              if (Math.abs(videoTrack.timescale / 1000 - rate) < 1) {\n                frameRate = rate;\n                break;\n              }\n            }\n            \n            // If no match, try direct calculation\n            if (!frameRate && videoTrack.timescale > 1000) {\n              frameRate = videoTrack.timescale / 1000;\n            }\n          }\n          \n\n          resolve(frameRate > 0 && frameRate <= 120 ? frameRate : 0);\n        } else {\n\n          resolve(0);\n        }\n      };\n      \n      mp4boxFile.onError = () => {\n        // MP4Box parsing failed, use default framerate\n        resolve(0);\n      };\n      \n      // Convert ArrayBuffer to the format MP4Box expects\n      const buffer = arrayBuffer as any;\n      buffer.fileStart = 0;\n      \n      // Append data and flush\n      mp4boxFile.appendBuffer(buffer);\n      mp4boxFile.flush();\n    });\n  }\n\n  /**\n   * Process single video frame to canvas\n   */\n  private processVideoFrameToCanvas(\n    video: HTMLVideoElement, \n    options: ProcessingOptions, \n    timestamp: number, \n    frameIndex: number,\n    frameDuration: number\n  ): ProcessedFrame {\n    const { targetWidth, targetHeight, maintainAspectRatio, cropMode } = options;\n    \n    // Set canvas to target size (this is what the user wants)\n    this.canvas.width = targetWidth;\n    this.canvas.height = targetHeight;\n    \n    // Clear canvas\n    this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);\n    \n    if (maintainAspectRatio) {\n      // Apply crop settings to fill the canvas while maintaining aspect ratio\n      const sourceRect = this.calculateSourceRect(\n        video.videoWidth,\n        video.videoHeight,\n        targetWidth,\n        targetHeight,\n        cropMode,\n        maintainAspectRatio\n      );\n      \n      // Draw cropped video frame to fill the entire canvas\n      this.ctx.drawImage(\n        video,\n        sourceRect.x,\n        sourceRect.y,\n        sourceRect.width,\n        sourceRect.height,\n        0,\n        0,\n        targetWidth,\n        targetHeight\n      );\n    } else {\n      // Stretch to fit without maintaining aspect ratio\n      this.ctx.drawImage(\n        video,\n        0,\n        0,\n        video.videoWidth,\n        video.videoHeight,\n        0,\n        0,\n        targetWidth,\n        targetHeight\n      );\n    }\n    \n    // Get image data\n    const imageData = this.ctx.getImageData(0, 0, this.canvas.width, this.canvas.height);\n    \n    // Create result canvas (clone)\n    const resultCanvas = document.createElement('canvas');\n    resultCanvas.width = this.canvas.width;\n    resultCanvas.height = this.canvas.height;\n    const resultCtx = resultCanvas.getContext('2d')!;\n    resultCtx.drawImage(this.canvas, 0, 0);\n    \n    return {\n      canvas: resultCanvas,\n      imageData,\n      timestamp,\n      frameIndex,\n      frameDuration\n    };\n  }\n\n  /**\n   * Calculate source rectangle for cropping\n   */\n  private calculateSourceRect(\n    sourceWidth: number,\n    sourceHeight: number,\n    targetWidth: number,\n    targetHeight: number,\n    cropMode: ProcessingOptions['cropMode'],\n    maintainAspectRatio: boolean\n  ) {\n    if (!maintainAspectRatio) {\n      return {\n        x: 0,\n        y: 0,\n        width: sourceWidth,\n        height: sourceHeight\n      };\n    }\n    \n    const sourceAspectRatio = sourceWidth / sourceHeight;\n    const targetAspectRatio = targetWidth / targetHeight;\n    \n    let cropWidth: number;\n    let cropHeight: number;\n    let cropX: number;\n    let cropY: number;\n    \n    // Calculate crop dimensions to fill target while maintaining aspect ratio\n    if (sourceAspectRatio > targetAspectRatio) {\n      // Source is wider - crop width, fit height\n      cropHeight = sourceHeight;\n      cropWidth = sourceHeight * targetAspectRatio;\n    } else {\n      // Source is taller - crop height, fit width\n      cropWidth = sourceWidth;\n      cropHeight = sourceWidth / targetAspectRatio;\n    }\n    \n    // Calculate crop position based on alignment mode\n    switch (cropMode) {\n      case 'top-left':\n        cropX = 0;\n        cropY = 0;\n        break;\n      case 'top':\n        cropX = (sourceWidth - cropWidth) / 2;\n        cropY = 0;\n        break;\n      case 'top-right':\n        cropX = sourceWidth - cropWidth;\n        cropY = 0;\n        break;\n      case 'left':\n        cropX = 0;\n        cropY = (sourceHeight - cropHeight) / 2;\n        break;\n      case 'center':\n      default:\n        cropX = (sourceWidth - cropWidth) / 2;\n        cropY = (sourceHeight - cropHeight) / 2;\n        break;\n      case 'right':\n        cropX = sourceWidth - cropWidth;\n        cropY = (sourceHeight - cropHeight) / 2;\n        break;\n      case 'bottom-left':\n        cropX = 0;\n        cropY = sourceHeight - cropHeight;\n        break;\n      case 'bottom':\n        cropX = (sourceWidth - cropWidth) / 2;\n        cropY = sourceHeight - cropHeight;\n        break;\n      case 'bottom-right':\n        cropX = sourceWidth - cropWidth;\n        cropY = sourceHeight - cropHeight;\n        break;\n    }\n    \n    return {\n      x: Math.max(0, cropX),\n      y: Math.max(0, cropY),\n      width: Math.min(cropWidth, sourceWidth),\n      height: Math.min(cropHeight, sourceHeight)\n    };\n  }\n\n  /**\n   * Clean up resources\n   */\n  dispose(): void {\n    // Clean up canvas and context\n    this.canvas.remove();\n  }\n}\n\n/**\n * Singleton instance for media processing\n */\nexport const mediaProcessor = new MediaProcessor();","usedDeprecatedRules":[]},{"filePath":"/Users/cameronfoxly/GitHubRepos/Ascii-Motion/src/utils/paletteValidation.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":24,"column":19,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":24,"endColumn":22,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[599,602],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[599,602],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'error' is defined but never used.","line":27,"column":12,"nodeType":null,"messageId":"unusedVar","endLine":27,"endColumn":17},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":74,"column":26,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":74,"endColumn":29,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2132,2135],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2132,2135],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":125,"column":45,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":125,"endColumn":48,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3564,3567],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3564,3567],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":200,"column":61,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":200,"endColumn":64,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5599,5602],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5599,5602],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":5,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// Palette validation utilities for import/export functionality\n\nimport type { PaletteExportFormat } from '../types/palette';\nimport { isValidHexColor, isPaletteExportFormat } from '../types/palette';\n\nexport interface ValidationResult {\n  isValid: boolean;\n  errors: string[];\n  warnings: string[];\n  data?: PaletteExportFormat;\n}\n\n/**\n * Validate JSON string as palette export format\n */\nexport const validatePaletteJSON = (jsonString: string): ValidationResult => {\n  const result: ValidationResult = {\n    isValid: false,\n    errors: [],\n    warnings: []\n  };\n\n  // Parse JSON\n  let parsedData: any;\n  try {\n    parsedData = JSON.parse(jsonString);\n  } catch (error) {\n    result.errors.push('Invalid JSON format. Please check the file syntax.');\n    return result;\n  }\n\n  // Check if it's an object\n  if (typeof parsedData !== 'object' || parsedData === null) {\n    result.errors.push('Palette data must be a JSON object.');\n    return result;\n  }\n\n  // Validate required fields\n  if (typeof parsedData.name !== 'string') {\n    result.errors.push('Palette must have a \"name\" field of type string.');\n  }\n\n  if (!Array.isArray(parsedData.colors)) {\n    result.errors.push('Palette must have a \"colors\" field of type array.');\n  }\n\n  // If basic structure is invalid, return early\n  if (result.errors.length > 0) {\n    return result;\n  }\n\n  // Validate palette name\n  const name = parsedData.name.trim();\n  if (name.length === 0) {\n    result.errors.push('Palette name cannot be empty.');\n  } else if (name.length > 100) {\n    result.warnings.push('Palette name is very long (over 100 characters).');\n  }\n\n  // Validate colors array\n  const colors = parsedData.colors;\n  if (colors.length === 0) {\n    result.errors.push('Palette must contain at least one color.');\n  } else if (colors.length > 256) {\n    result.warnings.push('Palette contains a very large number of colors (over 256). This may impact performance.');\n  }\n\n  // Validate each color\n  const validColors: string[] = [];\n  const invalidColors: string[] = [];\n  const duplicateColors: string[] = [];\n  const seenColors = new Set<string>();\n\n  colors.forEach((color: any, index: number) => {\n    if (typeof color !== 'string') {\n      invalidColors.push(`Color at index ${index} is not a string.`);\n      return;\n    }\n\n    const trimmedColor = color.trim();\n    if (!isValidHexColor(trimmedColor)) {\n      invalidColors.push(`Color \"${color}\" at index ${index} is not a valid hex color.`);\n      return;\n    }\n\n    const normalizedColor = trimmedColor.toUpperCase();\n    if (seenColors.has(normalizedColor)) {\n      duplicateColors.push(normalizedColor);\n    } else {\n      seenColors.add(normalizedColor);\n      validColors.push(normalizedColor);\n    }\n  });\n\n  // Add validation errors\n  if (invalidColors.length > 0) {\n    result.errors.push(...invalidColors);\n  }\n\n  // Add warnings for duplicates\n  if (duplicateColors.length > 0) {\n    result.warnings.push(`Found ${duplicateColors.length} duplicate colors that will be removed: ${duplicateColors.slice(0, 3).join(', ')}${duplicateColors.length > 3 ? '...' : ''}`);\n  }\n\n  // Check if we have any valid colors after validation\n  if (validColors.length === 0) {\n    result.errors.push('No valid colors found in the palette.');\n  }\n\n  // If no errors, mark as valid and prepare cleaned data\n  if (result.errors.length === 0) {\n    result.isValid = true;\n    result.data = {\n      name: name,\n      colors: validColors\n    };\n  }\n\n  return result;\n};\n\n/**\n * Validate palette export format object\n */\nexport const validatePaletteObject = (data: any): ValidationResult => {\n  const result: ValidationResult = {\n    isValid: false,\n    errors: [],\n    warnings: []\n  };\n\n  if (!isPaletteExportFormat(data)) {\n    result.errors.push('Invalid palette format. Expected object with \"name\" and \"colors\" fields.');\n    return result;\n  }\n\n  // Additional validation beyond type checking\n  if (data.name.trim().length === 0) {\n    result.errors.push('Palette name cannot be empty.');\n  }\n\n  if (data.colors.length === 0) {\n    result.errors.push('Palette must contain at least one color.');\n  }\n\n  if (result.errors.length === 0) {\n    result.isValid = true;\n    result.data = data;\n  }\n\n  return result;\n};\n\n/**\n * Sanitize and normalize palette data\n */\nexport const sanitizePaletteData = (data: PaletteExportFormat): PaletteExportFormat => {\n  return {\n    name: data.name.trim(),\n    colors: [...new Set(data.colors.map(color => color.toUpperCase()))] // Remove duplicates and normalize case\n  };\n};\n\n/**\n * Generate validation summary for user display\n */\nexport const getValidationSummary = (result: ValidationResult): string => {\n  const parts: string[] = [];\n\n  if (result.isValid) {\n    parts.push('✅ Valid palette format');\n    if (result.data) {\n      parts.push(`📊 ${result.data.colors.length} colors found`);\n    }\n  } else {\n    parts.push('❌ Invalid palette format');\n  }\n\n  if (result.errors.length > 0) {\n    parts.push(`🚨 ${result.errors.length} error${result.errors.length > 1 ? 's' : ''}`);\n  }\n\n  if (result.warnings.length > 0) {\n    parts.push(`⚠️ ${result.warnings.length} warning${result.warnings.length > 1 ? 's' : ''}`);\n  }\n\n  return parts.join(' • ');\n};\n\n/**\n * Common palette file extensions for validation\n */\nexport const SUPPORTED_PALETTE_EXTENSIONS = ['.json', '.palette', '.pal'] as const;\n\n/**\n * Check if filename has supported extension\n */\nexport const hasSupportedExtension = (filename: string): boolean => {\n  const extension = filename.toLowerCase().slice(filename.lastIndexOf('.'));\n  return SUPPORTED_PALETTE_EXTENSIONS.includes(extension as any);\n};\n","usedDeprecatedRules":[]},{"filePath":"/Users/cameronfoxly/GitHubRepos/Ascii-Motion/src/utils/performance.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":242,"column":14,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":242,"endColumn":17,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6257,6260],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6257,6260],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Performance measurement utilities for ASCII Motion\n * Development tools to track rendering performance and identify bottlenecks\n */\n\ninterface PerformanceMetric {\n  name: string;\n  startTime: number;\n  endTime?: number;\n  duration?: number;\n}\n\ninterface RenderMetrics {\n  renderTime: number;\n  cellCount: number;\n  fps: number;\n  timestamp: number;\n}\n\nclass PerformanceMonitor {\n  private metrics: Map<string, PerformanceMetric> = new Map();\n  private renderHistory: RenderMetrics[] = [];\n  private frameCount = 0;\n  private lastFrameTime = 0;\n  private isEnabled = false;\n\n  constructor() {\n    // Only enable in development\n    this.isEnabled = import.meta.env.DEV;\n  }\n\n  /**\n   * Start measuring a performance metric\n   */\n  start(name: string): void {\n    if (!this.isEnabled) return;\n\n    this.metrics.set(name, {\n      name,\n      startTime: performance.now()\n    });\n  }\n\n  /**\n   * End measuring a performance metric and return duration\n   */\n  end(name: string): number {\n    if (!this.isEnabled) return 0;\n\n    const metric = this.metrics.get(name);\n    if (!metric) {\n      console.warn(`Performance metric \"${name}\" was not started`);\n      return 0;\n    }\n\n    const endTime = performance.now();\n    const duration = endTime - metric.startTime;\n\n    metric.endTime = endTime;\n    metric.duration = duration;\n\n    return duration;\n  }\n\n  /**\n   * Measure canvas render performance\n   */\n  measureCanvasRender(cellCount: number): { duration: number; fps: number } {\n    if (!this.isEnabled) return { duration: 0, fps: 0 };\n\n    const renderTime = this.end('canvas-render');\n    const currentTime = performance.now();\n\n    // Calculate FPS\n    let fps = 0;\n    if (this.lastFrameTime > 0) {\n      const frameDelta = currentTime - this.lastFrameTime;\n      fps = Math.round(1000 / frameDelta);\n    }\n\n    this.lastFrameTime = currentTime;\n    this.frameCount++;\n\n    // Store render metrics\n    const metrics: RenderMetrics = {\n      renderTime,\n      cellCount,\n      fps,\n      timestamp: currentTime\n    };\n\n    this.renderHistory.push(metrics);\n\n    // Keep only last 100 measurements\n    if (this.renderHistory.length > 100) {\n      this.renderHistory.shift();\n    }\n\n    return { duration: renderTime, fps };\n  }\n\n  /**\n   * Get performance statistics\n   */\n  getStats(): {\n    averageRenderTime: number;\n    averageFPS: number;\n    totalRenders: number;\n    lastRenderTime: number;\n    efficiency: string;\n  } {\n    if (!this.isEnabled || this.renderHistory.length === 0) {\n      return {\n        averageRenderTime: 0,\n        averageFPS: 0,\n        totalRenders: 0,\n        lastRenderTime: 0,\n        efficiency: 'N/A'\n      };\n    }\n\n    const recent = this.renderHistory.slice(-10); // Last 10 renders\n    const avgRenderTime = recent.reduce((sum, m) => sum + m.renderTime, 0) / recent.length;\n    const avgFPS = recent.reduce((sum, m) => sum + m.fps, 0) / recent.length;\n    const lastMetric = this.renderHistory[this.renderHistory.length - 1];\n\n    let efficiency = 'Good';\n    if (avgRenderTime > 16.67) { // > 60 FPS threshold\n      efficiency = avgRenderTime > 33.33 ? 'Poor' : 'Fair'; // 30 FPS threshold\n    }\n\n    return {\n      averageRenderTime: Math.round(avgRenderTime * 100) / 100,\n      averageFPS: Math.round(avgFPS),\n      totalRenders: this.frameCount,\n      lastRenderTime: Math.round(lastMetric.renderTime * 100) / 100,\n      efficiency\n    };\n  }\n\n  /**\n   * Log performance statistics to console\n   */\n  logStats(): void {\n    if (!this.isEnabled) return;\n\n    // Performance stats logging disabled for cleaner console\n  }\n\n  /**\n   * Clear performance history\n   */\n  clear(): void {\n    this.metrics.clear();\n    this.renderHistory = [];\n    this.frameCount = 0;\n    this.lastFrameTime = 0;\n  }\n\n  /**\n   * Test large grid performance\n   */\n  async testLargeGrid(width: number, height: number): Promise<{\n    gridSize: string;\n    avgRenderTime: number;\n    recommendation: string;\n  }> {\n    if (!this.isEnabled) {\n      return {\n        gridSize: `${width}x${height}`,\n        avgRenderTime: 0,\n        recommendation: 'Performance testing disabled in production'\n      };\n    }\n\n    // Testing grid performance (logging disabled)\n\n    // Clear previous measurements\n    this.clear();\n\n    // Simulate multiple renders\n    const cellCount = width * height;\n    const testRenders = 10;\n\n    for (let i = 0; i < testRenders; i++) {\n      this.start('canvas-render');\n      \n      // Simulate render work (in real usage, this would be actual rendering)\n      await new Promise(resolve => setTimeout(resolve, 1));\n      \n      this.measureCanvasRender(cellCount);\n    }\n\n    const stats = this.getStats();\n    const recommendation = this.getRecommendation(stats.averageRenderTime, cellCount);\n\n    const result = {\n      gridSize: `${width}x${height}`,\n      avgRenderTime: stats.averageRenderTime,\n      recommendation\n    };\n\n    return result;\n  }\n\n  private getRecommendation(renderTime: number, cellCount: number): string {\n    const cellsPerMs = cellCount / Math.max(renderTime, 0.1);\n    \n    if (renderTime < 8) return `Excellent performance (${Math.round(cellsPerMs)} cells/ms) - suitable for animation`;\n    if (renderTime < 16.67) return `Good performance (${Math.round(cellsPerMs)} cells/ms) - smooth for static editing`;\n    if (renderTime < 33.33) return `Fair performance (${Math.round(cellsPerMs)} cells/ms) - consider optimizations for large grids`;\n    return `Poor performance (${Math.round(cellsPerMs)} cells/ms) - optimization required`;\n  }\n}\n\n// Global performance monitor instance\nexport const performanceMonitor = new PerformanceMonitor();\n\n// Convenience functions\nexport const measureCanvasRender = () => {\n  performanceMonitor.start('canvas-render');\n};\n\nexport const finishCanvasRender = (cellCount: number) => {\n  return performanceMonitor.measureCanvasRender(cellCount);\n};\n\nexport const logPerformanceStats = () => {\n  performanceMonitor.logStats();\n};\n\nexport const testLargeGridPerformance = (width: number, height: number) => {\n  return performanceMonitor.testLargeGrid(width, height);\n};\n\nexport const clearPerformanceHistory = () => {\n  performanceMonitor.clear();\n};\n\n// Development helper to enable performance logging in console\nif (import.meta.env.DEV) {\n  (window as any).asciiMotionPerf = {\n    monitor: performanceMonitor,\n    logStats: logPerformanceStats,\n    testGrid: testLargeGridPerformance,\n    clear: clearPerformanceHistory\n  };\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/cameronfoxly/GitHubRepos/Ascii-Motion/src/utils/polygon.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/cameronfoxly/GitHubRepos/Ascii-Motion/src/utils/renderScheduler.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/cameronfoxly/GitHubRepos/Ascii-Motion/src/utils/selectionUtils.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/cameronfoxly/GitHubRepos/Ascii-Motion/src/utils/sessionImporter.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":59,"column":44,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":59,"endColumn":47,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1849,1852],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1849,1852],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":88,"column":18,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":88,"endColumn":21,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2873,2876],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2873,2876],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":117,"column":75,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":117,"endColumn":78,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4051,4054],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4051,4054],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { useCanvasStore } from '../stores/canvasStore';\nimport { useAnimationStore } from '../stores/animationStore';\nimport { useToolStore } from '../stores/toolStore';\nimport { usePaletteStore } from '../stores/paletteStore';\nimport { useCharacterPaletteStore } from '../stores/characterPaletteStore';\nimport type { Cell } from '../types';\nimport { DEFAULT_FRAME_DURATION } from '../constants';\n\n/**\n * Session Import Utility\n * Handles loading and restoring session data from .asciimtn files\n */\nexport class SessionImporter {\n  \n  /**\n   * Import session data from a JSON file\n   */\n  static async importSessionFile(\n    file: File, \n    typographyCallbacks?: {\n      setFontSize: (size: number) => void;\n      setCharacterSpacing: (spacing: number) => void;\n      setLineSpacing: (spacing: number) => void;\n    }\n  ): Promise<void> {\n    return new Promise((resolve, reject) => {\n      const reader = new FileReader();\n      \n      reader.onload = (event) => {\n        try {\n          const content = event.target?.result as string;\n          const sessionData = JSON.parse(content);\n          \n          // Validate session data structure\n          if (!SessionImporter.validateSessionData(sessionData)) {\n            throw new Error('Invalid session file format');\n          }\n          \n          // Import the session data\n          SessionImporter.restoreSessionData(sessionData, typographyCallbacks);\n          \n          resolve();\n        } catch (error) {\n          reject(new Error(`Failed to import session: ${error instanceof Error ? error.message : 'Unknown error'}`));\n        }\n      };\n      \n      reader.onerror = () => {\n        reject(new Error('Failed to read file'));\n      };\n      \n      reader.readAsText(file);\n    });\n  }\n  \n  /**\n   * Validate session data structure\n   */\n  private static validateSessionData(data: any): boolean {\n    try {\n      // Check required top-level properties\n      if (!data || typeof data !== 'object') return false;\n      if (!data.version) return false;\n      if (!data.canvas || typeof data.canvas !== 'object') return false;\n      if (!data.animation || typeof data.animation !== 'object') return false;\n      if (!data.tools || typeof data.tools !== 'object') return false;\n      \n      // Check canvas properties\n      if (typeof data.canvas.width !== 'number' || typeof data.canvas.height !== 'number') return false;\n      \n      // Check animation properties\n      if (!Array.isArray(data.animation.frames)) return false;\n      if (typeof data.animation.currentFrameIndex !== 'number') return false;\n      \n      // Check tools properties\n      if (!data.tools.activeTool || !data.tools.selectedColor) return false;\n      \n      return true;\n    } catch {\n      return false;\n    }\n  }\n  \n  /**\n   * Restore session data to application stores\n   */\n  private static restoreSessionData(\n    sessionData: any, \n    typographyCallbacks?: {\n      setFontSize: (size: number) => void;\n      setCharacterSpacing: (spacing: number) => void;\n      setLineSpacing: (spacing: number) => void;\n    }\n  ): void {\n    const canvasStore = useCanvasStore.getState();\n    const animationStore = useAnimationStore.getState();\n    const toolStore = useToolStore.getState();\n    const paletteStore = usePaletteStore.getState();\n    const characterPaletteStore = useCharacterPaletteStore.getState();\n    \n    // Restore canvas data\n    canvasStore.setCanvasSize(sessionData.canvas.width, sessionData.canvas.height);\n    canvasStore.setCanvasBackgroundColor(sessionData.canvas.canvasBackgroundColor);\n    \n    if (sessionData.canvas.showGrid !== undefined) {\n      if (sessionData.canvas.showGrid !== canvasStore.showGrid) {\n        canvasStore.toggleGrid();\n      }\n    }\n    \n    // Clear current canvas\n    canvasStore.clearCanvas();\n    \n    // Restore animation frames\n    if (sessionData.animation.frames && sessionData.animation.frames.length > 0) {\n      // Convert session frame data preserving ALL original properties\n      const importedFrames = sessionData.animation.frames.map((frameData: any) => {\n        // Convert frame data object back to Map\n        const frameMap = new Map<string, Cell>();\n        if (frameData.data && typeof frameData.data === 'object') {\n          Object.entries(frameData.data).forEach(([key, cellData]) => {\n            if (cellData && typeof cellData === 'object') {\n              frameMap.set(key, cellData as Cell);\n            }\n          });\n        }\n        \n        // Preserve ALL original frame properties from the export\n        return {\n          id: frameData.id, // Preserve original frame ID\n          name: frameData.name || 'Untitled Frame', // Preserve original name\n          duration: frameData.duration || DEFAULT_FRAME_DURATION,\n          data: frameMap,\n          thumbnail: frameData.thumbnail // Preserve thumbnail if exists\n        };\n      });\n      \n      // Use the new session-specific import method that preserves all frame properties\n      // This is the most reliable way to ensure exact frame order preservation\n      animationStore.importSessionFrames(importedFrames);\n      \n      // Set animation properties\n      if (sessionData.animation.frameRate !== undefined) {\n        animationStore.setFrameRate(sessionData.animation.frameRate);\n      }\n      if (sessionData.animation.looping !== undefined) {\n        animationStore.setLooping(sessionData.animation.looping);\n      }\n      \n      // Always start at the first frame (index 0) when importing\n      // This ensures the user sees frame 1 content, not the original currentFrameIndex content\n      animationStore.setCurrentFrame(0);\n      \n      // Load the first frame's data into the canvas\n      const animationState = useAnimationStore.getState();\n      const firstFrame = animationState.frames[0];\n      if (firstFrame && firstFrame.data) {\n        canvasStore.clearCanvas();\n        firstFrame.data.forEach((cell, key) => {\n          const [x, y] = key.split(',').map(Number);\n          canvasStore.setCell(x, y, cell as Cell);\n        });\n      }\n    }\n    \n    // Restore tool state\n    if (sessionData.tools.activeTool) {\n      toolStore.setActiveTool(sessionData.tools.activeTool);\n    }\n    if (sessionData.tools.selectedColor) {\n      toolStore.setSelectedColor(sessionData.tools.selectedColor);\n    }\n    if (sessionData.tools.selectedBgColor) {\n      toolStore.setSelectedBgColor(sessionData.tools.selectedBgColor);\n    }\n    if (sessionData.tools.selectedCharacter) {\n      toolStore.setSelectedChar(sessionData.tools.selectedCharacter);\n    }\n    if (sessionData.tools.rectangleFilled !== undefined) {\n      toolStore.setRectangleFilled(sessionData.tools.rectangleFilled);\n    }\n\n    // Restore palette data\n    if (sessionData.palettes) {\n      paletteStore.loadSessionPalettes({\n        customPalettes: Array.isArray(sessionData.palettes.customPalettes) ? sessionData.palettes.customPalettes : [],\n        activePaletteId: sessionData.palettes.activePaletteId,\n        recentColors: sessionData.palettes.recentColors\n      });\n    }\n\n    if (sessionData.characterPalettes) {\n      characterPaletteStore.loadSessionCharacterPalettes({\n        customPalettes: Array.isArray(sessionData.characterPalettes.customPalettes) ? sessionData.characterPalettes.customPalettes : [],\n        activePaletteId: sessionData.characterPalettes.activePaletteId,\n        mappingMethod: sessionData.characterPalettes.mappingMethod,\n        invertDensity: sessionData.characterPalettes.invertDensity,\n        characterSpacing: sessionData.characterPalettes.characterSpacing\n      });\n    }\n    \n    // Restore typography settings\n    if (typographyCallbacks && sessionData.typography) {\n      if (sessionData.typography.fontSize !== undefined) {\n        typographyCallbacks.setFontSize(sessionData.typography.fontSize);\n      }\n      if (sessionData.typography.characterSpacing !== undefined) {\n        typographyCallbacks.setCharacterSpacing(sessionData.typography.characterSpacing);\n      }\n      if (sessionData.typography.lineSpacing !== undefined) {\n        typographyCallbacks.setLineSpacing(sessionData.typography.lineSpacing);\n      }\n    }\n  }\n}\n\n/**\n * Hook for session import functionality\n */\nexport const useSessionImporter = () => {\n  const importSession = async (\n    file: File, \n    typographyCallbacks?: {\n      setFontSize: (size: number) => void;\n      setCharacterSpacing: (spacing: number) => void;\n      setLineSpacing: (spacing: number) => void;\n    }\n  ): Promise<void> => {\n    try {\n      await SessionImporter.importSessionFile(file, typographyCallbacks);\n    } catch (error) {\n      console.error('Session import failed:', error);\n      throw error;\n    }\n  };\n  \n  return { importSession };\n};","usedDeprecatedRules":[]},{"filePath":"/Users/cameronfoxly/GitHubRepos/Ascii-Motion/src/utils/svgExportUtils.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/cameronfoxly/GitHubRepos/Ascii-Motion/src/utils/timeEffectsProcessing.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/cameronfoxly/GitHubRepos/Ascii-Motion/src/vite-env.d.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/cameronfoxly/GitHubRepos/Ascii-Motion/tailwind.config.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/cameronfoxly/GitHubRepos/Ascii-Motion/vite.config.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]}]